# 算法汇总



## **一、时间复杂度**

### 1、算法优劣的核心指标

时间复杂度  额外空间复杂度 常数项时间(细节)



### 2、常见的常数时间操作

加减乘除     位运算(>>  >>>   <<  |  &  ^)     赋值，比较，自增减     数组寻址

位运算简介：>>把二进制全部向右移动一位，前面第一位补没有移动前的第一位

​                    />>>前面第一位补零

n>>2  等价n/2

比如常见的冒泡，选择，插入都是O(n2)时间复杂度



### 3、确认时间复杂度

1、按照最坏情况考虑

2、把整个流程拆分为一个个基本动作，保证每个动作都是常数时间

3、数据量为n，看基本动作和n的关系

4、得到表达式后，把最高阶系数去掉并且只保留最高阶



### 4、额外的空间复杂度

和目的有关的开辟空间不算额外



### 5、对数器

用暴力解和你想出来的优解比较，验证解的准确性



## 二、二分法

### 1、普通二分查找

### 2、在一个有序的数组中找>=某个值的最左侧位置

算法：

int index=-1;

while(l<=r){

mid=(l+r)/2

if(a[mid]>=value) int =mid;r=mid-1 

else l=mid+1

}

return index;

### **3、局部最小值**

找出一个

先判断0位置和n-1位置是不是局部最小值

a[1]>a[0]或者a[n-1]<a[n-2]这两个都是局部最小值

如果端点没有，那么局部最小值一定在中间，因为先下降再上升，所以可以用二分

取mid

left=1

right=n-2

如果a[mid-1]<a[mid]那么局部最小值在mid左边，r=mid-1；

如果a[mid+1]<a[mid]在右边

反之两边都大于a[mid]，那么mid就是局部最小值的坐标，返回

结尾return left



## 三、异或运算

### 1、异或运算概念

把两个数化为二进制

然后上下对其(长的前面补零)

相同为0不同为1

比如：1001110000

​           0111101110

结果是：1110011110

这就是异或运算



### 2、性质(重点)

0^n=n;

n^n=0

满足交换律和结合律

### 3、交换两个数

int a=甲   int b=已

a=a^b       a变成甲^乙

b=a^b         甲^乙^乙=甲

a=a^b          甲^乙^甲=乙

### 4、题目

1、找出一个数组中一种数出现了奇数次，其余全是偶数

直接让数组全部异或运算,最后结果就是这个数



2、把一个int类型的数最右侧的1取出来

结论：n&(~(n)+1)

&相同为1，不同为0



3、找数组中两个数是奇数个的

假设这两个数分别是a,b

首先让数组全部异或运算，得到e=a^b

然后用上面的结合计算把e最右侧1取出来 记作w

在这个位置上，a,b两个数肯定一个是1,一个是0

然后遍历数组和w&运算,因为w只有一位为1,其余为0,

```java
public void find(int []arr){
    int eor=0;
    for(int i=0;i<arr.length;i++){
        eor=eor&arr[i];
    }
    //eor=a^b 且！=0
    int rightone=eor&(~(eor)+1);
    int onlyone=0;
    for(int i=0;i<arr.length;i++){
        if((arr[i]&(rightone))!=0){
            onlyone=onlyone^arr[i];
        }
    }
    System.out.println(onlyone+"  "+(eor^onlyone));
}
```
