# 算法错题集

## 周赛难度网站

[rating (zerotrac.github.io)](https://zerotrac.github.io/leetcode_problem_rating/#/)

## 周赛积分预测

[Search | biweekly-contest-85 | Leetcode Rating Predictor (lcpredictor.herokuapp.com)](https://lcpredictor.herokuapp.com/contest/biweekly-contest-85/ranking/search)









## 常用容器

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171710.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171808.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171857.png)

## 一、队列

### 1、单调队列

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220711182601.png" style="zoom: 67%;" />

思路，可以用一个队列，然后让他单调递减，每次滑动窗口的时候，队列末尾找，边找边删除末尾，直到遇到比这个数

大的值，入队列

同时，队列的头是这个窗口的最大值，移动了窗口，保证删除的窗口值和队列头不一样，如果一样，pop出来；

重复如此

具体代码：

```java
class Solution1 {

    LinkedList<Integer>queue;

    public int[] maxSlidingWindow(int[] nums, int k) {

        int n = nums.length;
        int[] a = new int[n + 1 - k];
        queue = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            add(nums[i]);
        }
        int index = 0;
        a[index++] = get();
        for (int i = k; i < n; i++) {
            pop(nums[i - k]);
            add(nums[i]);
            a[index++] = get();

        }

        return a;
    }
     
    //添加值到队列，找到不小于它的值才添加，边找边Pop
    public void add(int a) {

        while (queue.size() > 0 && queue.get(queue.size() - 1) < a) {
            queue.remove(queue.size() - 1);
        }

        queue.add(a);
    }

    //只有当删除的窗口值等于队列最大值，才pop
    public void pop(int a) {
        if (queue.size() > 0 && queue.get(0) == a) {
            queue.remove(0);
        }
    }
    public int get() {

        return queue.get(0);
    }

}
```

```java
class Solution {//双端队列
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> deque = new LinkedList<Integer>();
        for (int i = 0; i < k; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }

        int[] ans = new int[n - k + 1];
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            while (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

### 2、两个队列实现一个堆栈

```java

class MyStack {
    Queue<Integer>queue1;
    Queue<Integer>queue2;
    public MyStack() {
        queue1=new LinkedList<>();
        queue2=new LinkedList<>();
    }

public void push(int x) {
    queue2.add(x);
    while(queue1.size()>0){
        queue2.add(queue1.poll());
    }
    Queue<Integer>help;
    help=queue1;
    queue1=queue2;
    queue2=help;
}

public int pop() {
    return queue1.poll();
}

public int top() {
    return queue1.peek();
}

public boolean empty() {
    return queue1.size()==0&&queue2.size()==0;
}
```
}



### **3、循环队列**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815004447.png)

参考算法汇总里面循环队列

```java
class MyCircularDeque {
    //循环队列
    int []queue;
    int max;
    int size;
    int preindex;
    int lastindex;
    public MyCircularDeque(int k) {
        queue=new int[k];
        max=k;
        preindex=0;
        lastindex=1;
    }

    public boolean insertFront(int value) {
        if(size==max)return false;
        queue[preindex]=value;
        size++;
        if(preindex-1>=0)preindex--;
        else preindex=max-1;
        return true;
    }

    public boolean insertLast(int value) {
        if(size==max)return false;
        queue[lastindex]=value;
        size++;
        if(lastindex+1<max)lastindex++;
        else lastindex=0;
        return true;
    }

    public boolean deleteFront() {
        if(size==0)return false;
        if(preindex+1<max)preindex++;
        else preindex=0;
        size--;
        return true;
    }

    public boolean deleteLast() {
        if(size==0)return false;
        if(lastindex-1>=0)lastindex--;
        else lastindex=max-1;
        size--;
        return true;
    }

    public int getFront() {
        if(size==0)return -1;
        if(preindex+1<max)return queue[preindex+1];
        else return queue[0];
    }

    public int getRear() {
        if(size==0)return -1;
        if(lastindex-1>=0)return queue[lastindex-1];
        else return queue[max-1];
    }

    public boolean isEmpty() {
        return size==0;
    }

    public boolean isFull() {
        return size==max;
    }
}
```



### 4、石头下落

思路分析：

每一行进行操作，从后向前遍历，维护一个队列，如果遇到空，加入队列，如果是障碍物，则全部清空队列，如果是石头

弹出队列第一个位置，变成石头，然后石头的位置变为空，然后加入队列。

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220907181820.png)

```cpp
class Solution {
    public:
    vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
        int n=box.size();
        int m=box[0].size();
        deque<int>q;
        for(int i=0;i<n;i++){
            for(int j=m-1;j>=0;j--){
                if(box[i][j]=='.')q.push_back(j);
                else if(box[i][j]=='*')q.clear();
                else {
                    if(q.size()>0){
                        box[i][j]='.';
                        int k=q.front();
                        q.pop_front();
                        box[i][k]='#';
                        q.push_back(j);
                    }

                }
            }
            q.clear();
        }
        vector<vector<char>>v(m,vector<char>(n));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                v[j][n-i-1]=box[i][j];
            }
        }

        return v;
    }
};
```



### 5、最大堆

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910024334.png)

```cpp
class Solution {
    public:
    int halveArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        priority_queue<double>heap;//最大堆
        double sum=0.0;
        int count=0.0;
        for(int k:nums){
            sum+=k;
            heap.push(k);
        }
        double flag=sum/2;
        while(sum>flag){
            double k=heap.top();
            heap.pop();
            sum-=k/2;
            heap.push(k*1.0/2);
            count++;
        }
        return count;
    }
};
```



## 二、数组

### 1、拆分数组



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712104954.png" style="zoom:67%;" />

如果用模拟，可能过程有点繁琐

可以这样想，把每一秒都看成一个时刻，然后算这段时间人数，最后在用前缀和遍历

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int []num=new int[1001];
        for(int []a:trips){
            num[a[1]]+=a[0]; //num[a[1]]表示a[1]路程有a[0]个人上车
            num[a[2]]-=a[0];  
        }
        if(num[0]>capacity)return false;  //判断第一次有没有超载
        for(int i=1;i<1001;i++){
            num[i]=num[i-1]+num[i];
            if(num[i]>capacity)return false;
        }
        return true;
    }
}
```



### 2、数组操作

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220716204527.png" style="zoom:50%;" />

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int k=in.nextInt();
        long[]num=new long[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextInt();
        }
        Arrays.sort(num);
        int index=0;
        long sum=0;
        long []s=new long[1000000];
        for(int i=0;i<n;i++) {
            while(i<n&&num[i]-sum<=0)i++;
            if(i<n){
                s[index++]=num[i]-sum;
                sum=num[i];
            }
        }
        for(int i=0;i<k;i++){
            System.out.println(s[i]);
        }
    }

}
```





### **3、力扣周赛可否被整除**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717140710.png)





一个思路是找出numsDivide数组所有数字的最大公约数，然后在让第一个数组能不能整除最大公约数，这里用了辗转相除法

```Java
class Solution {
    public int minOperations(int[] nums, int[] numsDivide) {
        int sum=0;
        int n1=nums.length;
        int n2=numsDivide.length;
        Arrays.sort(numsDivide);
        Arrays.sort(nums);
        HashSet<Integer>set=new HashSet<>();
        int index=numsDivide[0];
        //求出最大公约数
        for(int i=1;i<n2;i++){
            index=find(index,numsDivide[i]);
            if(index==-1)return -1;
        }
        //System.out.println(index);
        for(int i=0;i<nums.length;i++){
            if(index%nums[i]!=0)sum++;
            else break;
        }
        if(sum==n1)return -1;
        return sum;
    }
    public int find(int a,int b){
        return b > 0 ? find(b, a % b) : a;
    }
}
```





### 4、差分

先算出每个位置移动的情况，用差分然后再求前缀和，最后别忘记要取余

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821011550.png)



```java
class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        int n=s.length();
        char[]a=s.toCharArray();
        int []num=new int[n+1];
        //差分
        for(int i=0;i<shifts.length;i++){
            int k1=shifts[i][0];
            int k2=shifts[i][1];
            int k3=shifts[i][2];
            int w;
            if(k3==1)w=1;
            else w=-1;
            num[k1]+=w; num[k2+1]-=w;
        }
        //前缀和
        for(int i=1;i<n;i++){
            num[i]+=num[i-1];
        }
        for(int i=0;i<s.length();i++){
            if(num[i]==0)continue;
            if(num[i]>0){
                int k=num[i]%26;
                if(a[i]+k>'z')a[i]= (char) (a[i]+k-1-'z'+'a');
                else a[i]= (char) (a[i]+k);
            }else if(num[i]<0){
                int k=num[i]%26;
                if(a[i]+k<'a')a[i]=(char)('z'+a[i]+k+1-'a');
                else a[i]= (char) (a[i]+k);
            }
        }

        return new String(a);
    }
}
```



### 5、倒置

首先局部倒置一定是全局倒置，全局倒置不一定是局部倒置，所以问我们找出多的全局倒置，也就是不是局部倒置的情况

找出num[i]>num[j]  并且j>i+1

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220823005802.png)

```java
class Solution {
    public boolean isIdealPermutation(int[] nums) {
        int n=nums.length;
        int []dp=new int[n];
        if(n<=2)return true;
        dp[n-1]=nums[n-1];
        dp[n-2]=Math.min(nums[n-1],nums[n-2]);
        for(int i=n-3;i>=0;i--){
            dp[i]=Math.min(dp[i+1],nums[i]);
            if(nums[i]>dp[i+2])return false;
        }
        return true;
    }
}
```



### 6、长度为k的子数组最大和(滑动窗口)

维护一段区间的有多少个不同的数

然后移动窗口

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221107014039.png)

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        nums.insert(nums.begin(),0);
        vector<long long>pre(n +1,0);
        //前缀和
        for(int i = 1 ; i <= n ; i ++){
            pre[i] =  pre[i - 1] + nums[i];
        }
        nums.push_back(0);
        int l  = 1;
        int r  = k;
        long long  count = 0;
        map<int,int>m;
        int c = 0;
        for(int i = 1 ;i <= k ;i ++){
            m[nums[i]] ++;
            if(m[nums[i]] == 1)c ++;
        }
        while(r <= n){
             //cout<<l<<" "<<r<<" "<<c<<endl;
            if(c == k){
                count = (long long )max(count,pre[r] - pre[l - 1]);
            }
            m[nums[l]] --;
            if(m[nums[l]] == 0)c --;
            r ++;
            l ++;
             m[nums[r]] ++;
            if(m[nums[r]] == 1)c ++;
        }
        return count;
    }
};
```





## 三、哈希

### 1、哈希表排序



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712105458.png)

用定制排序对哈希表的value进行排序，这是核心

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {

        sort p=new sort();
        int []str=new int[k];
        int index=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.get(nums[i])==null)map.put(nums[i],0);
            map.put(nums[i],map.get(nums[i])+1);
        }
        Set<Map.Entry<Integer,Integer>> set=map.entrySet();
        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(set);
        Collections.sort(list,p);
        for(Map.Entry<Integer,Integer> s:list){
            int w=s.getKey();
            str[index++]=w;
            if(index==k)break;
        }
        return str;
    }
}
class sort implements Comparator<Map.Entry<Integer,Integer>>{

    @Override
    public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
        return o2.getValue()-o1.getValue();
    }
}
```



### 2、哈希计数

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714023226.png" style="zoom:67%;" />

用哈希表记录数组的值，如果有了，就计算长度，并且和min比较，记得吧新的值和坐标加回去

```Java
class Solution {
    public int minimumCardPickup(int[] cards) {
        int min=1000000;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<cards.length;i++){
            if(map.get(cards[i])==null)map.put(cards[i],i);
            else {
                min=Math.min(i-map.get(cards[i])+1,min);
                map.put(cards[i],i);
            }
        }
        if(min==1000000)return -1;
        return min;
    }
}
```



### 3、哈希找最大数组对

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717133739.png)

具体做法用哈希表存每个位置之和，然后遇到相同的，那就把哈希表值和算出的每位数之和相加，最后在更新哈希表，未来下一次计算

```java
class Solution {
    public int maximumSum(int[] nums) {
        HashMap<Integer,Integer>map=new HashMap<>();
        int max=-1;
        for(int i=0;i<nums.length;i++){
            int sum=0;
            int k=nums[i];
            while(k>0){
                sum=sum+k%10;
                k=k/10;
            }
            if(map.get(sum)==null)map.put(sum,nums[i]);
            else{
                max=Math.max(map.get(sum)+nums[i],max);
                if(map.get(sum)<nums[i])map.put(sum,nums[i]);
            }
        }
        return max;
    }
}
```





### **4、图论加哈希表**

每次DFS遍历，用Map记录结点和长度

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731122317.png)



```java
class Solution {
    int []vist;
    int sum;
    public int closestMeetingNode(int[] edges, int node1, int node2) {
          HashMap<Integer,Integer>map1=new HashMap<>();
         HashMap<Integer,Integer>map2=new HashMap<>();
        vist=new int[edges.length];
        map1.put(node1,0);
        vist[node1]=1;
        sum=0;
        dfs(map1,edges,edges[node1]);
        vist=new int[edges.length];
        vist[node2]=1;
        map2.put(node2,0);
        sum=0;
        dfs(map2,edges,edges[node2]);
        int max=1000000;
        int index=0;
        for(int k:map1.keySet()){
            int k1= map1.get(k);
            if(map2.get(k)==null)continue;
            int k2=map2.get(k);
           int min=Math.max(k1,k2);
           if(min<max){
               max=min;
               index=k;
           }

        }
        if(max==1000000)return -1;
        return index;
    }
    public  void dfs(HashMap<Integer,Integer>map,int[]edges,int k){
        if(k!=-1&&vist[k]==0){
            vist[k]=1;
            sum=sum+1;
            map.put(k,sum);
            dfs(map,edges,edges[k]);
        }
    }
}
```



### **5、坏数**

把左右两边移位置，记录i-num[i]

然后遍历，下标i表示前面多少数字，然后i-map[num[i]]就是不等于的，sum+=i-map[num[i]]; 然后map++;

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807004143.png)

```java
class Solution {
    public long countBadPairs(int[] nums) {
        int n=nums.length;
        long sum=0;
        for(int i=0;i<n;i++){
            nums[i]=nums[i]-i;
        }
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            if(map.get(nums[i])==null)sum+=i;
            else sum+=i-map.get(nums[i]);
            if(map.get(nums[i])==null)map.put(nums[i],1);
            else map.put(nums[i],map.get(nums[i])+1);
        }
        return sum;
    }
}
```



### 6、连接成数组

把pieces第一个数和整个数组放到map中

然后循环arr

如果arr[i]不在map 返回false

否则取出map中数组  对比数组和arr[i];

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827021052.png)

```java
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        HashMap<Integer,int[]>map=new HashMap<>();
        //把数组的第一个值和数组放入Map中
        for(int []a:pieces){
            map.put(a[0],a);
        }

        for(int i=0;i<arr.length;){
            if(map.containsKey(arr[i])==false)return false;
            int []a=map.get(arr[i]);
            for(int j=0;j<a.length;i++,j++){
                if(a[j]!=arr[i])return false;
            }
        }
        return true;
    }
}
```



### 7、计算重复字符串(非常难)

思路：

就是统计每个字符串出现的位置，用哈希表记录

找出只含有当前字符个数唯一的字符串

然后对应下标为i的字符串，向前找重复的下标为x1   向后为x2

(i-x1)*(x2-i)就是字符串个数

记住前面加-1,后面甲长度

记录只有一个字符情况

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220906031843.png)



```cpp
class Solution {
    public:
    int uniqueLetterString(string s) {
        map<char,vector<int>>m;
        for(int i=0;i<s.size();i++){
            char a=s[i];
            m[a].push_back(i);
        }
        int sum=0;
        for(auto k:m){
            vector<int>v=k.second;
            v.push_back(s.size());
            v.insert(v.begin(),-1);
            for(int i=1;i<v.size()-1;i++){
                sum+=(v[i]-v[i-1])*(v[i+1]-v[i]);
            }
        }
        return sum;
    }
};
```





### 8、摧毁目标

思路：

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030015554.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030004127.png)

```cpp
ppclass Solution {
public:
    int destroyTargets(vector<int>& nums, int space) {
      map<int,int>m;
      sort(nums.rbegin(),nums.rend());
      int max = 0;
      int flag = -1;
      for(auto k : nums){
          int r = k % space;
          m[r]++;
          if(m[r] >= max ){
              max = m[r];
              flag = k;
          }
      }
      return flag;
    }
};
```





### 9、子字符串查询

>思路：
>我们要求  first ^ second的二进制在s中位置
>由于异或和最多为三十位，所以我们只要找出s中小于等于三十位的二进制对应的位置，用map记录下来就行了
>然后查找的时候就很方便

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230212144509.png)

```cpp
class Solution {
public:
    int count(string s){
      int sum = 0;  
      for(int i = s.size() - 1 ; i >= 0 ; i --){
         int a = s[i] - '0';
         sum +=  a*pow(2,s.size() - i - 1);
      }
      return sum;
    }
    vector<vector<int>> substringXorQueries(string s, vector<vector<int>>& queries) {
         int n = queries.size();
         vector<vector<int>>v(n,vector<int>(2,-1));
         unordered_map<int,pair<int,int>>m;
         for(int i = 1 ; i <= 30 ; i ++){
            for(int j = 0 ;j + i <= s.size() ; j ++){
                int c = count(s.substr(j,i));
                if(m.count(c) == 0)m[c] = {j,i + j - 1};
            }
         }
       for(int i = 0 ; i < n ; i ++){
           int a = queries[i][0] ^ queries[i][1];
           if(m.count(a) != 0){
               v[i][0] = m[a].first;
               v[i][1] = m[a].second;
           }
       }
       return v;
    }
};
```





### 10、字母和数字

题目
给一个数组，返回最长子数组：数字数量等于字母

>可以用哈希表加前缀和
>记录当前差值，找到上一个差值的位置，更新最大值

```cpp
class Solution {
public:
    int judge(char x){
        if(x >= '0' && x <= '9')return 1;
        else return 0;
    }
    vector<string> findLongestSubarray(vector<string>& array) {
      vector<string>v;
      int n = array.size();
      map<int,int>m;
      m[0] = -1;
      int mx = 0;
      int pre = 0;
      int sum = 0;
      for(int i = 0 ;i < n ; i ++){
          if(judge(array[i][0]) == 1)sum ++;
          else sum --;
          if(m.count(sum)){
              int index = m[sum];
              if(i - index > mx){
                 mx = i - index;
                 pre = index + 1; 
              }
          }else {
              m[sum] = i;
          }
      }
      if(mx == 0)return {};
      else return vector<string>(array.begin() + pre,array.begin() + pre + mx);
    }
};
```







## 四、树



### 1、堂兄弟

给你两个值，，判断是否为堂兄弟结点

无脑递归即可，找到这个结点后，记录这个结点的父节点

```java
class Solution {
    int h1;
    int h2;
    TreeNode root1;
    TreeNode root2;
    public boolean isCousins(TreeNode root, int x, int y) {
        dfs(root,0,x,y,null);
        return h1==h2&&root1!=root2;
    }
    public void dfs(TreeNode root,int sum,int x,int y,TreeNode parent){
        if(root==null)return ;
        if(root.val==x){
            h1=sum;
            root1 =parent;
            return;
        }else if(root.val==y){
            h2=sum;
            root2=parent;
            return;
        }

        dfs(root.left,sum+1,x,y,root);
        dfs(root.right,sum+1,x,y,root);
    }
}
```





### 2、翻转二叉树

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712112805.png" style="zoom: 67%;" />



```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)return null;
        TreeNode left=invertTree(root.left);
        TreeNode right=invertTree(root.right);
        root.left=right;
        root.right=left;
        return root;
    }
}
```

非递归

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (queue.size() > 0) {
            int size = queue.size();
            TreeNode head = queue.poll();
            TreeNode help = head.left;
            head.left = head.right;
            head.right = help;
            if (head.left != null) queue.add(head.left);
            if (head.right != null) queue.add(head.right);
            size--;
        }
        return root;
    }
}
```



### 3、完全二叉树结点个数

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)return 0;
        int left=countNodes(root.left);
        int right=countNodes(root.right);
        return left+right+1;
    }
}
```



### 4、二叉树的最小高度

找左儿子为null的结点，最小一点在右，反之在左，最后比较

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)return 0;
        int left=minDepth(root.left);
        int right=minDepth(root.right);
        if(root.left==null&&root.right!=null){
            return 1+right;
        }
        if(root.left!=null&&root.right==null){
            return 1+left;
        }
        return  Math.min(right,left)+1;
    }
}
```



### 5、最左下角的结点

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717000946.png" style="zoom:67%;" />

因为要最右边的左结点，所以我们采取前序遍历，然后贪心

```java
class Solution {
    int value;
    int deepmax=-1;
    public int findBottomLeftValue(TreeNode root) {
        value=root.val;
        dfs(root,0);
        return value;
    }
    public void dfs(TreeNode root,int deep){
        if(root==null)return;
        if(root.left==null&&root.right==null){
            if(deep>deepmax){
                deepmax=deep;
                value=root.val;
            }
        }
        dfs(root.left,deep+1);
        dfs(root.right,deep+1);
    }
}
```





### **6、验证一棵树是不是二插搜索树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718034405.png)

思路，在左子树中找到最大值，在右子树中小于最小值，如果当前的结点值小于等于左子树最大且大于等于右子树最小，return FALSE

然后分别递归

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)return true;
        int k1=0;
        int k2=0;
        if(root.left!=null)
            k1=findmax(root.left);
        if(root.right!=null)
            k2=findmin(root.right);
        if(root.left!=null&&root.val<=k1||root.right!=null&&root.val>=k2)return false;
        return isValidBST(root.left)&&isValidBST(root.right);
    }

    public int findmax(TreeNode head){
        while(head.right!=null){
            head=head.right;
        }
        return head.val;
    }
    public int findmin(TreeNode head){
        while(head.left!=null){
            head=head.left;
        }
        return head.val;
    }
}
```



### **7、最大二叉树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719003214.png)

可以这样想，就是每次从数组里找出最大值的下标，然后人让他成为根，然后递归创建左右子树

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return  dfs(nums,0,nums.length-1);
    }
    public TreeNode dfs(int []nums,int l,int r){

        if(l>r)return null;
        int index=findmax(nums,l,r);
        TreeNode root=new TreeNode(nums[index]);
        root.left=dfs(nums,l,index-1);
        root.right=dfs(nums,index+1,r);
        return root;
    }
    public int  findmax(int []nums,int l,int r){
        int max=nums[l];
        int index=l;
        for(int i=l;i<=r;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        return index;
    }
}
```



### 8、二叉树两个结点最近的公共祖先

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719014425.png)

递归，看看这棵树的根结点是不是等于p,或者q

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null)return null;
        if(root==q||root==p)return root;
        var left=lowestCommonAncestor(root.left,p,q);
        var right=lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null)return root;
        if(left!=null)return left;
        if(right!=null)return right;
        return null;
    }
}
```



### 9、删除结点

找到要删除的结点，找左子树最大的结点或者右子树最小的结点替换当前结点

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode temp=new TreeNode();
        if(root==null)return null;
        if(key>root.val)root.right=deleteNode(root.right,key);
        else if(key<root.val)root.left=deleteNode(root.left,key);
        else {
            if(root.left!=null&&root.right!=null){
                temp.val=findmax(root.left);
                root.val=temp.val;
                root.left=deleteNode(root.left,root.val);
            }else{
                if(root.left==null){
                    root=root.right;
                }else root=root.left;
            }
        }
        return root;

    }
    //找左边最大的值
    public int findmax(TreeNode root){
        while(root.right!=null)root=root.right;
        return root.val;
    }
}
```



### 10、修剪树

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220720152514.png)

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root==null)return null;
        if(root.val<low)return trimBST(root.right,low,high);
        if(root.val>high)return trimBST(root.left,low,high);
        root.left=trimBST(root.left,low,high);
        root.right=trimBST(root.right,low,high);
        return root;
    }
}
```



### 11、层序遍历加队列

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725022256.png)

核心思想：用层序遍历找到两个结点都不是有值的结点，然后存储到另一个队列

```java
class CBTInserter {
    TreeNode head;
    Queue<TreeNode>queue=new LinkedList<>();
    TreeNode parent;
    public CBTInserter(TreeNode root) {
        Queue<TreeNode>help=new LinkedList<>();
        head=root;
        TreeNode root1=root;
        help.add(root1);
        //只把最底层的结点装入队列中
        while(help.size()>0){
            root1=help.poll();
            if(root1.left!=null)help.add(root1.left);
            if(root1.right!=null)help.add(root1.right);
            if(!(root1.left!=null&&root1.right!=null))queue.add(root1);
        }
    }

    public int insert(int val) {
        TreeNode node=new TreeNode(val);
        node.left=node.right=null;
        if(parent==null||parent.left!=null&&parent.right!=null)parent=queue.poll();
        if(parent.left==null){
            parent.left=node;
        }else if(parent.right==null){
            parent.right=node;
        }
        queue.add(node);
        return parent.val;
    }

    public TreeNode get_root() {
        return head;
    }
}
```



### 12、等价翻转

<img src="C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220729200558.png" style="zoom: 67%;" />



```java
class Solution {
    public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        if(root1==null&&root2==null)return true;
        if(root1==null&&root2!=null||root1!=null&&root2==null)return false;
        if(root1.val!=root2.val)return false;
        return flipEquiv(root1.left,root2.left)&&flipEquiv(root1.right,root2.right)||
                flipEquiv(root1.left,root2.right)&&flipEquiv(root1.right,root2.left);
    }
}
```





### 13、删点成林

很简单，后序遍历每一个点，如果当前点的值在数组中，那么就记录当前点的两个左右儿子，同时让当前点的父节点的指向当前的指针为空，记住，递归开始前要先判断根结点，

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820140835.png)

```java
class Solution {
    HashSet<Integer>set;
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
        List<TreeNode>list=new ArrayList<>();
        set=new HashSet<>();
        for(int k:to_delete){
            set.add(k);
        }
        if(set.contains(root.val)==false){
            list.add(root);
        }
        dfs(root,list,null,0);
        return list;
    }

    public void dfs(TreeNode root,List<TreeNode>list,TreeNode p,int n){
        if(root==null)return;
        dfs(root.left,list,root,1);
        dfs(root.right,list,root,2);
        if(set.contains(root.val)==true){
            if(root.left!=null)list.add(root.left);
            if(root.right!=null)list.add(root.right);
            if(n==1)p.left=null;
            else if(n==2)p.right=null;
        }
    }
```





### **14、二叉树最大宽度**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827010554.png)

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        int index=1;
        Queue<TreeNode>queue=new LinkedList<>();
        queue.add(root);
        HashMap<TreeNode,Integer>map=new HashMap<>();
        int max=1;
        int pre=0;
        map.put(root,1);
        while(queue.size()>0){
            int size=queue.size();
            pre=map.get(queue.peek());
            while(size>0){
                size--;
                root=queue.poll();
                if(root!=null){
                    max=Math.max(max,map.get(root)-pre+1);
                }
                if(root.left!=null){
                    queue.add(root.left);
                    map.put(root.left,map.get(root)*2);
                }
                if(root.right!=null){
                    queue.add(root.right);
                    map.put(root.right,map.get(root)*2+1);
                }
            }
        }
        return max;
    }
}
```





### 15、最深结点的父节点

思路：

递归看左边深度和右边深度

如果一样，返回根结点

否则如果左边高度大，递归左边，否则右边

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830172122.png)



```java
class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        int l=deep(root.left);
        int r=deep(root.right);
        if(l==r)return root;
        else if(l>r)return subtreeWithAllDeepest(root.left);
        else return subtreeWithAllDeepest(root.right);
    }
    public int deep(TreeNode root){
        if(root==null)return 0;
        int l=deep(root.left)+1;
        int r=deep(root.right)+1;
        return Math.max(l,r);
    }
}
```



### **16、最大二叉树(题目傻逼)**

首先先描述题目：

这里的树是按照数组的二分来构造的

根结点左边的全部是左子树

根结点右边的全部是右子树

题目的意思是在数组的末尾加一个值

返回新的树的根结点



思路：

首先加到数组的右边，那么当前值肯定在跟结点的右边，不可能在左边

首先要先判断，如果值比根还大，那么当前值作为根结点，当前值的左儿子指向原来的根结点，返回当前结点

否则向右递归

如果当前结点为Null说明这个值是要接到叶子结点，直接返回新的结点就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830173034.png)



```java
class Solution {
    TreeNode last=null;
    int flag=0;
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {
        if(root==null)return new TreeNode(val);
        if(root.val<val){
            TreeNode root1=new TreeNode(val);
            root1.left=root;
            return root1;
        }
        root.right=insertIntoMaxTree(root.right,val);
        return root;
    }

}
```



### **17、重复子树(难)序列化**

把数序列化，这样子可以判断有没有重复



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220906000627.png)



```java
class Solution {
   HashMap<String,TreeNode>map;
   HashSet<TreeNode>set;
   public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
      map=new HashMap<>();
      set=new HashSet<>();
      dfs(root);
      return new ArrayList<TreeNode>(set);
   }
   public String dfs(TreeNode root){
      if(root==null)return "";
      StringBuilder s = new StringBuilder();
      s.append(root.val+"");
      s.append("(");
      s.append(dfs(root.left));
      s.append(")(");
      s.append(dfs(root.right));
      String str=s.toString();
      if(map.get(str)!=null){
         set.add(map.get(str));
      }else map.put(str,root);
      return str;
   }
}
```



### **18、平衡树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911035259.png)

```cpp
class Solution {

    public:
    vector<int>v;
    TreeNode* balanceBST(TreeNode* root) {
        dfs(root);
        sort(v.begin(),v.end());
        int mid=(v.size()-1)/2;
        TreeNode *root1=new TreeNode(v[mid]);
        root1->left= make(0,mid-1);
        root1->right=make(mid+1,v.size()-1);
        return root1;
    }
    TreeNode *make(int l,int r){
        if(l>r)return NULL;
        int mid=(l+r)/2;
        TreeNode*node=new TreeNode(v[mid]);
        node->left=make(l,mid-1);
        node->right=make(mid+1,r);
        return node;
    }
    void dfs(TreeNode *root){
        if(root==NULL)return ;
        dfs(root->left);
        dfs(root->right);
        v.push_back(root->val);
    }
};
```





### 19、二叉树寻路(难)

思路：

我们先计算总的层数

对于第i层   第一个数是2的i-1次方

整棵树的结点数是2的i次方减一

我们可以根据层数和结点标号来算出它反转的结点是多少

每次结点标号反转然后除以2才是下一个结点的值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221004003255.png)

```cpp
class Solution {
    public:
    vector<int> pathInZigZagTree(int label) {
        vector<int>v;
        int row = 1;
        while(!(label <= pow(2,row) - 1 && label >= pow(2,row-1)))row++;
        int k = label;
        v.push_back(label);
        label = count(label,row--)/2;;
        while(row > 0){
            v.push_back(label);
            label = count(label,row --);
            label = label/2;
        }
        reverse(v.begin(),v.end());
        return v;
    }

    //计算倒置后对应的数
    int count(int number,int row){
        int count = pow(2,row - 1);
        int sum = pow(2,row) - 1;
        int rest = sum - number;
        return count + rest;
    }
};
```

## 五、贪心

### 1、连续子数组最大和

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int i,j;
        int max=0;
        int pre=nums[0];
        for(i=0;i<n;i++){
            max=Math.max(nums[i],max+nums[i]);
            pre=Math.max(pre,max);
        }
        return pre;
    }
}
```



### 2、最长山脉

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714022439.png" style="zoom:67%;" />

二分加贪心，从中间向两边延伸，然后贪心

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n=arr.length;
        if(n<=2)return 0;
        int sum=0;
        for(int i=1;i<n-1;i++){
            int count=0;
            if(arr[i-1]>=arr[i]||arr[i+1]>=arr[i])continue;
            int left=i;
            int right=i;
            while(left-1>=0&&arr[left-1]<arr[left]){
                left--;
                count++;;
            }
            while(right+1<=n-1&&arr[right+1]<arr[right]){
                right++;
                count++;
            }
            sum=Math.max(sum,count+1);
        }
        return sum;
    }
}
```



### 3、买股票

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806001333.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min=10000000;
        int max=0;
        for(int i=0;i<prices.length;i++){
            if(prices[i]<min){
                min=prices[i];
            }else {
                max=Math.max(max,prices[i]-min);
            }
        }
        return max;
    }
}
```



### 4、完成任务(我是sb)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807011133.png)

第一种方法，计算这个任务下一次完成在第几天，也就是sum+space+1;

每次遇到这个任务，取出前一天+1和map里值中的最大值，更新sum,然后重新记录map里的值

```java
class Solution {
    public long taskSchedulerII(int[] tasks, int space) {
        int n=tasks.length;
        long sum=0;
        HashMap<Integer,Long>map=new HashMap<>();
        for(int i=0;i<n;i++){
            long k=map.get(tasks[i])==null?0:map.get(tasks[i]);
            sum=Math.max(sum+1,k);
            map.put(tasks[i],sum+(long)(space+1));
        }
        return sum;
    }
}
```

另一种方法是记录现在这个任务要计划多少填，如果Map等于Null,直接sum++就行了，把下一次的任务给记住，否则就从sum+1到当前任务计划天数里面取大的，更新Map

```java
class Solution {
    public long taskSchedulerII(int[] tasks, int space) {
        int n=tasks.length;
        long sum=0;
        HashMap<Integer,Long>map=new HashMap<>();
        for(int k:tasks){
            long pre=0;
            if(map.get(k)==null){
                sum++;
                map.put(k,sum+space+1);
                continue;
            }
            pre=map.get(k);
            sum=Math.max(sum+1,pre);
            map.put(k,sum+space+1);
        }
        return sum;
    }
}
```



### 5、排序数组(数学知识)

我们从后到前，记住上一个数为last

如果当前数小于更新last

否则：

判断如果当前数可以整除last

那么拆分的次数就是整除-1  Last维持

如果不可以，那要平均分k组，使得每组尽可能相等

比如当前数是7 last 是6，我们分两组，分别为3,4这样子后面拆分的操作才能更少，不能拆成1 6

所以k等于当前数除以last+1

因为有分成了K组，所以操作为k-1 

最后last为  当前数除以k  余数全部加到后面去了

比如当前数是8   last=3   所以分成三组   2,3,3

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807023402.png)

```java
class Solution {
    public long minimumReplacement(int[] nums) {
        long sum=0;
        int n=nums.length;
        int last=nums[n-1];
        for(int i=n-2;i>=0;i--){
            // System.out.println(last+" "+sum);
            if(nums[i]<=last)last=nums[i];
            else{
                if(nums[i]%last==0){
                    sum+=nums[i]/last-1;
                }else{
                    int k=nums[i]/last+1;
                    sum+=k-1;
                    last=nums[i]/k;
                }
            }
        }
        return sum;
    }
}
```



### 6、划分k

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220811181453.png)

```java
class Solution {
    public int partitionArray(int[] nums, int k) {
        Arrays.sort(nums);
        int count=1;
        int falg=nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i]-falg<=k){

            }else {
                falg=nums[i];
                count++;
            }
        }
        return count;
    }
}
```



### 7、划分数组

如果左边数组最大值大于当前值，那么定位到当前数组，如果更新左边数组的最大值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815191526.png)

```java
class Solution {
    public int partitionDisjoint(int[] nums) {
        int n=nums.length;
        int index=0;
        int leftmax=nums[0];
        int max=nums[0];
        for(int i=0;i<n;i++){
            max=Math.max(nums[i],max);
            if(nums[i]<leftmax){
                index=i;
                leftmax=max;
            }
        }
        return index+1;
    }
}
```



### 8、矩阵二进制

思路，如果都为零全部加零，为一，全部加一，记住Lower和upper要递减，如果加一lower或者upper有等于零直接返回空

然后一个零一个一，优先把一往大的地方放

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818142103.png)

```java
class Solution {
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        List<Integer>list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        List<List<Integer>>list=new ArrayList<>();
        int n=colsum.length;
        for(int i=0;i<n;i++){
            int value=colsum[i];
            if(value==2){
                if(upper==0||lower==0)return list;
                list1.add(1);
                list2.add(1);
                upper--;
                lower--;
            }else if(value==0){
                list1.add(0);
                list2.add(0);
            }else {
                if(upper>lower){
                    list1.add(1);
                    list2.add(0);
                    upper--;
                }else {
                    list1.add(0);
                    list2.add(1);
                    lower--;
                }
            }
        }

        if(lower!=0||upper!=0)return list;
        list.add(list1);
        list.add(list2);
        return list;
    }
}
```





### 9、删除字符串

先记录字符串数量，从小到大排序，然后用哈希表，判断当前字符串数量有没有重复吗，如果重复，就递减，然后操作加一

最后更新哈希表

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819170046.png)

```java
class Solution {
    public int minDeletions(String s) {
        int[]num=new int[26];
        for(int i=0;i<s.length();i++){
            num[s.charAt(i)-'a']++;
        }
        int sum=0;
        HashSet<Integer>set=new HashSet<>();
        Arrays.sort(num);
        for(int i=0;i<26;i++){
            int value=num[i];
            while(value!=0&&set.contains(value)==true){
                value--;
                sum++;
            }
            set.add(value);
        }
        return sum;
    }
}
```





### 10、摆动序列

每次开始检测是不是和前一次一样，记录上一次摆动序列

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827024704.png)

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n=nums.length;
        if(n<=1)return n;
        int pre=0;
        int last=0;
        int sum=1;
        for(int i=0;i<n-1;i++){
            last=nums[i+1]-nums[i];
            if(last<0&&pre>=0||last>0&&pre<=0){
                sum++;
                pre=last;
            }
        }
        return sum;
    }
}
```



### 11、跳跃游戏

每次看下标和最大距离的大小，并且更新最大距离

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830185049.png)

```c++
class Solution {
    public:
    bool canJump(vector<int>& nums) {
        int max1=nums[0];
        for(int i=1;i<nums.size();i++){

            if(i>max1)return false;
            max1=max(max1,i+nums[i]);
        }
        return true;
    }
};
```



### **12、跳跃游戏2(难)**

思路：

这道题有点意思

首先要维护此时最大距离nextreach

reach是上一步覆盖的氛围

如果下标到达这个范围，就要更新nextreach

能够到最远距离为nextreach的点一定在上一点到reach之间

所以更新count

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830202007.png)

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length==1)return 0;
        int n=nums.length;
        int nextreach=nums[0];
        int reach=0;
        int count=0;
        for(int i=0;i<n;i++){
            nextreach=Math.max(nextreach,i+nums[i]);
            if(nextreach>=n-1)return count+1;
            if(reach==i){
                reach=nextreach;
                count++;
            }
        }
        return count;
    }
}
```





### 13、分糖果

思路：先让数组初始值为1

然后从前往后遍历，如果后一个值大于前一个，后一个值等于前一个加一

否则跳过

然后从后向前

如果前一个大于后一个

从后一个加一和当前值这两个选个最大值出来

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220903215848.png)

```java
class Solution {
    public int candy(int[] ratings) {
        int n=ratings.length;
        int []num=new int[n];
        for(int i=0;i<n;i++){
            num[i]=1;
        }
        for(int i=0;i<n-1;i++){
            if(ratings[i+1]>ratings[i])num[i+1]=num[i]+1;
        }
        for(int i=n-1;i>=1;i--){
            if(ratings[i-1]>ratings[i]){
                num[i-1]=Math.max(num[i]+1,num[i-1]);
            }
        }
        int sum=0;
        for(int i=0;i<n;i++){
            sum+=num[i];
        }
        return sum;
    }
}
```



### **14、最小异或**

找出Num2中的1

然后从最高位到最低位吧num1中的1替换为0

如果有剩余的就把num1中的0从最低位到最高位替换为1



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002130820.png)





```cpp
class Solution {
    public:
    int minimizeXor(int num1, int num2) {
        int cnt = 0;
        while(num2){
            cnt += (num2)&1;
            num2 = num2>>1;
        }
        int res=num1;
        for(int i=30;i>=0&&cnt>0;i--){
            if(((num1 >> i) & 1) == 1){
                res -=1<<i;
                cnt --;
            }
        }
        for(int i=0;i<=30&&cnt>0; i ++){
            if(((num1 >> i) & 1) ==0){

                res +=1<<i;
                cnt--;
            }
        }

        return res^num1;
    }
};
```



### 15、k个回文子串

因为构造k个回文

所以奇数的个数小于k

并且长度大于k

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002233040.png)

```cPp
class Solution {
    public boolean canConstruct(String s, int k) {

        int []num=new int[26];
        for(int i=0;i<s.length();i++){
            num[s.charAt(i)-'a']++;
        }
        int sum=0;
        for(int i=0;i<26;i++){
            if(num[i]%2==1)sum++;
        }
        return sum<=k&&s.length()>=k;
    }
}
```



### 16、最小化数组的最大值

求前缀和  每一次求平均数  取最大值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014144.png)



```cPP
class Solution {
    public:
    int minimizeArrayValue(vector<int>& nums) {
        int mx = nums[0];
        long long  sum = nums[0];
        for(int i = 1;i < nums.size(); i ++){
            sum = (sum+nums[i]);
            if(sum%(i+1)==0)
                mx = max(mx,(int)((sum)/(i+1)));
            else mx = max(mx,(int)((sum)/(i+1)+1));
        }
        return mx;
    }
};
```

## 六、动态规划

### 1、最长递增子序列

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714021803.png" style="zoom:67%;" />

思想动态规划

dp[i]为此时的最长子序列，前面i-1个数，如果dp[j]<dp[i]  dp[i]=dp[j]+1;然后在取大

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < nums.length; i++) {
            //初始肯定为1
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    //贪心
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```



### **2、子矩阵**

可以先统计每个点向左横向可以形成几个正方形

如果下面动态规划

这个点向上面走，取小，然后相加

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807061701.png)

```java
class Solution {
    public int numSubmat(int[][] mat) {
        int m=mat.length;
        int n=mat[0].length;
        int [][]dp=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(j==0){
                    dp[i][j]=mat[i][j];
                }else {
                    if(mat[i][j]!=0){
                        dp[i][j]=dp[i][j-1]+1;
                    }
                    else dp[i][j]=0;
                }
            }
        }
        int sum=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                int min=dp[i][j];
                for(int k=i;k>=0&&min!=0;k--){
                    min=Math.min(min,dp[k][j]);
                    sum=sum+min;
                }
            }
        }
        return sum;
    }
}
```





### **3、组合**(难)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220808112534.png)

dp[i]等于前i-1下标是否可以构成序列，nums[i-1]==nums[i-2]  先不影响前i-2序列，所以保证f[i-2]=true  才能为true   其他都一样



```java
class Solution {
    public boolean validPartition(int[] nums) {
        int  n=nums.length;
        boolean[]dp=new boolean[n+1];
        dp[0]=true;
        dp[1]=false;

        dp[2]=(nums[1]==nums[0]);
        for(int i=3;i<=n;i++){
            if(nums[i-1]==nums[i-2]){
                if(dp[i-2]==true)dp[i]=true;
                if(nums[i-2]==nums[i-3]&&dp[i-3]==true)dp[i]=true;
            }else{
                if(nums[i-1]-nums[i-2]==1&&nums[i-2]-nums[i-3]==1&&dp[i-3]==true)dp[i]=true;
            }
        }
        return dp[n];
    }
}
```



### 4、子数组范围

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220817170544.png)

```java
class Solution {
    public long subArrayRanges(int[] nums) {
        int n=nums.length;
        int [][]max=new int[n][n];
        int [][]min=new int[n][n];
        long sum=0;
        for(int i=0;i<n;i++){
            max[i][i]=nums[i];
            min[i][i]=nums[i];
            for(int j=i+1;j<n;j++){
                max[i][j]=Math.max(nums[j],max[i][j-1]);
                min[i][j]=Math.min(nums[j],min[i][j-1]);
                sum+=max[i][j]-min[i][j];
            }
        }
        return sum;
    }
}
```





### 5、字典元音

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023930.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023134.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023156.png)



```java
class Solution {
    public int countVowelStrings(int n) {
        int []dp=new int[]{1,1,1,1,1};
        int sum=0;
        for(int i=2;i<=n;i++){
            sum=0;
            for(int j=4;j>=0;j--){
                sum+=dp[j];
                dp[j]=sum;
            }
        }
        sum=0;
        for(int i=0;i<5;i++)sum+=dp[i];
        return sum;
    }
}
```



### 6、摆动序列

思路：

考虑用动态规划的思想来解决这个问题。

很容易可以发现，对于我们当前考虑的这个数，要么是作为山峰（即nums[i] > nums[i-1]），要么是作为山谷（即nums[i] < nums[i - 1]）。

- 设dp状态`dp[i][0]`，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度
- 设dp状态`dp[i][1]`，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度

则转移方程为：

- `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 < j < i`且`nums[j] < nums[i]`，表示将nums[i]接到前面某个山谷后面，作为山峰。
- `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 < j < i`且`nums[j] > nums[i]`，表示将nums[i]接到前面某个山峰后面，作为山谷。

初始状态：

由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

<img src="C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220827024704.png"  />



```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n=nums.length;
        if(n<=1)return n;
        int [][]dp=new int[n][2];
        dp[0][0]=1;
        dp[0][1]=1;
        for(int i=1;i<n;i++){
            dp[i][0]=dp[i][1]=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i])dp[i][0]=Math.max(dp[i][0],dp[j][1]+1);
                else if(nums[j]>nums[i])dp[i][1]=Math.max(dp[i][1],dp[j][0]+1);
            }

        }
        return Math.max(dp[n-1][0],dp[n-1][1]);
    }
}
```



### 7、走步数(难)



思路：

k属于1到1000

也就是最左边是500 走过去再回来，最右边是1500 从1000位置走过去再回来

所以数组的大小为2000

我们开一个二维的 dp

第一个参数是步数，第二个是位置

同时我们还要把两个下标加500

然后量从两重循环：

第一重是步数，第二重是位置

每一步可以从上一步转移过来

同时两种转移方式

前或者后

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220904200633.png)

```java
class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        int e=1000000007;
        int [][]dp=new int[1010][2010];
        startPos+=500;
        endPos+=500;
        dp[0][startPos]=1;
        for(int i=1;i<=k;i++){
            for(int j=0;j<2010;j++){
                if(j!=0)dp[i][j]=dp[i-1][j-1];
                if(j+1<2010)dp[i][j]=(dp[i][j]+dp[i-1][j+1])%e;
            }
        }
        return dp[k][endPos];
    }
}
```



### 8、最短编辑距离

思路：

找到当前状态是从什么地方转移过来的

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910212529.png)

首先当前操作是删除

那么就是f(i-1)(j)+1  f(i-1)(j)表示将a中1到i-1的字符变成b中1到j

还有增加

修改   注意修改的时候要判断a(i)和b(j)是否相等

初始化的时候也要注意

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910214915.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 1010;
        int n,m;
        char a[N],b[N];
        int f[N][N];
        int main()
        {
           scanf("%d%s",&n,a+1);
           scanf("%d%s",&m,b+1);
           for(int i=0;i<=m;i++)f[0][i]=i;
           for(int i=0;i<=n;i++)f[i][0]=i;
           
           for(int i=1;i<=n;i++){
               for(int j=1;j<=m;j++){
                   f[i][j]=min(f[i-1][j]+1,f[i][j-1] + 1);
                    if(a[i]==b[j])f[i][j] = min(f[i][j], f[i-1][j-1]);
                    else f[i][j]=min(f[i][j],f[i-1][j-1]+1);
               }
            }
           cout<<f[n][m];
          return 0;
        }
```





### **9、编辑距离**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910223115.png)





```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include<string.h>
        using namespace std;
        int n,m;
        char str[1010][15];
        int f[15][15];
        int sum=0;
        int find(char a[],char b[]){
            int lena=strlen(a+1);
            int lenb=strlen(b+1);
            for(int i=0;i<=lenb;i++)f[0][i]=i;
            for(int i=0;i<=lena;i++)f[i][0]=i;

            for(int i=1;i<=lena;i++){
                for(int j=1;j<=lenb;j++){
                   f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);
                  f[i][j]=min(f[i][j],f[i-1][j-1]+(a[i]!=b[j]));
              }
            }
            return f[lena][lenb];
        }


        int main()
        {
           cin>>n>>m;
           for(int i=0;i<n;i++)scanf("%s",str[i]+1);
           for(int i=0;i<m;i++){
           char s[15];
           int limt;
            sum=0;
            scanf("%s%d",s+1,&limt);
            for(int j=0;j<n;j++){
              if(find(str[j],s)<=limt)sum++;
             }
           cout<<sum<<endl;
        }
           return 0;
        }
```



### 10、整数拆分(难)

f(i)表示将i 拆分获得的最大乘积

i  可以分成两部分

j 是拆分的第一个整数

那么剩下的 i - j可以选择继续分或者不分

j  和  i-j   这时候      可以选择将i继续分  f(i-j)*j   或者 不分  j* *(i-j) 

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221011113242.png)



```cpp
class Solution {
    public:
    int integerBreak(int n) {
        vector<int>dp(n+1,0);
        dp[0] = dp[1] = 0;
        int sum = 0;
        for(int i = 2 ; i <= n ; i ++){
            for(int j = 1 ; j < i; j ++){
                sum = max(sum,max(dp[i - j]*j,(i - j) * j));
            }
            dp[i] = sum;
        }
        return dp[n];
    }
};
```







### 11、不同子序列(难)

思路就是统计每个字符作为最后一个单词出现的次序

没次遍历都要对26个字母统计一次

然后总次数加一  更新当前字符     只要sum +1就行了  因为自己本身也算一个

最后在遍历二十六个字母

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221014132945.png)



```cpp
class Solution {
    public:
    int distinctSubseqII(string s) {
        int n = s.size();
        int e = 1e9+7;
        int num[26];
        long sum ;
        memset(num,0,sizeof num);
        for(int i = 0; i < n ; i ++){
            sum = 0;
            for(int j = 0; j < 26 ;j ++){
                sum = (sum + num[j])%e;
            }
            num[s[i] - 'a'] = sum + 1;
        }
        int count = 0;
        for(int i = 0;i < 26 ; i++ ){
            count = (num[i] + count)%e;
        }
        return count;
    }
};
```



### 12、字符串链(哈希加动态规划)

思路：按长度排序，然后map记录每个字符出现的位置

这里吧map加一  因为map初始为0  会和0下标重复

如果就是一个循环  每次循环枚举比当前字符少一个的字符串   取最大值



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221015010709.png)



```cpp
class Solution {
    public:
    static int  cmp(string s1,string s2){
        return s1.size()<s2.size();
    }
    int longestStrChain(vector<string>& words) {
        sort(words.begin(),words.end(),cmp);
        int n=words.size();
        vector<int>dp(n,1);
        int mx=1;
        //记录字符串的位置
        unordered_map<string,int>mp;
        for(int i = 0; i < n ; i++){
            mp[words[i]] = i+1;
        }

        for(int i = 0 ; i < n ; i++){
            if(words[i].size() >= 2){
                for(int j = 0;j < words[i].size();j ++){
                    string str = words[i].substr(0,j) + words[i].substr(j+1,words[i].size() - j);
                    if(mp[str])dp[i] = max(dp[mp[str] - 1]+1,dp[i]);
                }
            }
            mx = max(dp[i],mx);
        }
        return mx;
    }

};
```





### 13、统计构造好字符串的方案数量

动态规划求前缀和就行了 然后记得会超出正常范围  加一个偏移量

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114090218.png)

```cpp
class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) {
         int e = 1e9+7;
         long long  dp[high+1];
         memset(dp,0,sizeof(dp));
         dp[0] = 0;
         for(int i = 1; i <= high ; i ++){
             if(i - zero>=0)dp[i] += (+dp[i - zero] + 1)%e;
             if(i - one >=0)dp[i] += (dp[i - one] + 1)%e;
         }
         return (dp[high]  - dp[low - 1] +e)%e;
    }
};
```





### 14、回文字符串个数

用两个三维数组 f(i)(j)(k)  表示 下标为i的位置  前面有多少个jk   以及后面多少个kj   

求出前缀和后缀

最后两个相乘

f(i)(j)(k) = f(i - 1)(j)(k)  还要计算当前下标可以和 0 - 9 构成多少对

所以还要相加

从后到前也是一样

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221127035541.png)

```cpp
const int N = 10010,e = 1e9+7;
int  pre[N][10][10],last[N][10][10];
class Solution {
public:
    int countPalindromes(string s) {
        int n = s.size();
        int cnt[10] = {0};
        memset(pre,0,sizeof pre);
        memset(last,0,sizeof last);
        for(int i = 1 ; i <= n ; i ++){
           for(int j = 0 ;j < 10 ; j ++){
               for(int k = 0 ; k < 10 ;  k ++){
                   pre[i][j][k] = pre[i - 1][j][k];
               }
           }
           int c = s[i - 1] - '0';
           for(int w = 0 ; w < 10 ; w ++){
               pre[i][w][c] += cnt[w];
           }
           cnt[c] ++;
        }
       memset(cnt,0,sizeof cnt);

       for(int i = n ;i > 0 ; i --){
          for(int j = 0 ;j < 10 ; j ++){
               for(int k = 0 ; k < 10 ;  k ++){
                   last[i][j][k] = last[i + 1][j][k];
               }
           }
           int c = s[i - 1] - '0'; 
           for(int w = 0 ; w < 10 ; w++){
               last[i][c][w] += cnt[w];
           }
           cnt[c] ++;
      }
      int sum = 0;
      for(int i = 1 ; i <= n ; i ++){
          for(int j = 0 ;j  < 10 ; j ++){
              for(int k = 0 ; k < 10 ;  k ++){
                 sum = (sum + (long long)pre[i - 1][j][k] * last[i + 1][k][j])%e;
              }
          }
      }
      return sum;
    }
};
```







### 15、青蛙跳石头

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230121105924.png)

分析

>这里青蛙可以侧着跳，如果中间有石头，那么就可以穿过石头，我们可以了解为当前位置可以由另外上下两个位置跳过来
>
>我们用dp(i)(j) 表示第i个位置的第i条跑到最小值
>
>刚开始我们先初始化全部为正无穷，我们假设当前位置全部由左边跑道横着过来，如果左边没有石头
>那么dp(i)(j) = dp(i)(j - 1)
>
>然后我们从dp(i)(0) dp(i)(1) dp(i)(2)中选出最小值，然后更新 dp(i)(j)  因为此时可能从侧边跳过来
>
>最后 dp(n)(0) dp(n)(1)  dp(n)(2)最小值就是结果

```cpp
class Solution {
public:
    int minSideJumps(vector<int>& obstacles) {
       int n = obstacles.size() - 1;
       int dp[n + 1][3];
       int mx = 1000000000;
        memset(dp,mx,sizeof(dp));
       dp[0][0] = 1;
       dp[0][1] = 0;
       dp[0][2] = 1;
       for(int i = 1 ; i <= n ; i ++){
         int c = mx;
         for(int j = 0 ; j < 3 ; j ++){
             if(j != obstacles[i] - 1){
                dp[i][j] = dp[i - 1][j];
                c  = min(c,dp[i][j]);
             }else dp[i][j] = mx;
         }
         for(int j = 0 ; j < 3 ; j ++){
             if(j == obstacles[i] - 1)continue;
             else {
                  dp[i][j] = min(dp[i][j],c + 1);
             }
         }
       }
       return min(dp[n][0],min(dp[n][1],dp[n][2]));
    }
};
```



### **8、无平分子集(状态压缩难)**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230226031552.png)



![微信截图_20230226031542](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230226031542.png)

```cpp
class Solution {
public:
    int squareFreeSubsets(vector<int>& nums) {
        // 质数表
        const int MAXK = 10;
        int prime[10] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29};

        // 检查 x 是否为平方数
        auto check = [&](int x) {
            for (int i = 0; i < MAXK; i++) if (x % (prime[i] * prime[i]) == 0) return true;
            return false;
        };

        const int MOD = 1e9 + 7;
        int n = nums.size();
        long long f[n + 1][1 << MAXK];
        memset(f, 0, sizeof(f));
        f[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            // 不把第 i 个数加入子集的方案数
            for (int j = 0; j < (1 << MAXK); j++) f[i][j] = f[i - 1][j];
            int x = nums[i - 1];
            // 如果 x 是平方数，那么肯定不能把它加入子集，直接看下一个数
            if (check(x)) continue;
            // 计算第 i 个数的质因数分解
            int msk = 0;
            for (int j = 0; j < MAXK; j++) if (x % prime[j] == 0) msk |= 1 << j;
            // 把第 i 个数加入子集的方案数
            for (int j = 0; j < (1 << MAXK); j++) if ((j & msk) == 0) f[i][j | msk] = (f[i][j | msk] + f[i - 1][j]) % MOD;
        }

        long long ans = 0;
        for (int j = 0; j < (1 << MAXK); j++) ans = (ans + f[n][j]) % MOD;
        // 注意题目求的是非空子集，因此要扣掉空集合
        ans = (ans - 1 + MOD) % MOD;
        return ans;
    }
};
```









### 9、获得分数的方法数(周赛第四题)

>思路
>类似分组背包，分为n个组，所以有
>
>+ dp(i)(j)表示用了前i个物品获取分数为j的最大数量
>+ 转移方程：dp(i)(j) = dp(i)(j) + dp(i - 1)(j - k * s)
>
>这里三重循环枚举，分别是，物品数，分数，还有k表示当前可以选取的数量

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230307105357.png)

```cpp
class Solution {
public:
    //表示用到前i个题目，容量为j的最大数量
    int dp[1010][1010];
    int waysToReachTarget(int target, vector<vector<int>>& types) {
        int n = types.size();
        int e = 1e9 + 7;
        dp[0][0] = 1;
        for(int i = 1 ; i <= n ; i ++){
            int c = types[i - 1][0];
            int s = types[i - 1][1];
            for(int j = 0 ; j <= target; j ++){
                for(int k = 0 ; k <= c && j >=k * s ; k ++){
                    dp[i][j] = (dp[i - 1][j - k*s] + dp[i][j]) % e; 
                }
            }
        }
        return dp[n][target];
    }
};
```







## 七、搜索(dfs,bfs)

### **1、缓存搜索(难)**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715114227.png" style="zoom:67%;" />

首先可以dfs记录每个点的最大深度，用vist来表示，如果下次访问到了这个点。，直接return回去就行了

```java
class Solution {
    int [][]vist;
    public int dfs(int[][]matrix,int i,int j,int flag ){
        if(i==matrix.length||j==matrix[0].length||i<0||j<0)return 0;
        if(flag>=matrix[i][j]){
            return 0;
        }
        if(vist[i][j]!=0)return vist[i][j];
        int left=dfs(matrix,i+1,j,matrix[i][j]);
        int right=dfs(matrix,i-1,j,matrix[i][j]);
        int up=dfs(matrix,i,j+1,matrix[i][j]);
        int dowm=dfs(matrix,i,j-1,matrix[i][j]);
        vist[i][j]=Math.max(Math.max(left,right),Math.max(up,dowm))+1;
        return vist[i][j];
    }
    public int longestIncreasingPath(int[][] matrix) {
        vist=new int[matrix.length][matrix[0].length];
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                dfs(matrix,i,j,-1);
            }
        }
        int max=1;
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(vist[i][j]>max)max=vist[i][j];
            }
        }
        return max;
    }
}
```



### 2、三幂次方之和

直接暴力好吧



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818011051.png)

```java
class Solution {
    int flag=0;
    int num;
    public boolean checkPowersOfThree(int n) {
        num=n;
        List<Integer>list=new ArrayList<>();
        int sum=1;
        //把所有可能数字记录下来
        while(sum<=n){
            list.add(sum);
            sum=sum*3;
        }
        dfs(n,-1,list);
        return flag==1;
    }
    public void dfs(int sum,int n,List<Integer>list){
        // System.out.println(sum);
        if(sum<0)return;
        if(flag==1)return;
        if(sum==0){
            flag=1;
            return;
        }
        for(int i=n+1;i<list.size();i++){
            dfs(sum-list.get(i),i,list);
        }
    }
```





### **3、八数码(难，bfs)**

思路，我们可以把初始状态看成第一个结点，把我们想要的状态看成第二个结点，然后可以变化的状态看成当前状态到变化状态的一条边，也就是形成图，然后用bfs处理，这里字符串处理要注意。

把一个3*3的矩阵看成一个字符串  然后向四个方向进行搜索  和bfs一样

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820175828.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <cmath>
#include <map>
using namespace std;
map<string,int>m;
queue<string>q;
int h1[4] = {1,0,-1,0};
int h2[4] = {0,-1,0,1};
string t = "12345678x";
int dfs(string str){
    q.push(str);
    m[str] = 0;
    int flag = 0;
    while(q.size() > 0){
      
        string s = q.front();
        q.pop();
        if(t == s){
            return m[s];
        }
        int dis = m[s];
        int index = s.find('x');
        int a = index/3;
        int b = index%3;
        
        for(int i = 0 ; i < 4 ; i ++){
            int c = a + h1[i];
            int d = b + h2[i];
            //cout<<c<<" "<<d<<endl;
            if(c < 0 || d < 0 || c >= 3 || d >= 3)continue;
            //转换为一维
            int index2 = c*3+d;
            swap(s[index2],s[index]);
          
            //第一次遍历就入队
            if(m.count(s) == 0){
              q.push(s);
              m[s] = dis + 1;
            }
            swap(s[index2],s[index]);
        }
    }
    return -1;
}
int main(){
    string s;
    string c;
    for(int i = 0 ; i < 9 ;  i++){
        cin>>c;
        s += c;
    }
   // cout<<s<<endl;
    cout<<dfs(s)<<endl;
    return 0;
}
```





```java
import java.util.*;
public class Main{
    static  HashMap<String,Integer>map;
    static Queue<String>queue;
    static int[]h1={1,-1,0,0};
    static  int[]h2={0,0,-1,1};
    static  String end="12345678x";
    public  static  int dfs(String start){
        queue.add(start);
        map.put(start,0);
        while(queue.size()>0){
            String str=queue.poll();
            // System.out.println(str);
            int dis=map.get(str);
            if(str.equals(end))return dis;
            int flag=0;
            //找出x下标
            for(int i=0;i<str.length();i++){
                if(str.charAt(i)=='x'){
                    flag=i;
                    break;
                }
            }
            //映射成二维矩阵
            int x=flag/3;
            int y=flag%3;
            //交换
            StringBuffer help=new StringBuffer(str);
            for(int i=0;i<4;i++){
                int a=x+h1[i];
                int b=y+h2[i];
                if(a<3&&a>=0&&b<3&&b>=0){

                    int c=a*3+b;//映射成一维数组下标
                    char d=help.charAt(c);
                    help.setCharAt(flag,d);
                    help.setCharAt(c,'x');
                    String s=help.toString();
                    if(map.containsKey(s)==false){
                        map.put(s,dis+1);
                        queue.add(s);
                    }
                    help=new StringBuffer(str);
                }
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        map=new HashMap<>();
        queue=new LinkedList<>();
        String s=in.nextLine();
        String start="";
        //处理字符串
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=' ')start+=s.charAt(i);
        }
        System.out.println(dfs(start));
    }
}
```



### 4、感染树

直接建图，bfs

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821130316.png)

```java
class Solution {
    //建图
    int []tree=new int[100010];
    int []dist=new int[100010];
    int []value=new int[200010];
    int []next=new int[200010];
    int index=0;
    int []vist=new int[100010];
    public void dfs(TreeNode root){
        if(root==null)return;
        if(root.left!=null){
            insert(root.val,root.left.val);
            insert(root.left.val,root.val);
            dfs(root.left);
        }
        if(root.right!=null){
            insert(root.val,root.right.val);
            insert(root.right.val,root.val);
            dfs(root.right);
        }
    }
    public void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }
    public int amountOfTime(TreeNode root, int start) {
        for(int i=0;i<100010;i++){
            tree[i]=-1;
        }
        dfs(root);
        Queue<Integer>queue=new LinkedList<>();
        queue.add(start);
        int max=0;
        dist[start]=0;
        vist[start]=1;
        while(queue.size()>0){
            int size=queue.size();
            while(size>0){
                size--;
                int k=queue.poll();
                for(int i=tree[k];i!=-1;i=next[i]){
                    int j=value[i];
                    if(vist[j]==0){
                        vist[j]=1;
                        queue.add(j);
                        if(dist[j]<dist[k]+1){
                            dist[j]=dist[k]+1;
                        }
                        max=Math.max(max,dist[j]);
                    }
                }
            }
        }
        return max;
    }
}
```







### 5、农场

因为每一次从农场的左上角开始，所以每次只要记录pair的值就可以了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908174645.png)



```cpp
class Solution {
    public:
    vector<vector<int>>v1;
    vector<vector<int>> findFarmland(vector<vector<int>>& land) {
        int n=land.size();
        int m=land[0].size();
        vector<int>help;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                pair<int,int>a(-1,-1);
                if(land[i][j]==1){
                    help.clear();
                    help.push_back(i);
                    help.push_back(j);
                    dfs(land,a,i,j);
                    help.push_back(a.first);
                    help.push_back(a.second);
                    v1.push_back(help);
                }
            }
        }
        return v1;
    }
    void dfs(vector<vector<int>>&land,pair<int,int>&p,int i,int j){
        if(i<0||j<0||i>=land.size()||j>=land[0].size()||land[i][j]==0)return;
        land[i][j]=0;
        if(p.first==-1||i>=p.first&&j>=p.second){
            p.first=i;
            p.second=j;
        }
        dfs(land,p,i+1,j);
        dfs(land,p,i-1,j);
        dfs(land,p,i,j+1);
        dfs(land,p,i,j-1);
    }
};
```





### 6、最短的桥

思路：

先用dfs把一个倒岛标记为1

然后全部放入队列

然后在bfs找另一个岛

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221026123401.png)

```cpp
class Solution {
public:
    queue<pair<int,int>>q;
    int step = 0;
    int a[4] = {1,0,-1,0};
    int b[4] = {0,1,0,-1};
    void dfs(vector<vector<int>>&grid,int i,int j){
        if(i < 0||j < 0||i >= grid.size() || j >= grid[0].size() || grid[i][j] != 1)return ;
        q.push(pair(i,j));
        grid[i][j] = 2;
        dfs(grid,i + 1,j);
        dfs(grid,i - 1,j);
        dfs(grid,i,j + 1);
        dfs(grid,i,j - 1);
    }

    void find(vector<vector<int>>&grid){
      while(q.size() > 0){
         int size = q.size();
       while(size > 0){
         size --;
         pair<int,int>&p = q.front();
         int c = p.first;
         int d = p.second;
         q.pop();
         for(int i = 0; i < 4 ;i ++){
             int x = c + a[i];
             int y = d + b[i]; 
             if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == 2)continue;
             if(grid[x][y] == 1)return;
             grid[x][y] = 2;
             q.push(pair(x,y));
         }
       }
       step ++ ;
      }
    }
    int shortestBridge(vector<vector<int>>& grid) {
        int  n = grid.size();
        int m = grid[0].size();
        //将第一个岛屿标记
        int flag = 0;
        for(int i = 0; i < n ; i ++){
            for(int j = 0 ; j < m ; j ++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    flag = 1;
                    break;
                }
            }
            if(flag == 1)break;
        }
       find(grid);
       return step;
    }
};
```





### 7、树的重心



![微信截图_20230103033220](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230103033220.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int tree[100010];
int ne[200010];
int e[200010];
int vist[100010];
int ids = 0;
int mn = 100000000;
int n;
void insert(int a,int b){
    e[ids] = b;
    ne[ids] = tree[a];
    tree[a] = ids++;
}

int dfs(int u){
    vist[u] = 1;
    int res = 0;
    int sum = 1;
    for(int i = tree[u];i!=-1;i = ne[i]){
        int j = e[i];
        if(vist[j] == 0){
            int s = dfs(j);
            sum += s;
            res =  max(res,s);
        }
    }
    res = max(res, n - sum);
    mn = min(res,mn);
    return sum;
}

int main(){
    for(int i = 0 ; i < 100010 ; i ++)tree[i] = -1; 
    cin>>n;
    for(int i = 0; i  < n ; i ++){
        int a,b;
        cin>>a>>b;
        insert(a,b);
        insert(b,a);
    }
    dfs(1);
    cout<<mn<<endl;
}
```







## 八、二分

### **1、寻找大于等于某个数的最左，或者小于等于某个值的最右，左神讲过，用二分**

比如 0 1  1 1 1 1 1 1 2

找出最左边和最右边的1

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715161333.png" style="zoom:67%;" />

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715161345.png" style="zoom:50%;" />

```java
class Main222{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int q=in.nextInt();
        int l;
        int r;
        int mid;
        int index1;
        int index2;
        int []num=new int[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextInt();
        }
        int target;
        for(int i=0;i<q;i++){
            target=in.nextInt();
            l=0;
            r=n-1;
            index1=-1;
            index2=-1;
            //找最左边不小于目标值的下标
            while(l<=r){
                mid=(r+l)/2;
                if(num[mid]>=target){
                    index1=mid;
                    r=mid-1;
                }else l=mid+1;
                System.out.println(index1);
            }
            l=0;
            r=n-1;
            //找最右边小于等于目标值的下标
            while(l<r){
                mid=(r+l)/2;
                if(num[mid]<=target){
                    index2=mid;
                    l=mid+1;
                }else r=mid-1;
            }
            if(index1>=0&&index1<n&&index2>=0&&index2<n&&num[index1]==target&&num[index2]==target){
                System.out.println(index1+" "+index2);
            }else {
                System.out.println(-1+" "+-1);
            }
        }
    }
}
```



### **2、高精度**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807044900.png)



```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        double n=in.nextDouble();
        double l=-10000;
        double r=10000;
        while(r-l>0.00000001){
            double mid=(l+r)/2;
            if(mid*mid*mid<n)l=mid;
            else r=mid;
        }
        System.out.printf("%6f",l);
    }
}
```



### 3、少的数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831182729.png)



```java
class Solution {
    public:
    int missingNumber(vector<int>& nums) {
        int n=nums.size();
        int l=0;
        int r=n;
        while(l<r){
            int mid=(l+r)/2;
            if(nums[mid]!=mid)r=mid;
            else l=mid+1;
        }
        return l;
    }
};
```



### 4、平分和

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220902211542.png)

```java
class Solution {
    public:
    bool isPerfectSquare(int num) {
        int pre=0;
        int last=num;
        int flag=0;
        while(pre<=last){
            int mid=(pre+last)/2;
            if((long long)mid*mid>num)last=mid-1;
          else if((long long)mid*mid<=num){
                pre=mid+1;
                flag=mid;
            }
        }
        return (long long)flag*flag==num;
    }

};
```



### **5、最长上升子序列(难)**

这里构造一个上升的数组，第i个元素是长度为i的上升子序列的末尾

每次遍历，在这个数组中找到小于这个数的最大值，然后更新数组，还有更新一下最长的max

这里用二分处理

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910210600.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        int a[100010];
        int q[100010];
        int main()
        {
           int n;
           cin>>n;
           for(int i=0;i<n;i++){
              cin>>a[i];
           }
          //最大长度
           int len=0;
           for(int i=0;i<n;i++){
             int  l=0;
             int  r=len;
             while(l<r){
                int mid=(l+r)/2+1;
                if(a[i]>q[mid])l=mid;
                else {
                  r=mid-1;
                 }
          }
            len=max(len,r+1);
            q[r+1]=a[i];
         }
            cout<<len;
            return 0;
        }
```



### 6、旋转数组

找出中间值，然后和最后一个元素比较

如果大于他，那么最小值肯定在mid右边

如果小于，最小值肯定在左边

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220914154309.png)



```cpp
class Solution {
    public:
    int findMin(vector<int>& nums) {
        int flag=nums[nums.size()-1];
        int l=0;
        int r=nums.size()-1;
        while(l<r){
            int mid=(l+r)/2;
            if(nums[mid]<flag)r=mid;
            else  l=mid+1;
        }
        return nums[l];
    }
};
```





### 7、结果不超过最大值最小除数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220925202913.png)



```cpp
class Solution {
    public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        int l=1;
        int r=0;
        int flag=0;
        for(int i=0;i<nums.size();i++)r=max(r,nums[i]);
        while(l<=r){
            int mid=(l+r)/2;
            int total=0;
            for(int k:nums){
                if(k%mid!=0)total+=k/mid+1;
                else total+=k/mid;
            }

            if(total>threshold){
                l=mid+1;
            }else {
                flag=mid;
                r=mid-1;
            }
        }
        return flag;
    }
};
```



### **8、匹配字符串序列**

思路：

记录每一个字符出现的次数

然后匹配的时候用二分

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221117035610.png)

```cpp
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
       int n = s.size();
       int m = words.size();
       vector<vector<int>>v(26);
       //存下字符出现的下标
       for(int i = 0 ;i < n ; i ++){
          v[s[i] - 'a'].push_back(i);
       }
       int sum = 0 ;
       for(int i = 0 ; i < words.size() ; i ++){
           int c = words[i].size();
           if(c > n)continue;
           int flag = c ;
           int count = 0 ;
           int w = -1;
          
           for(int j = 0 ;j <c ; j ++){
               auto &h  = v[words[i][j] - 'a'];
               if(h.size() == 0)break;
               if(h[h.size() - 1] < w)break;
               int l = 0;
               int r = h.size() - 1;
               int c = 0;
               while(l <= r){
                   int mid = (l + r)/2;
                
                   if(h[mid] >w){
                       c =h[mid];
                       r = mid - 1;
                   }else if(h[mid] <= w)l = mid + 1;
               }
               if(c <= w)continue;
               w = c;
               count ++;
           }
           if(count == words[i].size())sum ++;
       }
       return sum;
    }
};
```





### **9、最大化城市供电数目**  

> 思路
>
> 最小化最大值和最大化最小值问题用贪心来解决
> 先求前缀和，求出每个城市初始有多少电
> 然后找出最小值，这个最小值就是二分的左端点，然后加上k就是二分的右端点
> 然后我们就开始二分，每次希望一个值，判断他是否可用满足
>
> 二分函数
>
> power就是每个城市的初始供电量
> 现在我们有k做电站，看看能不能分配给power  使得最小值为mid
> need是当前需要的总电站，如果大于k说明不能满足，直接返回false
> 由于贪心，我们对于i来说，要在i + r位置修改，这样子覆盖i这个边界
>
> diff是差分数组，c是前缀和，代表当前城市加了几个电站，用mid减去c和原本的power[i] 就是目前还要几个
> 如果是负数说明满足最小值mid  否则就要让need加上他们的差，然后差分数组起始位置加上m ,差分数组i+r*2 + 1位置减去m
> 


    ```c++
     bool check(long long  mid,vector<long long>&power,int r, int k){
            vector<long long>diff(n,0);
            long long c = 0;
            long long  need = 0;
            for(int i = 0 ; i < n ; i ++){
                //c是当前城市增加的电站数量
                c += diff[i];
                long long m = mid - c - power[i];
                if(m > 0){
                    need += m;
                    //超过了所能建造的电站
                    if(need > k)return false;
                    //由于当前建造了m个电站所以差分数组起始位置要加上m
                    c += m;
                    //新修的电站影响的范围要把后面的减去
                    if(i + r*2 + 1 < n)diff[i + r*2 + 1] -= m;
                }
            }
          return true;
        }
    ```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230115191401.png)

代码

```c++
++class Solution {
public:  
    int n;
    bool check(long long  mid,vector<long long>&power,int r, int k){
        vector<long long>diff(n,0);
        long long c = 0;
        long long  need = 0;
        for(int i = 0 ; i < n ; i ++){
            //c是当前城市增加的电站数量
            c += diff[i];
            long long m = mid - c - power[i];
            if(m > 0){
                need += m;
                //超过了所能建造的电站
                if(need > k)return false;
                //由于当前建造了m个电站所以差分数组起始位置要加上m
                c += m;
                //新修的电站影响的范围要把后面的减去
                if(i + r*2 + 1 < n)diff[i + r*2 + 1] -= m;
            }
        }
      return true;
    }

    long long maxPower(vector<int>& stations, int r, int k) {
        n = stations.size();
        vector<long long>sum(n+1,0);
        vector<long long >power(n,0);
        //计算初始每个城市有多少电用前缀和
        for(int i = 1 ; i <= n ; i ++){
            sum[i] = sum[i - 1] + stations[i - 1];
        }
        long long  left = sum[n];
        for(int i = 0 ; i < n ; i ++){
            power[i] = sum[min(i + r + 1,n)] - sum[max(i - r,0)];
            left = min(left,power[i]);
        }
        
        long long  right = (long long )(left + k + 1);
        while(left + 1 < right){
            long long  mid = (right - left)/2+left;
            if(check(mid,power,r,k))left = mid;
            else right  = mid;
        }
        return left;
    }
};
```









### 10、打家劫舍(最小化最大值)

>这里是最小化最大值，可以考虑用二分，然后贪心

![微信截图_20230205230644](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230205230644.png)

```cpp
class Solution {
public:
    bool judge(int mid,vector<int>&nums,int k){
        int count = 0;
        for(int i = 0 ;i < nums.size() ; i ++){
            if(nums[i] <= mid){
                count++;
                i ++;
            }
        }
        return count >= k;
    }
    int minCapability(vector<int>& nums, int k) {
        int left = 0,right = 1e9 + 7;
        while(left < right){
            int mid = (left + right)/2;
           bool s =  judge(mid,nums,k);
            if(s == true)right = mid;
            else left = mid + 1;
        }
        return left;
    }
};
```



### **11、公平数对(边界很傻逼)**

>先排序再二分，算出当前值可以匹配的最小值和最大值
>找出右边最近的大于最小值的下标，以及最远小于最大值的下标

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230212131152.png)

```cpp
class Solution {
public:
    long long countFairPairs(vector<int>& nums, int lower, int upper) {
         long long sum = 0;
         int n = nums.size();
         sort(nums.begin(),nums.end());
         for(int i = 0 ;i  < n ; i ++){
             int a = lower - nums[i];
             int b = upper - nums[i];
             int l1 = i + 1, r1 = n - 1;
             while(l1 < r1){
                 int mid = l1 + r1 >>1;
                 if(nums[mid] >= a)r1 = mid;
                 else l1 = mid + 1;
             }
             int l2 = i + 1,r2 = n - 1;
             while(l2 < r2){
                 int mid = l2 + r2  + 1>>1;
                 if(nums[mid] <= b)l2 = mid;
                 else r2 = mid - 1;
             }
             if(l1 >= 0 && l1 < n && l2 >= 0 && r2 < n && nums[l1] >= a && nums[l2] <= b){
                 sum += l2 - l1 + 1;
             }
         }
         return sum;
    }
};
```







### 12、我在哪

题目
给一个字符串，找出最小的k，使得该字符串所有大小为k的子字符串不想等

>这里可以用二分

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_set>

using namespace std;
string s;
bool check(int mid){
    unordered_set<string>se;
    for(int i = 0 ; i + mid - 1 < s.size() ; i ++){
        string str = s.substr(i,mid);
        if(se.count(str))return false;
        se.insert(str);
    }
    return true;
}
int main(){
    int n;
    cin>>n;
    cin>>s;
    int l = 1,r = n;
    while(l < r){
        int mid = l + r >>1;
        if(check(mid))r = mid;
        else l =  mid + 1;
    }
    cout<<r<<endl;
    return 0;
}
```



### 13、特殊排序

>思路
>我们可以用类似扑克牌规则，找到一个i 使得 a[i] < 当前数，a[i] + 1 > 当前数
>我们二分mid  a[mid]   > 当前数 ，我们要找到第一个小于当前数的位置，
> 所以我们可以往左边找，如果a[mid - 1] > 当前数然后再往左边，如果 a[k] < 当前数，
>并且a[k + 1]  > 当前数，那么插入位置就是 k + 1
>同理右边也一样
>最后r就行第一个小于当前数的位置，也有可能a[r] 大于当前数，那么就r就是当前要找的位置

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230219144050.png)

```cpp
class Solution {
public:
    vector<int> specialSort(int N) {
        vector<int>v(1,1);
        for(int i = 2 ; i <= N ; i ++){
            int l = 0,r = v.size() - 1;
            while(l < r){
                int mid = r + l + 1 >> 1;
                if(compare(v[mid],i))l = mid;
                else r = mid - 1;
            }
            v.push_back(i);
            for(int i = v.size() - 2 ; i > r ;  i --)swap(v[i],v[i + 1]);
            if(compare(i,v[r]))swap(v[r],v[r + 1]);
        }
        return v;
    }
};
```





### 14、出行的最少费用（二分加动态规划）

>dp+二分，注意到数据范围是n=10^5,m=20，大概率是用n*m的算法。因此在每次dp考虑可以遍历tickets。
>由于day有序，不需要额外排序。
>令f[i]为前i个day有机票覆盖时，最小的花费。
>显然第一个day，就是min(tickets)，这里前提是数据规定了没有任何一张票覆盖小于1天，即对于一天，任何票都可以飞，取花费最小即可。
>对于第i天，如果这天使用的一张票，时长价格为(v,p)，那么我可以向前坐，看看这张票能覆盖到多远的之前，这之间的票可以不买了，只买边界最早那张。
>计算s = d - v ，即s是用不到这张票的最后一天。
>如果s比day[0] (最早一天)还小，说明从开始到这天都可以用这张票搞定f[i] = p。
>如果s > day[i-1]，即本票不能覆盖前边任意一天，那前边的票依然要买，还要为今天单独买这张票f[i] = p + f[i-1]
>如果s <= day[i - 1] 那么要找出 一个最大index  使得 day[index] <= s,用二分 



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230220175755.png)

```cpp
class Solution {
public: 
    long long findmin(long long a,long long b){
        if(a > b)return b;
        return a;
    }
    long long minCostToTravelOnDays(vector<int>& days, vector<vector<int>>& tickets) {
       int  m  =  tickets.size();
       int n = days.size();
       vector<long long>f(n,33333500000000);
        for(int i = 0 ;i < m ; i ++)f[0] = findmin(f[0],(long long)tickets[i][1]);
      
        for(int i = 1 ;i  < n ;i  ++){
            int d = days[i] ;
        
            for(int j = 0 ; j < m ; j ++){
                int v = tickets[j][0];
                int p = tickets[j][1];
                int s = d - v;
                if(s < days[0]){
                    f[i] = findmin(f[i],p);
                }else if(s > days[i - 1]){
                    f[i] = findmin(f[i],f[i - 1] +(long long) p);
                }else {
                    int l = 0;
                    int r = i;
                    while(l < r){
                        int mid = l + r  + 1>> 1;
                        if(days[mid] <= s)l = mid;
                        else r = mid  - 1;
                    }
                
                    f[i] = findmin(f[i],f[l] + (long long)p);
                }
            }
        }
        return f[n - 1];
    }
};
```





## 九、贪心‘

#### 1、公交车

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220716073406.png)

超级恶心一道题

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        Arrays.sort(buses);
        Arrays.sort(passengers);
        int anx=0;
        Queue<Integer>queue=new LinkedList<>();
        HashSet<Integer>set=new HashSet<>();
        for(int k:passengers){
            queue.add(k);
            set.add(k);
        }

        for(int i=0;i<buses.length;i++){
            int c=capacity;//座位数
            int sum=buses[i];
            while(c>0&&queue.size()>0&&queue.peek()<=sum){
                int k=queue.poll();
                c--;
                if(set.contains(k-1)==false)anx=k-1;

            }
            if(c>0&&set.contains(sum)==false)anx=sum;
        }
        return anx;
    }
}
```



解法二也是类似贪心，不过不用set集合，节省了时间

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        int n1=buses.length;
        int n2=passengers.length;
        Arrays.sort(buses);
        Arrays.sort(passengers);
        int c;
        int max=0;
        int sum=0;
        int pre=0;
        int p=0;
        for(int i=0;i<n1;i++){
            sum=buses[i];
            c=0;
            //符合一下条件，才能上去，这个乘客
            while(p<n2&&passengers[p]<=sum&&c<capacity){
                if(p==0||p>0&&passengers[p]-1!=passengers[p-1]){
                    max=Math.max(max,passengers[p]-1);
                }
                c++;
                p++;
            }
            if((c<capacity)&&(p==0||p>0&&passengers[p-1]!=sum)){
                max=sum;
            }
        }
        return max;
    }
}
```



#### 2、区间合并

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719043613.png" style="zoom:67%;" />



具体思路是将左端点从左到右排序，然后每一次遍历一个组合的时候，如果新元素的左端点在当前区间之间，那么判断当前元素的右端点是否大于当前区间的右端点，更新当前区间的右端点，如果新元素左端点不在此区间，那么sum++,并且更新右端点

```java
class Main2222{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int sum=0;
        List<int[]>list=new ArrayList<>();
        for(int i=0;i<n;i++){
            int k1=in.nextInt();
            int k2=in.nextInt();
            int []a=new int[2];
            a[0]=(k1);
            a[1]=(k2);
            list.add(a);
        }
        Sort sort=new Sort();
        Collections.sort(list,sort);
        for(int[]a:list){
            System.out.println(Arrays.toString(a));
        }
        int last=list.get(0)[1];
        int i=1;
        while(i<n){
            int k1=list.get(i)[0];
            int k2=list.get(i)[1];
            if(k1<=last){
                if(last<=k2)last=k2;
            }else if(k1>last){
                last=k2;
                sum++;
            }
            i++;
            System.out.println(last);
        }
        System.out.println(sum+1);
    }
}
class Sort implements Comparator<int[]>{


    @Override
    public int compare(int[] o1, int[] o2) {
        return Integer.compare(o1[0],o2[0]);
    }
}
```



#### 3、加油站

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725171110.png)

贪心，如果总的加油不能大于消耗，直接return -1;



```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n=gas.length;
        int sum=0;
        int rest=0;
        int index=0;
        for(int i=0;i<n;i++){
            rest=rest+gas[i]-cost[i];
            sum=sum+gas[i]-cost[i];
            if(sum<0){
                index=i+1;
                sum=0;
            }
        }
        if(rest<0)return -1;
        return index;
    }
}
```



## **十、定制排序(重要)**

### 1、定制排序

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717132349.png)

```java
 public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
        int n=nums.length;
        int m=queries.length;
        sort []sort=new sort[n];
        int []help=new int[m];
        for(int i=0;i<m;i++){
            int k=queries[i][0];
            int trim=queries[i][1];
            for(int j=0;j<n;j++){
               if(nums[j].length()<trim){
                   sort[j]=new sort("0",j);
               }else {
                   sort[j]=new sort(nums[j].substring(nums[j].length()-trim),j);
               }
            }
           // System.out.println(Arrays.toString(sort));
            Arrays.sort(sort);
            help[i]=sort[k-1].age;
        }
        return help;
    }
}
class sort implements Comparable<sort>{
    String s;
    int age;

    public sort(String s, int age) {
        this.s = s;
        this.age = age;
    }

    @Override
    public int compareTo(sort o) {
        return this.s.compareTo(o.s);
    }

    @Override
    public String toString() {
        return "sort{" +
                "s='" + s + '\'' +
                ", age=" + age +
                '}';
    }
}
```

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730213141.png)

### 2、卡牌

```java
import java.util.*;
public class Main{
    public static void  main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []s=new int[n+1];
        int min=1;
        int sum=0;
        count1 []count1=new count1[n+1];
        TreeSet<count1>set=new TreeSet<>();
        for(int i=1;i<=n;i++){
            count1[i]=new count1(i,0);
            set.add(count1[i]);
        };
        for(int i=0;i<m;i++) {
            int x=in.nextInt();
            set.remove(count1[x]);
            count1[x].value=count1[x].value+1;
            set.add(count1[x]);
            if(set.first().value-sum<1){
                System.out.print(0);
            }else {
                System.out.print(1);
                sum++;
            }
        }
    }
}
class count1 implements Comparable<count1>{
    public  int index;
    public  int value;

    public count1(int index, int value) {
        this.index = index;
        this.value = value;
    }

    public count1() {
    }


    @Override
    public int compareTo(count1 o) {
        if(this.value!=o.value)
            return Integer.compare(this.value,o.value);
        return Integer.compare(this.index,o.index);
    }

}
```



### 3、根据身高重建队列

思路：首先按照身高从大到小，然后如果身高相同就按照k从小到大依次加入集合

因为先把大的放后，小的不会影响大的，而且先按照k小的放置，这样子不会混乱

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802013429.png)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        help p=new help();
        Arrays.sort(people,p);
        List<int[]>list=new ArrayList<>();
        for(int []a:people){
            list.add(a[1],a);
        }
        for(int i=0;i<people.length;i++){
            people[i]=list.get(i);
        }
        return people;
    }
}

class help implements Comparator<int[]>{
    @Override
    public int compare(int[] o1, int[] o2) {
        if(o1[0]!=o2[0])return Integer.compare(o2[0],o1[0]);
        return Integer.compare(o1[1],o2[1]);
    }
}
```





### 4、权重排序

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819014405.png)

```java
import java.util.*;
class Solution {
    public int getKth(int lo, int hi, int k) {
        List<p2>list=new ArrayList<>();
        for(int i=lo;i<=hi;i++){
            list.add(new p2(i,get(i)));
        }
        Collections.sort(list);
        return list.get(k-1).value;
    }
    public static int  get(int n){
        if(n==1)return 0;
        if(n%2==1)return get(n*3+1)+1;
        return get(n/2)+1;
    }
}

class  p2 implements Comparable<p2>{
    int value;
    int flag;

    public p2(int value, int flag) {
        this.value = value;
        this.flag = flag;
    }

    @Override
    public int compareTo(p2 o) {
        if(this.flag!=o.flag)return Integer.compare(this.flag,o.flag);
        return Integer.compare(this.value,o.value);
    }
}
```



### 5、标签

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815235856.png)

```java
class Solution {

    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        //构建大顶堆
        PriorityQueue<node> queue = new PriorityQueue<>(new com());
        for(int i=0;i<values.length;i++){
            queue.add(new node(values[i],labels[i]));
        }
        int sum=0;
        int count=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        while(count<numWanted){
            node nodes=queue.poll();
            //System.out.println(nodes);
            if(nodes==null)break;
            int value=nodes.value;
            int lab=nodes.lab;
            if(map.get(lab)==null||map.get(lab)<useLimit){
                sum+=value;
                count++;
                if(map.get(lab)==null)map.put(lab,1);
                else map.put(lab,map.get(lab)+1);
            }
        }
        return sum;
    }
}

class com implements  Comparator<node>{

    @Override
    public int compare(node o1, node o2) {
        if(o1.value!=o2.value)
            return o2.value-o1.value;
        return o1.lab-o2.lab;
    }
}
class node{

    public int value;
    public  int lab;

    public node(int value, int lab) {
        this.value = value;
        this.lab = lab;
    }


}
```



### **6、数字容器系统**(难)

思路：

就是两个map

一个对应下标和值的关系

一个对应值的下标的关系

因为一个值可能多个下标

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908183023.png)



```cpp
class NumberContainers {
    //自动排序set
    map<int,int>map1;
    map<int,set<int>>map2;
    public:
    NumberContainers() {

    }

    void change(int index, int number) {
        if(map1.count(index)!=0){
            int pre=map1[index];
            map2[pre].erase(index);
        }map1[index]=number;
        map2[number].insert(index);
    }

    int find(int number) {
        set<int>&s=map2[number];
        if(s.size()<=0)return -1;
        return *(s.begin());
    }
};
```





十一、回溯

1、组合加减枝

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718035907.png)

每一次回溯，记得如果list1的数加上w后面的数小于k时候，代表后面不能凑齐k个数，可以直接返回了

```java
class Solution {
    List<List<Integer>>list1;
    public List<List<Integer>> combine(int n, int k) {
        list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        dfs(list2,n,k,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int n,int k,int w){
        if(n-w+list2.size()<k)return ;
        if(list2.size()==k){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=w+1;i<=n;i++){
            list2.add(i);
            dfs(list2,n,k,i);
            list2.remove(list2.size()-1);
        }
    }
}
```



## 十一双指针

### **1、最长连续序列(双指针加哈希)**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718091005.png" style="zoom:50%;" />

具体思路是来两个指针pre, last last往后走，如果map存在Num[last],并且map.get(num[last])>=pre (只要在pre到last之间重复的元素才不能添加进来)，更新max,让pre=num[last]在的位置，更新map 中Num[last]的值，last++;

比如 1  0 2 3 4 5 6 2 9 10

pre 等于0  last=7时候，2重复，并且map中的2下标在pre和last之间，所以更新max,让pre等于2的下标加一，并且让map中的2更新为7，然后last++;

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int pre=0;
        int last=1;
        int [] nums=new int[n];
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            nums[i]=in.nextInt();
        }
        int max=1;
        map.put(nums[0],0);
        while(last<n){
            if(map.containsKey(nums[last])==true&&map.get(nums[last])>=pre){
                max=Math.max(last-pre,max);
                int k=map.get(nums[last]);
                if(k+1>=n)break;
                map.put(nums[last],last);
                last++;
                pre=k+1;
            }else{
                max=Math.max(max,last-pre+1);
                map.put(nums[last],last);
                last++;
            }
        }
        System.out.println(max);
    }
}
```

解法2

每一次添加Num[i]的时候

s[num[i]]++;

如果大于一，说明有重复，让j++,并且同时让s[nums[j]]--;

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int pre=0;
        int last=0;
        int [] nums=new int[n];
        int []s=new int[100001];
        int max=0;
        for(int i=0;i<n;i++){
            nums[i]=in.nextInt();
        }
        while(last<n){
            s[nums[last]]++;
            while(s[nums[last]]>1){
                s[nums[pre]]--;
                pre++;
            }
            max=Math.max(max,last-pre+1);
            last++;
        }
        System.out.println(max);
    }
}
```

### 2、字符串版本

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220726031318.png)



```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0)return 0;
        int []num=new int[128];
        int last=0;
        int pre=0;
        int sum=1;
        while(last<s.length()){
            int k=s.charAt(last);
            num[k]++;
            while(num[s.charAt(last)]>1){
                num[s.charAt(pre)]--;
                pre++;
            }
            sum=Math.max(last-pre+1,sum);
            last++;
        }
        return sum;
    }
}
```

### **3、两个数组**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719033955.png" style="zoom:67%;" />

双指针，让一个指针在前，一个在后，每次让j往前移动

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int x=in.nextInt();
        int []a=new int[n];
        int []b=new int[m];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        for(int j=0;j<m;j++){
            b[j]=in.nextInt();
        }
        int sum=0;
        int pre=0;
        int last=m-1;
        while(pre<n){
            while(b[last]+a[pre]>x)last--;
            if(b[last]+a[pre]==x){
                System.out.println(pre+" "+last);
                break;
            }
            pre++;
        }
    }
}
```



### 4、重叠部分

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220727011347.png)



```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List<Integer> list=new ArrayList<>();
        int index1=0;
        int index2=0;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        while(index1<nums1.length&&index2<nums2.length){
            if(nums1[index1]<nums2[index2]){
                index1++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else {
                list.add(nums1[index1]);
                index1++;
                index2++;
            }
        }
        int []a=new int[list.size()];
        for(int i=0;i<list.size();i++){
            a[i]=list.get(i);
        }
        return a;
    }
}
```



### 5、字符二进制

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220817012456.png)

```java
class Solution {
    int sum;
    public boolean hasAllCodes(String s, int k) {
        HashSet<String>set=new HashSet<>();
        int left=0;
        int right=k;
        while(right<=s.length()){
            set.add(s.substring(left,right));
            left++;
            right++;
        }
        return set.size()==Math.pow(2,k);
    }
}
```



### 6、下标最大



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820150819.png)

```java
class Solution {
    public int maxDistance(int[] nums1, int[] nums2) {
        int n1=nums1.length;
        int n2=nums2.length;
        int i=0;
        int j=0;
        int max=0;
        while(i<n1&&j<n2){
            if(nums1[i]>nums2[j])i++;
            else {
                max=Math.max(j-i,max);
                j++;
            }
        }
        return max;
    }
}
```



### **7、摘苹果**

双指针，数组记录每一个数的大小，然后两个指针滑动

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821171442.png)

```java
class Solution {
    public int totalFruit(int[] fruits) {
        HashSet<Integer>set=new HashSet<>();
        int []num=new int[100001];
        int n=fruits.length;
        if(n==1)return 1;
        if(n==2)return 2;
        set.add(fruits[0]);
        set.add(fruits[1]);
        int left=0;
        int right=2;
        int max=2;
        num[fruits[0]]++;
        num[fruits[1]]++;
        while(right<n){
            if(set.size()>=2&&set.contains(fruits[right])==false){
                num[fruits[left]]--;
                if(num[fruits[left]]==0)
                    set.remove(fruits[left]);
                left++;
            }else {
                set.add(fruits[right]);
                num[fruits[right]]++;
                max=Math.max(right-left+1,max);
                right++;
            }
        }
        return max;
    }
}
```



### 8、找k个最接近的元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825144800.png)

第一种方法，删除两边最大元素

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n=arr.length;
        int l=0,r=n-1;
        for(int i=0;i<n-k;i++){
            if(Math.abs(arr[l]-x)<=Math.abs(arr[r]-x))r--;
            else l++;
        }
        List<Integer>list=new ArrayList<>();
        for(int i=l;i<=r;i++){
            list.add(arr[i]);
        }
        return list;
    }
}
```



第二种：二分

找到中间最接近的，然后往两边找

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        Arrays.sort(arr);
        int n=arr.length;
        int left=0;
        int right=n-1;
        int index=0;
        while(left<right){
            int mid=(left+right)/2;
            if(arr[mid]>=x){
                right=mid;
            }else {
                left=mid+1;
            }
        }
        List<Integer>list=new ArrayList<>();
        int pre=left-1;
        int last=left;
        while(k>0){
            k--;
            if(pre<0)last++;
            else if(last>=n)pre--;
            else if(x-arr[pre]<=arr[last]-x)pre--;
            else last++;
        }
        for(int i=pre+1;i<last;i++)list.add(arr[i]);
        return list;
    }
}
```



### **9、长度为3的不同回文子串**

双指针从前往后枚举就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002234431.png)

```cpp
class Solution {
    public:
    int countPalindromicSubsequence(string s) {
        int n = s.size();
        int sum = 0;
        for(char i = 'a';i <= 'z'; i ++){
            int pre = 0;
            int last = s.size()-1;
            while(pre<n&&s[pre]!=i) pre ++;
            while(last>=0&&s[last]!=i) last --;
            if(last - pre<2)continue;
            set<char>st;
            for(int j = pre+1;j <last;j++){
                st.insert(s[j]);
            }
            sum += st.size();
        }
        return sum;
    }
};
```

## **十二、回溯**

### 1、组合

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725171556.png)

可以适当剪枝

```java
class Solution {
    List<List<Integer>>list1;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        Arrays.sort(candidates);
        dfs(list2,candidates,target,0,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int []candidates,int target,int sum,int n){
        if(n+1>candidates.length)return;
        if(sum==target){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=n;i<candidates.length;i++){
            if(candidates[i]+sum<=target){
                list2.add(candidates[i]);
                dfs(list2,candidates,target,sum+candidates[i],i);
                list2.remove(list2.size()-1);
            }
        }
    }
}
```

### **2、组合剪枝**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725172013.png" style="zoom:67%;" />

因为不能重复，而且数组中可能有重复的数字，所以先排序，如果canditates[i]==codnitates[i-1]并且i-1没有被访问，说明有重复动作，所以要减枝

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>>list=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        int []help=new int[candidates.length];
        Arrays.sort(candidates);
        dfs(list,list2,candidates,target,0,-1,help);
        return list;
    }
    public void dfs(List<List<Integer>>list,List<Integer>list2,int []candidates,int target
            ,int sum,int n,int []help){
        if(sum==target){
            list.add(new ArrayList<>(list2));
            return;
        }
        if(sum>target){
            return;
        }
        for(int i=n+1;i<candidates.length;i++){
            if(i>0&&candidates[i]==candidates[i-1]&&help[i-1]==0)continue;
            list2.add(candidates[i]);
            help[i]=1;
            dfs(list,list2,candidates,target,sum+candidates[i],i,help);
            if(list2.size()>0)list2.remove(list2.size()-1);
            help[i]=0;
        }
    }
}
```



### 3、回文数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220727205402.png)

```java
class Solution {
    List<List<String>>list1=new ArrayList<>();
    public List<List<String>> partition(String s) {
        List<String>list2=new ArrayList<>();
        dfs(s,list2,0);
        return list1;
    }
    public void dfs(String s,List<String>list2,int n){
        if(n>=s.length()){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=n;i<s.length();i++){
            String str=s.substring(n,i+1);
            if(judge(str)==true){
                list2.add(str);
                dfs(s,list2,i+1);
                list2.remove(list2.size()-1);
            }
        }
    }
    public boolean judge(String s){
        int pre=0;
        int last=s.length()-1;
        while(pre<=last){
            if(s.charAt(pre)!=s.charAt(last))return false;
            pre++;
            last--;
        }
        return true;
    }
}
```



### 4、子集(减枝)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220728154542.png)

```java
class Solution {
    int []vist;
    List<List<Integer>>list1=new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        vist=new int[nums.length];
        Arrays.sort(nums);
        List<Integer>list2=new ArrayList<>();
        dfs(list2,nums,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int []nums,int n){
        if(n>nums.length)return;
        list1.add(new ArrayList<>(list2));
        for(int i=n;i<nums.length;i++){
            if(i>0&&vist[i-1]==0&&nums[i-1]==nums[i])continue;
            vist[i]=1;
            list2.add(nums[i]);
            dfs(list2,nums,i+1);
            list2.remove(list2.size()-1);
            vist[i]=0;
        }
    }
}
```



### **5、减枝(set)难点**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220728214918.png)

这里我们不能用之前排序的减枝，因为这里顺序是不固定的，所以我们要用set  [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]这是一个极端样例

每一层我们放一个set来记录每一层收入的点，在这一层中这一个点只能出现一次，因为第一次就可以把后面所以情况全部枚举出来，所以后面相同的值直接跳过

```java
class Solution {
    List<List<Integer>>list1=new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer>list2=new ArrayList<>();
        int []vist=new int[nums.length];
        dfs(list2,nums,vist,-1000,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int[]nums,int[]vist,int pre,int n){
        if(list2.size()>=2)list1.add(new ArrayList<>(list2));
        HashSet<Integer>set=new HashSet<>();
        for(int i=n;i<nums.length;i++){
            if(set.contains(nums[i]))continue;
            if(nums[i]>=pre){
                list2.add(nums[i]);
                set.add(nums[i]);
                dfs(list2,nums,vist,nums[i],i+1);
                list2.remove(list2.size()-1);
            }
        }
    }
}
```





### 6、机场回溯加字典排序

思路：用Map嵌套map  表示第一个点到其他点有几次，然后第二个map要用treemap，便于字典排序，因为有treemap如果集合塞满了就是最优解，回溯的目的是保证要有解

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220803023344.png)



```java
class Solution {
    List<String>list;
    HashMap<String,TreeMap<String,Integer>>map;

    public void dfs(int size){
        if(list.size()==size)return;
        //获取最后一个元素
        String s=list.get(list.size()-1);
        //最后一个元素有目的地
        if(map.get(s)!=null){
            var help=map.get(s);
            for(Map.Entry<String,Integer> set:map.get(s).entrySet()){
                if(set.getValue()>0){
                    // System.out.println(set.getKey());
                    list.add(set.getKey());
                    //System.out.println(set.getKey());
                    int count=set.getValue();
                    set.setValue(count-1);
                    dfs(size);
                    if(list.size()==size)return;
                    list.remove(list.size()-1);
                    set.setValue(count);
                }
            }
        }
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map=new HashMap<>();
        list=new ArrayList<>();
        for(List<String>k:tickets){
            String s1=k.get(0);
            String s2=k.get(1);
            if(map.get(s1)==null){
                TreeMap<String,Integer>map2=new TreeMap<>();
                map2.put(s2,1);
                map.put(s1,map2);
            }else{
                var map3=map.get(s1);
                if(map3.get(s2)==null){
                    map3.put(s2,1);
                }else {
                    map3.put(s2,map3.get(s2)+1);
                }

            }
        }
        //System.out.println(map);
        list.add("JFK");
        //所有的机票要用一次
        dfs(tickets.size()+1);
        return list;
    }
}
```



### 7、n皇后

有一个小技巧，可以用两个集合装横坐标和纵坐标的和与差

因为横坐标和纵坐标之和一样的两个点肯定在一条斜线上，

横坐标和纵坐标之差一样的点肯定也在一条斜线上

这样子优化查找效率

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220805225303.png)

```java
class Solution {
    int n;
    List<List<String>>list1;
    HashSet<Integer>set1;
    HashSet<Integer>set2;
    HashSet<Integer>set3;
    public List<List<String>> solveNQueens(int m) {
        set1=new HashSet<>();
        set2=new HashSet<>();
        set3=new HashSet<>();
        list1=new ArrayList<>();
        n=m;
        int[][]s=new int[n][n];
        dfs(s,0);
        return list1;
    }
    public void dfs(int[][]num,int count){
        //System.out.println(count);
        if(count==n){
            add(num);
            return;
        }
        for(int i=0;i<n;i++){
            if(judge(num,count,i)==true){
                num[count][i]=1;
                set1.add(count+i);
                set2.add(count-i);
                set3.add(i);
                dfs(num,count+1);
                set1.remove(count+i);
                set2.remove(count-i);
                set3.remove(i);
                num[count][i]=0;
            }

        }
    }
    public boolean judge(int [][]num,int i,int j){
        if(set3.contains(j)==true)return false;
        if(set1.contains(i+j)||set2.contains(i-j))return false;
        return true;
    }

    public void add(int[][]s){
        List<String> list2=new ArrayList<>();
        String w="";
        for(int i=0;i<n;i++){
            w="";
            for(int j=0;j<n;j++){
                if(s[i][j]==0)w=w+".";
                else w=w+"Q";
            }
            list2.add(w);
        }
        list1.add(list2);

    }
}
```

## 十三、栈



### 1、用栈实现队列

```java
class CQueue {
    Stack<Integer>stack1;
    Stack<Integer>stack2;
    public CQueue() {
        stack1=new Stack<>();
        stack2=new Stack<>();
    }

    public void appendTail(int value) {
        stack1.push(value);
    }

    public int deleteHead() {
        if(stack2.size()==0){
            while(stack1.size()!=0){
                stack2.add(stack1.pop());
            }
        }
        if(stack2.size()==0)return -1;
        return stack2.pop();
    }
}
```





### 2、最小堆栈

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220801063605.png)

```java
class MinStack {

   Stack<Integer>stack=new Stack();
   Stack<Integer>min=new Stack();
   public MinStack() {

   }

   public void push(int val) {
      stack.push(val);
      if(min.size()==0)min.push(val);
      else {
         if(val<=min.peek())min.push(val);
      }
   }

   public void pop() {
      int x=stack.pop();
      if(min.size()>0&&min.peek()==x)min.pop();
   }

   public int top() {
      return stack.peek();
   }

   public int getMin() {
      return min.peek();
   }
}
```



### **3、栈的输入输出顺序**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807062117.png)

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        int n=pushed.length;
        int left=0;
        int right =0;
        Stack<Integer>stack=new Stack<>();
        for(int i=0;i<n;i++){
            stack.push(pushed[i]);
            while(right<n&&!stack.isEmpty()&&stack.peek()==popped[right]){
                right++;
                stack.pop();
            }
        }
        return right==n;
    }
}
```









### 4、有效括号

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813213223.png)



```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character>stack=new Stack<>();
        int n=s.length();
        for(int i=0;i<n;i++){
            var a=s.charAt(i);
            if(a=='(')stack.push(')');
            else if(a=='{')stack.push('}');
            else if(a=='[')stack.push(']');
            else if(stack.size()==0||stack.peek()!=a)return false;
            else stack.pop();
        }
        return stack.size()==0;
    }
}
```

### 5、折扣(单调栈)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220901221854.png)



```c++
class Solution {
    public:
    vector<int> finalPrices(vector<int>& prices) {
        stack<int>s;
        int n=prices.size();
        vector<int>v(n);
        for(int i=n-1;i>=0;i--){
            while(s.size()>0&&s.top()>prices[i]){
                s.pop();
            }
            if(s.size()==0)v[i]=prices[i];
            else v[i]=prices[i]-s.top();
            s.push(prices[i]);
        }
        return v;
    }
};
```



### 6、删除重复项

思路：如果当前元素和上一个不同，堆栈加1这个元素

否则堆栈顶部加一

如果大小到了，删除字符串这K个元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220912033910.png)

```cpp
class Solution {
    public:
    string removeDuplicates(string s, int k) {
        int n=s.size();
        stack<int>st;
        for(int i=0;i<s.size();i++){
            if(i==0||s[i]!=s[i-1])st.push(1);
            else {
                st.top()++;
                if(st.top()==k){
                    s.erase(i+1-k,k);
                    i=i-k;
                    st.pop();
                }
            }
        }
        return s;
    }
};
```







### **7、括号的分数(难)**

先压入0  表示分数是0

如果遇到左括号  就压入0表示  加一个0  因为() 分数为1   (s)为s*2

所以遇到)  弹出堆栈顶部

然后判断是哪种形式  



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009013939.png)

```cpp
class Solution {
    public:
    int scoreOfParentheses(string s) {
        int n = s.size();
        stack<int>st;
        st.push(0);
        for(int i = 0;i<n ;i++){
            if(s[i] == '('){
                st.push(0);
            }else {
                int k = st.top();
                st.pop();
                if(k == 0)st.top() += 1;
                else st.top() += 2*k;
            }
        }
        return st.top();
    }
};
```



### **8、机器人打印**

可以把题目理解为给定一个字符串

运用一个堆栈能得到的最小字典序字符串

因为最多26个字母

所以我们记录每个字母出现的最后一个位置

然后每次枚举 从a开始

先判断堆栈顶部的元素是不是比当前枚举的小  然后加入字符串末尾

遇到枚举的字母，加入字符串末尾  否则入堆栈

最好把堆栈的字符串加回去

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009135011.png)



```cpp
class Solution {
    public:
    string robotWithString(string s) {
        string res,t;
        int index = 0 ;
        vector<int>pos(26,-1);
        for(int i = 0;i<s.size();i++)
            pos[s[i]-'a'] = i;

        for(int i = 0,k=0;i<26&&k<s.size();i++){
            char c = i+'a';
            while(t.size()&&t.back()<=c){
                res +=t.back();
                t.pop_back();
            }
            while(k<=pos[i]){
                if(s[k]==c)res += c;
                else  t += s[k];
                k++;
            }
        }
        reverse(t.begin(),t.end());
        return res + t;
    }
};
```





### 9、股票的跨度

思路：可以转变为找出第一个比当前值大的元素的下表加一

所有每次遇到一个值  把小于他的弹出

这里堆栈要用pair 记录每个值的下标是多少

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221021032218.png)

```cpp
class StockSpanner {
    public:
    stack<pair<int,int>>st;
    int index = 0;
    StockSpanner() {

    }

    int next(int price) {
        int sum = 1;
        while(st.size() > 0 && st.top().first <= price){
            st.pop();
        }
        if(st.size() > 0) sum = index-(st.top().second);
        else sum = index + 1;
        pair<int,int>m(price,index);
        index ++;
        st.push(m);
        return sum;
    }
};
```

## 十四、并查集

### 1、按公因数计算最大组件

这里用了数学思维，就是求公约数用了一个方法

 ![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730003126.png)

```java
class Solution {
    int[]parent;
    public int largestComponentSize(int[] nums) {
        int n=0;
        for(int i=0;i<nums.length;i++){
            n=Math.max(n,nums[i]);
        }
        parent=new int[n+1];
        for(int i=0;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<nums.length;i++){
            int k=nums[i];
            for(int j=2;j*j<=k;j++){
                if(k%j==0){
                    union(j,k);
                    union(j,k/j);
                }
            }
        }
        int max=0;
        int []count=new int[n+1];
        for(int i=0;i<nums.length;i++){
            int root=findroot(nums[i]);
            count[root]++;
            max=Math.max(max,count[root]);
        }
        return max;
    }

    //联通
    public void union(int root1,int root2){
        int k1=findroot(root1);
        int k2=findroot(root2);
        if(k1==k2)return;
        if(k1<k2)
            parent[k1]=k2;
        else parent[k2]=k1;
    }

    //寻找跟，路径压缩
    public int findroot(int x){
        if(parent[x]!=x){
            parent[x]=findroot(parent[x]);
        }
        return parent[x];
    }
}
```



### **2、吃动物**(难)

我们可以这样，用一个parent表示父节点，然后一个dist数组表示整个点到父亲点的距离

一个点到根节点距离取余3
>1  可以吃根
>
>2   被根吃
>
>0是同类

所以我们只要算出两个点的dist值就可以判断这两只动物的关系



在找根的时候，我们要先保存根根节点是谁，也就是路径压缩

让dist[x]+=dist[parent(x)];当前结点到根的距离等于当前结点到父节点的距离dist[x]+父节点到根结点的距离

因为是递归，x的父节点的dist刚好是根的距离，因为x的父节点直接指向了根，但是dist[x]只是单纯的父节点距离





![微信截图_20230227002747](C:\Users\waili\Desktop\usual\微信截图\ACWING\微信截图_20230227002747.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806033827.png)

```java
import java.util.*;
public class Main{
    static int []parent;
    static int sum;
    static int[]dist;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        parent=new int[50005];
        dist=new int[50005];
        sum=0;
        int n=in.nextInt();
        int k=in.nextInt();
        for(int i=1;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<k;i++){

            int d=in.nextInt();
            int x=in.nextInt();
            int y=in.nextInt();
            if(x>n||y>n)sum++;
            else{
                int root1=findroot(x);
                int root2=findroot(y);
                if(d==1){
                    if(root1==root2&&(dist[x]-dist[y])%3!=0)sum++;
                    else if(root1!=root2){
                        parent[root1]=root2;
                        dist[root1]=dist[y]-dist[x];
                    }
                }else{
                    if(root1==root2&&(dist[x]-dist[y]-1)%3!=0){
                        sum++;
                    }else  if(root1!=root2){
                        parent[root1]=root2;
                        dist[root1]=dist[y]-dist[x]+1;
                    }
                }
            }
        }
        System.out.println(sum);
    }

    public static int findroot(int x){
        if(parent[x]!=x){
            int t=findroot(parent[x]);
            dist[x]+=dist[parent[x]];
            parent[x]=t;
        }
        return parent[x];
    }
}
```



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
const int N =  50010;
int p[N];
int d[N];
int n;
int m;
using namespace std;

int find(int x)  // 并查集
{
    if (p[x] != x){
        int t = find(p[x]);
        d[x] += d[p[x]];
        p[x] = t;
    }
    return p[x];
}
int main(){
   cin >>n>>m;
   int res = 0;
   for(int i = 0 ; i < N ; i ++)p[i] = i;
   while(m --){
       int s,x,y;
       cin>>s>>x>>y;
       if(x > n || y > n){
           res ++;
           continue;
       }
       int p1 = find(x),p2 = find(y);
       if(s == 1){
           if(p1 == p2 &&(d[x] - d[y]) % 3 != 0)res ++;
           else if(p1 != p2){
               p[p1] = p2;
               d[p1] = d[y] - d[x];
           }
       }else {
           if(p1 == p2 && (d[x] - d[y] - 1) % 3 != 0)res ++;
           else if(p1 != p2){
               p[p1] = p2;
               d[p1] = d[y] - d[x] + 1;
           }
       }
   }
    cout<<res<<endl;
    return 0;
}
```





### **3、删除后最大子段和(难)**

我们可以倒序，添加，然后逐一统计区间的最大数量

用并查集

s表示添加后这段区间的大小

同时，对于x两边的数，如果s[x]大于0，表示添加过，加入并查集，记住，先找出它的根，然后加s[根],最后将根指向x，一层层叠加下去，然后加入吧max加入集合，更新max

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821021848.png)



```java
class Solution {
    long max;
    int[]p;
    long []s;
    public int find(int a){
        if(p[a]!=a)p[a]=find(p[a]);
        return p[a];
    }
    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {
        max=0;
        int n=nums.length;
        p=new int[n];
        s=new long[n];
        List<Long>list=new ArrayList<>();
        for(int i=0;i<n;i++){
            p[i]=i;
            s[i]=0;
        }
        for(int i=n-1;i>=0;i--){
            int x=removeQueries[i];
            s[x]=nums[x];
            for(int j=x-1;j<=x+1;j=j+2){
                //点的左右两边都有值,加入并查集
                if(j>=0&&j<n&&s[j]>0){
                    s[x]+=s[find(j)];
                    p[find(j)]=x;
                }
            }
            list.add(max);
            // System.out.println(max);
            max=Math.max(max,s[x]);
        }
        long []a=new long[list.size()];
        int index=0;
        for(int i=list.size()-1;i>=0;i--){
            a[index]=list.get(i);
            index++;
        }
        return a;
    }
}
```





### 4、无法到达的点队数

思路：

明显并查集，因为无法到达的带你肯定不在一个集合里面

所以我们算出多少个集合

这里算出每个集合多少个元素，然后统计出来

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220903024405.png)



```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        int []parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
        for(int i=0;i<edges.length;i++){
            merge(edges[i][0],edges[i][1],parent);
        }
        long sum=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        HashSet<Integer>set=new HashMap<>();
        for(int i=0;i<n;i++){
            int root=findroot(i,parent);
            set.add(root);
            if(map.get(root)==null)map.put(root,1);
            else map.put(root,map.get(root)+1);
        }
        for(int k:map.keySet()){
            long count=map.get(k);
            sum+=(n-count)*count;
        }

        public void merge(int a,int b,int []parent){
            int k1=findroot(a,parent);
            int k2=findroot(b,parent);
            if(a==b)return;
            parent[k1]=k2;
        }
        //路径压缩
        public int findroot(int a,int []parent){
            if(parent[a]!=a)parent[a]=findroot(parent[a],parent);
            return parent[a];
        }
    }
```



### 5、城市最小分数

找一个联通分量中最小的边就行了

用并查集

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221205003910.png)

```cpp
class Solution {
public:
    int parent[1000010];
    int findroot(int x){
        if(parent[x] != x)parent[x] = findroot(parent[x]);
        return parent[x];
    }
    int minScore(int n, vector<vector<int>>& roads) {
          for(int i = 1 ; i <= n ; i ++){
              parent[i] = i;
          }
          int w = 100000;
          int m = roads.size();
          for(int i = 0 ; i < m ; i ++){
             int a = roads[i][0];
             int b = roads[i][1];
             int c= roads[i][2];
             int root1 = findroot(a);
             int root2 = findroot(b);

             if(root1 == 1)parent[root2]  = 1;
             else parent[root1] = root2; 
          }
          for(int i = 0  ; i < m ; i ++){
               int a = roads[i][0];
             int b = roads[i][1];
             int c= roads[i][2];
             int root1 = findroot(a);
             int root2 = findroot(b);
             if(root1 == 1 || root2 == 1)
             w = min(w,c);
          }
          return w;
    }
};
```





## 十五、模拟

### 1、卡牌

![](C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220730213141.png)

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []s=new int[n+1];
        int total=0;
        for(int i=0;i<m;i++){
            int c=in.nextInt();
            s[c]++;
            if(s[c]==1)total++;
            if(total==n){
                System.out.print(1);
                for(int j=1;j<=n;j++){
                    s[j]--;
                    if(s[j]==0)total--;
                }
            }else {
                System.out.print(0);

            }

        }
    }
}
```





### 2**、矩阵螺旋**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806003247.png)

1、暴力模拟

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        List<List<Integer>>list=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        int m=mat.length;
        int n=mat[0].length;
        int []num=new int[m*n];
        int index=0;
        int flag=1;
        for(int i=0;i<m;i++){
            int k=i;
            int j=0;
            list2=new ArrayList<>();
            while(k>=0&&j<n){
                list2.add(mat[k][j]);
                k--;
                j++;
            }
            if(flag%2==0){
                Collections.reverse(list2);
            }
            flag++;
            list.add(list2);
        }

        for(int j=1;j<n;j++){
            int k=m-1;
            int w=j;
            list2=new ArrayList<>();
            while(k>=0&&w<n){
                list2.add(mat[k][w]);
                k--;
                w++;
            }
            if(flag%2==0){
                Collections.reverse(list2);
            }
            flag++;
            list.add(list2);
        }
        for(int i=0;i<list.size();i++){
            for(int j=0;j<list.get(i).size();j++){
                num[index++]=list.get(i).get(j);
            }
        }
        return num;
    }
}
```



第二种直接模拟，比较技巧

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int n=mat.length;
        int m=mat[0].length;
        int []num=new int[m*n];
        int index=0;
        int k1=0;
        int k2=0;
        //指引方向
        int flag=1;
        while(index<m*n){
            num[index++]= mat[k1][k2];
            if(index==m*n)break;
            if(flag==1){
                //转向
                if(k1-1<0||k2+1>=m){
                    if(k2+1<m)k2=k2+1;
                    else k1=k1+1;
                    flag=0;
                }else{
                    k1=k1-1;
                    k2=k2+1;
                }
            }else{
                if(k1+1>=n||k2-1<0){
                    if(k1+1<n)k1=k1+1;
                    else k2=k2+1;
                    flag=1;
                }else{
                    k1=k1+1;
                    k2=k2-1;
                }
            }
        }
        return num;
    }
}
```





### 3、提莫攻击

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220809181607.png)





```java
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        int n=timeSeries.length;
        int last=0;
        int sum=0;
        for(int i=0;i<n;i++){
            if(timeSeries[i]>=last){
                sum+=duration;
            }else{
                sum+=duration;
                sum-=last-timeSeries[i];
            }
            last=timeSeries[i]+duration;
        }
        return sum;
    }
}
```







### 4、表面积

计算每个点上的正方形的贡献就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819041659.png)

```java
class Solution {
    public int surfaceArea(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int sum=0;
        int []k1={1,-1,0,0};
        int []k2={0,0,1,-1};
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]>0)sum=sum+2;
                for(int w=0;w<4;w++){
                    int x=i+k1[w];
                    int y=j+k2[w];
                    if(x<0||y<0||x>=n||y>=m)sum+=grid[i][j];
                    else if(grid[x][y]<grid[i][j])sum+=grid[i][j]-grid[x][y];
                }
            }
        }
        return sum;
    }
}
```



## 十六、字典树

### 1、最大异或对



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813072448.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813062526.png)

就是相同为0不同唯一，从最高位置开始，往和当前数位置不同的地方走

可以用字典树

```java
import java.util.*;
class Main{
    static int[][]root=new int[3100010][2];
    static int index=0;
    static int  []a;

    static void insert(int x){
        int p=0;
        for(int i=30;i>=0;i--){
            //取出最第i位的数字
            int u=x>>i&1;
            if(root[p][u]==0)root[p][u]=++index;
            p=root[p][u];
        }
    }

    static int query(int x){
        int p=0;
        int res=0;
        for(int i=30;i>=0;i--){
            int u=x>>i&1;
            int w;
            if(u==0)w=1;
            else w=0;
            if(root[p][w]!=0){
                p=root[p][w];
                res=res*2+w;
            }else {
                p=root[p][u];
                res=res*2+u;
            }
        }
        //System.out.println(res);
        return res;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        a=new int[n+1];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        int res=0;
        for(int i=0;i<n;i++){
            insert(a[i]);
            int t=query(a[i]);
            res=Math.max(res,t^a[i]);
        }
        System.out.println(res);
    }
}
```





### **2、字符串前缀和(经典)**

将所有字符串加入前缀树

每一次加入到同一个字符串都有吧总数加一

然后再来一次循环，寻找这个字符串出现了多少次前缀

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220919013831.png)



```cpp
class Solution {
    public:
    int a[(int)4e5][26];
    int index=0;
    int sum[(int)4e5];
    vector<int> sumPrefixScores(vector<string>& words) {
        int n=words.size();
        for(int i=0;i<n;i++){
            insert(words[i]);
        }
        vector<int>v(n);
        for(int i=0;i<n;i++){
            v[i]=query(words[i]);
        }
        return v;
    }

    int  query(string s){
        int count=0;
        int q=0;
        for(int i=0;i<s.size();i++){
            int k=s[i]-'a';
            if(a[q][k]==0)break;
            q=a[q][k];
            count+=sum[q];
        }
        return count;
    }

    void insert(string s){
        int q=0;
        for(int i=0;i<s.size();i++){
            int k=s[i]-'a';
            if(a[q][k]==0)a[q][k]=++index;
            q=a[q][k];
            sum[q]++;
        }
    }
};
```



## 十六、迪杰斯拉

### 1、序列

找出每次最小距离和数组最小距离相比=就可以判断

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731060354.png)

```java
import java.util.*;
public class Main{
    //有权图单源最短路
    static int[][] graph;
    static int dist[];
    static int flag;
    static int index;
    static int []help;
    static HashSet<Integer> set = new HashSet<>();//判断是否被收录

    //初始化
    public static void creat(int []a) {
        for (int i = 0; i <a.length; i++) {
            dist[a[i]] = 100000000;
        }
        dist[a[0]]=0;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        //初始化图
        graph=new int[1010][1010];
        for(int i=0;i<m;i++){
            int k1=in.nextInt();
            int k2=in.nextInt();
            int k3=in.nextInt();
            graph[k1][k2]=graph[k2][k1]=k3;
        }
        int count=in.nextInt();
        int []a=new int[n];
        for(int i=0;i<count;i++){
            help=new int[1010];
            dist=new int[1010];
            set=new HashSet<>();
            for(int j=0;j<n;j++){
                a[j]=in.nextInt();
            }
            index=0;
            creat(a);
            Dijkstra(a);
        }
    }

    //具体算法
    public static void Dijkstra(int []a) {
        while (true) {
            int v = -1;
            long min = 1000000000;
            //对于没有被收录进去的结点，找出dist最小的
            for (int i = 1; i <=a.length; i++) {
                if (set.contains(i) == false) {
                    if (dist[i] < min) {
                        min = dist[i];
                        v = i;
                    }
                }
            }
            //已经全部收录了
            if (min == 1000000000) break;
            if(dist[v]<dist[a[index++]]){
                System.out.println("No");
                return;
            }
            help[v]=dist[v];
            set.add(v);
            for (int i = 1; i <=a.length; i++) {
                if (graph[v][i] > 0 && set.contains(i) == false) {
                    if (dist[v] + graph[v][i] < dist[i]) {
                        dist[i] = dist[v] + graph[v][i];
                    }
                }
            }
        }
        System.out.println("Yes");

    }

}
```







## 十七、图论

### **1、最长环**(难)

思路：

首先我们遍历，遇到一个被访问过的点，如果他是这次访问过得，就用总距离减去这个点的深度

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802002156.png)

```java
class Solution {
   int []vist;
   int []length;
   int max;
   public int longestCycle(int[] edges) {
      int n=edges.length;
      length=new int[n];
      vist=new int[n];
      max=-1;
      for(int i=0;i<n;i++){
         if(vist[i]==0){
            dfs(edges,i,1);
         }
      }
      return max;
   }
   public void dfs(int []edges,int i,int sum){
      if(i==-1)return;
      if(vist[i]==0){
         vist[i]=1;
         length[i]=sum;
         dfs(edges,edges[i],sum+1);
         length[i]=0;
      }else {
         if(length[i]>0){
            max=Math.max(max,sum-length[i]);
         }
      }
   }
}
```



### 2、负环

算法分析
使用spfa算法解决是否存在负环问题

求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：

方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环
**方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环**

所以要把每个点初始化都入队列

y总的原话
每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：
在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。

1、dist[x] 记录虚拟源点到x的最短距离

2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] >= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用

3、若dist[j] > dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步

注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220823165402.png)



```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];   //值
    public  static  int[]next=new int[200000];    //下一个指针
    public  static  int[]weight=new int[200000];   //权重
    public  static  int index=0;
    static  int n;
    public static int []cnt;
    static int max=1000000000;

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }



    public  static  boolean  spfa(){
        //全部点加入队列
        Queue<Integer>queue=new LinkedList<>();
        for(int i=1;i<=n;i++){
            visit[i]=1;
            queue.add(i);
        }
        while(queue.size()>0){
            int k=queue.poll();
            // System.out.println(k);
            visit[k]=0;
            for(int i=graph[k];i!=-1;i=next[i]){
                int j=value[i];
                if(dist[k]+weight[i]<dist[j]){
                    dist[j]=weight[i]+dist[k];
                    cnt[j]=cnt[k]+1;
                    if(cnt[j]>n)return true;
                    if(visit[j]==0){
                        visit[j]=1;
                        queue.add(j);
                    }
                }
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        cnt=new int[n+1];
        for(int i=1;i<=n;i++)graph[i]=-1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        boolean s=spfa();
        if(s==true) System.out.println("Yes");
        else System.out.println("No");
    }
}
```





### **3、二分图(难)**

意思就是分成两组  每组内的成员不能有边链接

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014610.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014422.png)

![]()

```java
class Solution {
    int []g=new int[100010];
    int[]next=new int[200020];
    int[]value=new int[200010];
    int[]color=new int[100010];
    int index=0;
    void insert(int a,int b){
        value[index]=b;
        next[index]=g[a];
        g[a]=index++;
    }
    public boolean dfs(int u,int c){
        color[u]=c;
        for(int i=g[u];i!=-1;i=next[i]){
            int j=value[i];
            if(color[j]==0){
                if(dfs(j,3-c)==false)return false;
            }
            else {
                if(color[j]==c)return false;
            }
        }
        return true;
    }
    public boolean possibleBipartition(int n, int[][] dislikes) {
        for(int i=1;i<=n;i++)g[i]=-1;
        for(int i = 0;i<dislikes.length;i++){
            insert(dislikes[i][0],dislikes[i][1]);
            insert(dislikes[i][1],dislikes[i][0]);
        }
        boolean flag=true;
        for(int i=1;i<=n;i++){
            if(color[i]==0){
                if(dfs(i,1)==false){
                    flag=false;
                    break;
                }
            }
        }
        return flag;
    }
}
```



### 4、添加边让结点成为偶数



思路：

最多添加两个结点，每一次造成的影响有：

两个奇数  奇数结点 - 2

链接两个偶数  奇数结点+2

链接一奇数一偶数   奇数结点不变



所以添加两条边最多减少4个奇数结点

所以先预处理  大于4直接返回false

不可能有奇数个结点

所以剩下  0 2 4

如果为0 直接返回true

为2

有两种情况  ：

1-将两个奇数结点相连

2-两个奇数结点共同连一个结点

如果为4：

只能是两个奇数结点两两匹配

全排列，这里用了一个函数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221218134629.png)

```cpp
class Solution {
public:
    //哈希值
    long long   hs(int a,int b){
        if(a > b)swap(a,b);
        return  (long long )((long long) a * 1000000 + b);
    }


    bool isPossible(int n, vector<vector<int>>& edges) {
        set<long long >s;
        vector<int>d(n + 1,0);
        for(auto & k : edges){
            int a = k[0],b = k[1];
            d[a] ++;
            d[b] ++;
            s.insert(hs(a,b));
        }


        vector<int>v;
        for(int i = 1 ; i <= n ; i ++){
           if(d[i] % 2 == 1){
               v.push_back(i);
           }
        }
    
        if(v.size() == 0)return true;
        if(v.size() > 4)return false;
        if(v.size() == 2){
           int a = v[0];
           int b = v[1];
           if(s.count(hs(a,b)) == 0)return true;
           for(int i = 1 ;i <= n ; i ++){
               if(i !=a && i != b && s.count(hs(i,a)) == 0 && s.count(hs(i,b)) == 0)return true;
           }
           return false;
        }else if(v.size() == 4) {
            for(int i = 0 ;i <24 ; i ++){
                int a = v[0],b = v[1],c = v[2],d = v[3];
                if(s.count(hs(a,b)) == 0 && s.count(hs(c,d)) == 0)return true;
                //下一个排列
                next_permutation(v.begin(),v.end());
            }

        }
        return false;
    }
};
```





## 十八、数学

### **1、拼长方体**

首先n是奇数直接排除  因为2*两边之和等于周长   所以n%4==1   n%4==3直接输出0

如果N是4的倍数  那么先组成一个正方形，然后让两条边分别减一，另外两条边加一  总共有n/4-1总方法

否则n%4==2

分成四份，两条边长，两条短，短的长度是n/4,  短的可以从1到四分之n变化， 所以总的方案是n/4

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807051707.png)

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        while(in.hasNext()){
            int n=in.nextInt();
            if(n%4==0)System.out.println(n/4-1);
            else{
                if(n%4==1||n%4==3)System.out.println(0);
                else
                    System.out.println(n/4);
            }
        }
    }
}
```







### 5、使数组能被p整除

>我们求一遍总和x，如果x被p整除，那么返回0
>否则我们要找到下标i和j  i 到 j之前的和为 s =   f(i + 1) - f(j)
>s能够整除x的最小长度
>
>+ s % p == x
>
>(y - z) % p = x可以分解：
>y - z = k * p + x  ->  z = y- k * p - x
>z = y - x - k * p
>把 y - x 分解成 (y - x)%p + k1 * p
>所以有z = (y - x)%p  + k1 * p - k * p
>所以z = (y - x)%p + (k1 - k)*p
>z % p = (y - x)%p
>所以我们从前往后遍历，如果前n个元素和y减去x可以正常p  那么找出z的下标  ，用当前下标减去z的下标加一就是数组长度
>最后取最小值
>
>第二种
>(x - s) % p = 0  s是前缀和,x是总和
>有x = k* p + s
>x % p = s % p 
>所以我们有x % p = f(j) % p  - f(i) % p 
>(f(j) - x)%p = f(i) % p
>((f(j) - x )%p+ p)%p = f(i) % p
>

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230310131359.png)

```cpp
class Solution {
public:
    int minSubarray(vector<int>& nums, int p) {
      int n  = nums.size();
      vector<int>a(n + 1,0);
      map<int,int>m;
      int sum = 0;
      for(auto k : nums){
          sum = (k + sum)%p;
      }
      int res = n;
      if(sum == 0)return 0;
      int s = 0;
      for(int i =  0 ; i < n ; i ++){
          m[s] = i;
        s = (s + nums[i]) % p;
        if(m.count((s - sum + p) % p )> 0){
            res = min(res,i - m[(s - sum + p) % p] + 1);
        } 
      }
      if(res == n)return -1;
      return res; 
    }
};
```





### 2、最大公约数

找出一堆数的最大公约数  分别求相邻两个数的最大公约数然后取最小

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221028014132.png)

```cpp
class Solution {
public:
    int count(int a,int b){
        int m = min(a,b);
        for(int i = m ; i >= 0 ; i --){
            if(a % i ==0 && b % i == 0)return i;
        }
        return 1;
    }
    int subarrayGCD(vector<int>& nums, int k) {
        int n = nums.size();
        int sum = 0;
        for(int i = 0 ;i< n ; i++){
            int mx = nums[i];
            for(int j = i;j < n ; j++){
                if(nums[i] % k !=0)break;
                mx = min(mx,count(mx,nums[j]));
                if(mx == k)sum ++;
            }
        }
        return sum;
    }
};
```



### 3、美丽数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030133436.png)

```cpp
class Solution {
public:
    long long makeIntegerBeautiful(long long n, int target) {
        long long sum = n;
        long long index = 1;
        while(get(sum) > target){
           long long c = sum/index%10;
           if(c == 0){
               index = index*10;
               continue;
           }
           c = c*index;
           sum = sum +10*index-c;
           index = index*10;
        }
        return sum - n;
    }
    int get(long long  n){
        int sum = 0 ;
        while(n>0){
            sum += n%10;
            n = n / 10;
        }
        return sum;
    }
};
```





### 4、孤独的照片

思路
>我们可以用四个数组表示当前位置，上一个h,上一个g  已经下一个h和g
>然后用乘法原理就行了

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127125734.png" style="zoom:67%;" />

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
long long sum = 0;

void count(int a,int b,int i){
        if(b - a < 4)return;
       // cout<<b<<" "<<a<<" "<<i<<endl;
        sum += (long long)(b - i - 1)*(i - a - 1);
        if(i - a >= 3)sum += (i - a - 2);
        if(b - i >= 3)sum += (b - i - 2);
}
int main(){
    int n;
    cin>>n;
    string s;
    cin>>s;
    n = s.size();
    
    int a1[n] = {-1};
    int a2[n] = {-1};
    int b1[n] = {n};
    int b2[n] = {n};
    int  flag1 = -1;
    int  flag2 = -1;
    
    for(int i = 0 ; i< n ; i ++){
        a1[i] = flag1;
        if(s[i] == 'G')flag1 = i;
        a2[i] = flag2;
        if(s[i] == 'H')flag2 = i;
    }
    
    flag1 = flag2 = n;
    sum = 0;
    for(int i = n - 1 ; i >= 0 ; i --){
        b1[i] = flag1;
        if(s[i] == 'G')flag1 = i;
        b2[i] = flag2;
        if(s[i] == 'H')flag2 = i;
    }
    
    for(int i = 0 ; i < n ; i ++){
        int a = a1[i],c = a2[i],b = b1[i],d = b2[i];
        if(s[i] == 'G')
        count(a,b,i);
        else 
        count(c,d,i);
    }
    
    cout<<sum<<endl;
    
}
```





## 十九、字符串

### 1、字符串和2的幂次方

找出长度一样的2的幂次方，一个个比较

![](C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220817173853.png)

```java
class Solution {
    public boolean reorderedPowerOf2(int n) {
        int sum=1;
        List<String> list=new ArrayList<>();
        while((sum+"").length()<=(n+"").length()){
            if((sum+"").length()==(n+"").length())list.add(sum+"");
            sum=sum*2;
        }
        char[]a;
        char[]b;
        for(int i=0;i<list.size();i++){
            String str=list.get(i);
            if((str).length()!=(n+"").length())return false;
            a=(str).toCharArray();
            b=(n+"").toCharArray();
            Arrays.sort(a);
            Arrays.sort(b);
            if(new String(a).equals(new String(b)))return true;
        }
        return false;
    }
}
```



### 2、最长回文

先找出首字母，如果首字母为空，那么就找出最大的数字，返回

不是空串，那就一个个加

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220822011520.png)

```java
class Solution {
    public String largestPalindromic(String num) {
        int []a=new int[10];
        int max=0;
        String s="";
        for(int i=0;i<num.length();i++){
            a[num.charAt(i)-'0']++;
        }
        for(int i=9;i>0;i--){
            if(a[i]>=2){
                a[i]-=2;
                s=i+"";
                break;
            }
        }
        if(s.equals("")){
            for(int i=9;i>=0;i--){
                if(a[i]>0)return i+"";
            }
        }  
        else {
            for (int j = 9; j >= 0; j--) {
                while (a[j] >= 2) {
                    a[j] -= 2;
                    s += j;
                }
            }
        }
        
        StringBuffer stringBuffer=new StringBuffer(s);
        String s2=stringBuffer.reverse().toString();
        for(int i=9;i>=0;i--){
            if(a[i]==1){
                s+=i;
                break;
            }
        }
        return s+s2;
    }
}
```





### 3、两个字符串接近

思路很简单：

先判断长度

然后计算两个字符串各自出现的次数，并且一个字符串是否都出现过

第一个操作可以忽略不计

第二个操作只要将次数从小到大排序就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220828181815.png)



```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        if(word1.length()!=word2.length())return false;
        int []num1=new int[26];
        int []num2=new int[26];
        int sum1=0;
        int sum2=0;
        for(int i=0;i<word2.length();i++){
            int a=word1.charAt(i)-'a';
            int b=word2.charAt(i)-'a';
            num1[a]++;
            num2[b]++;
        }
        for(int i=0;i<26;i++){
            if(num1[i]==0&&num2[i]!=0||num1[i]!=0&&num2[i]==0)return false;
        }
        if(sum1!=sum2)return false;
        Arrays.sort(num2);
        Arrays.sort(num1);
        for(int i=1;i<26;i++){
            if(num1[i]!=num2[i])return false;
        }
        return true;
    }
}
```





### **4、匹配字符串(傻逼题)**



思路：

每次遍历数组中字符串，然后匹配，如果相同下标加一，如果大写字母，直接false

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908024221.png)

```cpp
class Solution {
    public:
    vector<bool> camelMatch(vector<string>& queries, string pattern) {
        vector<bool>v;
        int n=queries.size();
        int index=0;
        for(int i=0;i<n;i++){
            index=0;
            string s=queries[i];
            int flag=0;
            for(char c:s){
                if(index<pattern.size()&&pattern[index]==c)index++;
                else if(c>='A'&&c<='Z'){
                    flag=1;
                    break;
                }
            }
            v.push_back(flag==0&&index==pattern.size());
        }
        return v;
    }
};
```



### 5、删除子文件夹

思路这里先排序

如果用Last表示主文件夹

遍历整个数组

如果数组中的元素不包含last  或者last长度的位置不是   "/"  符合条件  更新Last 

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221003134200.png)

```cPP
class Solution {
    public:
    vector<string> removeSubfolders(vector<string>& folder) {
        int n = folder.size();
        sort(folder.begin(),folder.end());
        vector<string>v;
        string last="/";
        string s="abc";

        for(auto &s:folder){
            if(s.find(last)!=0||s[last.size()]!='/'){
                v.push_back(s);
                last=s;
            }
        }
        return v;
    }
};
```





### **6、可以形成最多字符串(贪心)**

形成最多字符串无疑就是把首字母放或者把第二个字母放最后

我们设立两个变量分别统计两个字母

并且统计中间过程可以形成多少个匹配的单词

最后加上两个字符数量大的值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221011154652.png)

```cpp
class Solution {
    public:
    long long maximumSubsequenceCount(string text, string pattern) {
        int n = text.size();
        long long sum = 0;
        int sum1 = 0;
        int sum2 = 0;
        for(int i = 0 ; i < n ;i ++){
            if(text[i] == pattern[1]){
                sum += sum1;
                sum2 ++;
            }
            if(text[i] == pattern[0]) sum1 ++;
        }
        if(sum1>sum2)sum += sum1;
        else sum += sum2;
        return  sum;
    }
};
```

## 二十、异或

### 1、查询每个异或值

思路：

先算出全部异或， 由于a^b^b=a;

所以我们算出了总异或后    前i个数的异或和等于  i个数的异或和再异或低i个数

由于k小于2max次方，所以k最大只能取到2max次方减一

我们求出这个k    也就k^前i个异或和=2max-1

**这时候k等于2max-1^前i个异或和**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220826213400.png)

```java
class Solution {
    public int[] getMaximumXor(int[] nums, int maximumBit) {
        //可以达到的最大值
        int  flag=(int)Math.pow(2,maximumBit)-1;
        int sum=0;
        //求出异或
        for(int i=0;i<nums.length;i++){
            sum^=nums[i];
        }
        int []a=new int[nums.length];
        a[0]=sum^flag;
        int index=1;
        for(int i=nums.length-1;i>0;i--){
            sum=sum^nums[i];//得到去掉末尾位置数字的异或和
            a[index++]=sum^flag;
        }
        return a;
    }
}
```





### **2、两个异或相等的三元组(难)**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827175730.png)

方法一：三重

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827180024.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827180035.png)

```java
class Solution {
    public int countTriplets(int[] arr) {
        int n = arr.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                for (int k = j; k < n; ++k) {
                    if (s[i] == s[k + 1]) {
                        ++ans;
                    }
                }
            }
        }
        return ans;
    }
}
```



优化二重：

当si==sk+1时候

i+1到k也是符合的

所以有k-i个

```java

class Solution {
    public int countTriplets(int[] arr) {
        int n = arr.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int k = i + 1; k < n; ++k) {
                if (s[i] == s[k + 1]) {
                    ans += k - i;
                }
            }
        }
        return ans;
    }
}
```



**转换法：**

我们要求a[i]^...a[i-1]==a[j]^...a[k]

也就是a[i]^....a[k]==0

中间求多少个j

```java
/**
 * a ^ b = a[i]^...^a[k] = 0, 题目转化为求子串的异或结果等于0
 */
public static int countTriplets(int[] arr) {
    int res = 0;

    for (int i = 0; i < arr.length; i++) {
        int t = arr[i];
        for (int k = i + 1; k < arr.length; k++) {
            t ^= arr[k];
            if (t == 0) {
                // j 无所谓呐，i~k任意一个数都行
                res += k - i;
            }
        }
    }
    return res;
}
```





### 3、&运算

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831023931.png)

```c++
class Solution {
    public:
    bool isPowerOfTwo(int n) {
        return n>0&&(n&(-n))==n;
    }
};
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831023621.png)





### 4、二进制&

比较最右边是不是相等的

&1就行了，如果相等就表示右边一位相等

然后右移一位

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220905171632.png)



```c++
class Solution {
   public:
   int minBitFlips(int start, int goal) {
      int sum=0;
      while(start>0||goal>0){
         if((start&1)!=(goal&1))sum++;
         start=start>>1;
         goal=goal>>1;
      }
      return sum;
   }
};
```



### 5、按位或 |

意思：

因为| 运算是并集，也就是我们要找到1最多的子数组

我们可以用一个辅助数组记录第j位是1的元素的下标

然后贪心

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220918030701.png)



```cpp
class Solution {
    public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int>a(n);
        vector<int>help(32);
        int mx=0;
        for(int i = n-1;i>=0;i--){
            mx = mx|nums[i];
            for(int j = 0;j<32;j++){
                if(nums[i]>>j&1)help[j]=i;
            }
            int t=1;
            for(int j=0;j<32;j++){
                if(((mx>>j)&1)==1){
                    t=max(t,help[j]-i+1);
                }
            }
            a[i]=t;
        }
        return a;
    }
};
```









### 6、数组中最大异或值  



思路：

^相同为0   不同为1

我们有a^b = c   ->   a^c = b  -> b^c = a

我们找到max   只要遍历max ^ 数组中的元素   =  b  且b在数组中   那么就存在a^b = max

由于贪心法则  我们从最高位开始  验证当前位能否取1  依次类推

我们假设 第一次遍历 

 可以取1  那么我们把数组的最高位存入set  然后用这个数去和数组每一个数^  如果结果在set中  表示当前数可以取1

否则取0

第二次遍历我们假设当前为1    当前已经有两位了  分别是_1

_是上一次得出的结果

我们可以把上一次结果*2+1  就是当前位置的值变成1

如果最后不满足  就是把当前结果-1



比如11  ->111   就是3*2+1；

11 ->110   3*2

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230105020337.png)

```cpp
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        int x = 0;
        for(int i = 30; i >= 0 ; i --){
            unordered_set<int>s;
            for(auto k : nums){
                s.insert(k>>i);
            }
            int id = x*2 + 1;
            int flag = 0;
            for(auto k : nums){
                if(s.count(id^(k>>i)) !=0){
                   flag = 1;
                   break;
                }
            }
            if(flag == 0)x = id -1;
            else x = id;
        }
        return x;
    }
};
```





## 二十一、拓扑排序

### 1、构造矩阵

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220828141527.png)

```java
class Solution {
    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {
        int [][]g=new int[k][k];
        int []num1=new int[k+1];
        int []num2=new int[k+1];
        int sum1=topu(rowConditions,k,num1);
        int sum2=topu(colConditions,k,num2);
        if(sum1!=k)return new int[0][0];
        if(sum2!=k)return new int[0][0];

        for(int i=1;i<=k;i++){
            g[num1[i]][num2[i]]=i;
        }
        return g;
    }
    public  int  topu(int [][]num,int k,int []nums){

        int [][]g=new int[k+1][k+1];
        int []degree=new int[k+1];
        for(int []w:num){
            int a=w[0];
            int b=w[1];
            if(g[a][b]==1)continue;
            g[a][b]=1;
            degree[b]++;
        }

        Queue<Integer>queue=new LinkedList<>();
        for(int i=1;i<=k;i++){
            if(degree[i]==0)queue.add(i);
        }
        int sum=0;
        int index=0;
        while (queue.size()>0) {
            int w = queue.poll();
            sum++;
            nums[w] = index;
            for (int i = 1; i <= k; i++) {
                if (g[w][i] == 1) {
                    degree[i]--;
                    if (degree[i] == 0) queue.add(i);
                }
            }
            index++;
        }
        return sum;
    }
}
```







## 二十二、堆

### 1、区间划分

我们用小根堆来记录区间的第二个数，先对数组进行排序，第一个数从小到大，然后依次加入堆

如果堆中元素为0直接插入

如果堆顶元素大于当前数组第一个元素，那么直接入堆，不能合并

如果堆顶元素小于当前数组第一个元素

那么弹出堆顶，然后插入当前数组第二个元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911134605.png)

```cpp
class Solution {
    public:
    int minGroups(vector<vector<int>>& intervals) {
        int n=intervals.size();
        sort(intervals.begin(),intervals.end());
        //定义小顶堆
        priority_queue<int,vector<int>,greater<int>>heap;
        for(auto &k:intervals){
            if(heap.size()==0)heap.push(k[1]);
            else if(heap.top()>=k[0]){
                heap.push(k[1]);
            }else {
                heap.pop();
                heap.push(k[1]);
            }
        }
        return heap.size();
    }
};
```



### 2、将数组减半

用大根堆维护最大的数

每次减半

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009000148.png)



```cpp
class Solution {
    public:
    int halveArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        priority_queue<double>heap;//最大堆
        double sum=0.0;
        int count=0.0;
        for(int k:nums){
            sum+=k;
            heap.push(k);
        }
        double flag=sum/2;
        while(sum>flag){
            double k=heap.top();
            heap.pop();
            sum-=k/2;
            heap.push(k*1.0/2);
            count++;
        }
        return count;
    }
};
```





### 3、雇佣k个工人最少花费

思路 :

当2*candidates>数组的长度  放入堆中找最小值

反之

用两个堆维护两端

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221107024335.png)

```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();
        priority_queue<int,vector<int>,greater<int>>heap1;
        priority_queue<int,vector<int>,greater<int>>heap2;
        long long  sum = 0 ;
        if(candidates *2 > n){
           for(int i = 0 ;i < n ; i ++)heap1.push(costs[i]);
           for(int i = 0 ;i < k ; i++){
               sum += heap1.top();
               heap1.pop();
           }
        }else {
            int l;
            int r;
           for(l = 0 ;l < candidates ; l ++)heap1.push(costs[l]);
           for(r = n -1 ; r >= n - candidates ; r --)heap2.push(costs[r]);
           for(int i = 0 ;i < k ; i ++){
            //cout<<heap1.top()<<" "<<heap2.top()<<endl;
              if(heap1.size() == 0){
                  sum += heap2.top();
                  heap2.pop();
              }else if(heap2.size() == 0){
                  sum += heap1.top();
                  heap1.pop();
              }else {
                if(heap1.top() <= heap2.top()){
                      sum += heap1.top();
                      heap1.pop();
                      if(l <= r){
                          heap1.push(costs[l]);
                          l ++;
                      }
                  }else if(heap1.top() > heap2.top()) {
                      sum +=heap2.top();
                      heap2.pop();
                      if(l<= r){
                          heap2.push(costs[r]);
                          r --;
                      }
                  }
               }
           }
        }
      return sum;
    }
};
        
                
```





### 4、最大子序列分数 

思路

> 我们将数组二的值从大到小排序，还要记录对应的坐标
> 然后我们每次遍历数组二，当前i就是前面i个数的最小值
> 我们只要在数组一选k - 1个数，加上 下标为i这个数  用堆来维护就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230122125701.png)

```cpp
         int n = nums1.size();
         vector<pair<long long ,long long>>v(n);
         for(int i = 0 ; i < n ;i  ++){
             pair<int,int>p;
             p.first =(long long) nums2[i];
             p.second = (long long )i;
             v[i] = p;
         }
        sort(v.begin(),v.end(),[&](pair<long long ,long long>p1,pair<long long ,long long>p2){
            return p1.first > p2.first;
        });
        
        long long sum = 0;
        long long mx = 0;
         priority_queue<long long,vector<long long>,greater<long long>>heap;
      
        for(int i = 0 ; i < n ; i ++){
            if(heap.size() == k){
                sum -= heap.top();
                heap.pop();
            }
            heap.push(nums1[v[i].second]);
            sum += nums1[v[i].second];
            if(heap.size() == k){
                mx = max(mx,(long long)sum * v[i].first);
            }
        }
        return mx;
```





## 二十三、前缀和

### 1、子数组绝对值最大值

算出前缀和

然后求出前缀和最大和最小的

将这两个的绝对值和他们两个差的绝对值取最大

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220912192531.png)

```cpp
class Solution {
    public:
    int maxAbsoluteSum(vector<int>& nums) {
        int n=nums.size();
        int mx=nums[0];
        int mn=nums[0];
        for(int i=1;i<n;i++){
            nums[i]=nums[i-1]+nums[i];
            mx=max(nums[i],mx);
            mn=min(nums[i],mn);
        }
        return max(abs(mx-mn),max(abs(mx),abs(mn)));
    }
};
```





### 2、美丽数

直接前缀和 



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221212024854.png)

```cpp
class Solution {
public:
    int beautySum(string s) {
      int n = s.size();  
      int a[n + 1][26];
      memset(a,0,sizeof a);
      for(int i = 1 ; i <= n ; i ++){
        
          a[i][s[i - 1] - 'a'] ++;
          for(int j = 0 ; j < 26 ; j ++){
              a[i][j] += a[i - 1][j];
          }
      }
     
      int sum = 0;
      for(int i = 1 ; i <= n ; i ++){
          for(int j = i ; j <= n; j ++){
               int mn = 100000000000;
               int mx = -10000000000;
              for(int k = 0 ;k < 26 ; k ++){
                  mx = max(a[j][k] - a[i - 1][k],mx);
                  if(a[j][k] - a[i - 1][k] != 0)
                  mn = min(a[j][k] - a[i - 1][k],mn);
              }
           
              sum += mx - mn;
          }
      }
      return sum;
    }
};
```





## 二十四、滑动窗口

### 1、每种字符取k个

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221227031955.png)

```cpp
class Solution {
public:
    int takeCharacters(string s, int k) {
        int num[3] = {0};
        int n = s.size();
        for(int i = 0 ; i < n ; i ++){
            num[s[i] - 'a'] ++;
        }
        for(int i = 0 ; i < 3 ; i ++){
            if(num[i] < k)return -1;
        }
        int l =0,r = 0;
        int mx = 0;
        for(;r < n ;  r ++){
            num[s[r] - 'a'] --;
            while(l < r && (num[0]< k || num[1] < k || num[2] < k)){
                num[s[l] - 'a'] ++;
                l ++;
            }
            if(num[0] >= k && num[1] >= k && num[2] >= k){
               mx = max(mx,r - l + 1);
            }
        }
        return n - mx;
    }
};
```







### 2、好子数组数目

思路

>我们可以用map记录每个数字出现的次数，然后从前往后遍历 
>设左端点为l,右端点为r
>然后我们一直向右扩张，直到数对数目等于k
>我们怎么计算数对数目呢，如果l向有移动，那么减少map[l]  - 1个数对，r向右移动，就会加map[r] 个数对
>所以，我们找到r后，r后面的所有下标都是符合的，那么只要移动l就行了 

题目

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230116231151.png)

```cpp
class Solution {
public:
    long long countGood(vector<int>& nums, int k) {
        int n = nums.size();
        int l = -1;
        int r = 0;
        unordered_map<int,int>m;
        long long sum = 0;
        long long c = 0;
        while(l < n){
            if(l != -1){ 
               m[nums[l]] --;
               c -= m[nums[l]];
            }
            l ++;
            while(r < n){
               if(c >= k)break;
               c += m[nums[r]];
               m[nums[r]] ++;
               r ++;
            }
            if(c >= k)
            sum += (n - r + 1);
        }
        return sum;
    }
};
```





### 3、平衡字符串

>思路
>我们每次维护一个窗口，使得其他地方的 q w e r数量都小于n /4 然后更新这个窗口就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230213100742.png)

```cpp
class Solution {
public:
    int c;
    bool judge(int num[26]){
        if(num['Q' -'A'] > c ||num['W' - 'A'] > c || num['E' - 'A'] > c || num['R' - 'A'] > c)return false;
        return true;
    }
    int balancedString(string s) {
       int n = s.size();
       c = n/4;
       int num[26] = {0};
       for(auto k : s){
           num[k - 'A'] ++;
       }
       int l = 0,r = 0;
       int res =  n;
       for(;l<n;l++){
          while(r < n && !judge(num)){
              num[s[r] - 'A'] --;
              r ++;
          }
          if(!judge(num))break;
          res = min(res,r - l);
          num[s[l] - 'A'] ++;
       }
       return res;
    }
};
```









### 4、子字符串排列

>思路
>因为是排列，所以我们只要在s2一段区域找到字符串种类和数目等于s1就行了，可以用滑动窗口

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230223224249.png)

```cpp
class Solution {
public:
    bool checkInclusion(string s1, string s2) {
       int n = s1.size();
       int m = s2.size();
       if(n > m)return false;
       vector<int>v1(26,0);
       vector<int>v2(26,0);
       for(int i = 0 ; i < n ;i  ++){
           v1[s1[i] - 'a'] ++;
           v2[s2[i] - 'a'] ++;
       }
       if(v1 == v2)return true;
       for(int i = n, j = 0 ; i < m ; i ++,j ++){
            v2[s2[i] - 'a'] ++;
            v2[s2[j] - 'a'] --;
            if(v1 == v2)return true;
       }
       return false;
    }
};
```





## 二十四、树状数组  



### 1、找出牛的身高

> 描述：
> 给一组数据，表示第i头牛前面有多少头比他矮的牛，牛的的身高是1 - n  最后输出所有牛的身高

解：

+ 从后往前找，找出没有出现过的第w[i]小的数，然后加一就是当前牛的身高
+  用一个数组a  表示数字i 还可以用几次
+ 用树状数组维护前缀和
+ 在剩余的数中找到第k小的数就是找到一个最小的x满足sum(x) = k,用二分求



代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 100100;
int a[N];
int tre[N];
int n;
int ans[N];
int lowbit(int x)  // 返回末尾的1
{
    return x & -x;
}

int sum(int x){
    int res = 0;
    for(int i = x; i;i -= lowbit(i)){
        res += tre[i];
    }
    return res;
}

void add(int x,int c){
    for(int i = x  ;i <= n ; i += lowbit(i)){
        tre[i] += c;
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 2 ; i <= n ; i ++){
        scanf("%d",&a[i]);
    }
    
    //构建树状数组
    for(int i = 1 ; i<= n ;i ++){
        add(i,1);
    }
    
    for(int i = n  ; i >= 1 ; i --){
        int l = 1;
        int r = n;
        //当前排名是第k小
        int k = a[i] + 1;
        while(l < r){
            int mid = (l + r)/2;
            int value = sum(mid);
            if(value >= k)r = mid;
            else l = mid + 1;
        }
        ans[i] = r;
        add(r,-1);
    }
    
    for(int i = 1 ; i <= n;  i ++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```







### 2、公平数对的数量

>思路：
>这里用树状数组，先预处理，遍历一个数找出他的搭档最小为多少，最大为多少，然后用map离散化
>然后进行一次遍历，每一次找出符合条件范围的数，然后把当前数离散化的值加入树状数组中



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230212123719.png)

```cpp
class Solution {
public:
    int n;
    int index;
    int tre[300010];
    //找到最右边的1
int lowbit(int x){
    return x & -x;
}
map<int,int>m;
//求和
long long count(int x){
    long long sum = 0;
    for(int i = x; i ; i = i -lowbit(i)){
        sum += tre[i];
    }
    return sum;
}

//改变某个数
void add(int x,int k){
    for(int i = x ; i <= 3*n; i = i + lowbit(i)){
        tre[i] +=k;
    }
}
    
int ls(int a){
    return m[a];
}
   
long long countFairPairs(vector<int>& nums, int lower, int upper) {
        n = nums.size();
        index = 1;
        long long sum  = 0;
        vector<int>v;
        for(int i = 0; i < n ; i ++){
            int a = lower - nums[i];
            int b = upper - nums[i];
             v.push_back(a);
             v.push_back(b);
             v.push_back(nums[i]);
        }
        sort(v.begin(),v.end());
        for(int i = 0 ;i  < v.size() ; i ++){
            m[v[i]] = index ++;
        }
        for(int i = 0 ; i < n ;i  ++){
            int a = ls(lower - nums[i]);
            int b  = ls(upper - nums[i]);
            int c = count(a - 1);
            int d = count(b);
            sum += d - c;
            add(ls(nums[i]),1);
        }
        return sum;
    }
};
```







## 二十五、思维题

### 1、执行位运算使得字符相等 

思路
>1 | 1 =  1   1 | 0 = 1   1 & 1 = 0  1 & 0 = 1
>
>我们可以发现，只要有一个1，我们就可以把另一个位置变成任何数，但是最终会剩下一个一
>所以当s 有1时候 target必须有1  否则两个都要全部是0

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230124000759.png)

```cpp
class Solution {
public:
    bool makeStringsEqual(string s, string target) {
        int sum1 = 0;
        int sum2 = 0;
        int n = s.size();
        if(s == target)return true;
        for(int i = 0 ; i < n ; i ++){
            if(s[i] == '1')sum1 ++;
             if(target[i] == '1')sum2 ++;
        }
        if(sum1 != 0 && sum2 != 0)return true;
        return false;
    }
};
```





### 2、把珠子放入背包

>思路
>我们把原数组分成k哥序列，然后计算他们左右两端的值
>首先上一个序列的尾和下一个序列的头肯定是在一起的
>并且第一个元素和最后一个元素肯定是要出现的，最大分数和最小分数都包括这两个元素，所以可以忽略不计
>我们把 w(i)和w(i + 1)加入集合，然后排序，取出k - 1个就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230129123105.png)

```cpp
class Solution {
public:
    long long putMarbles(vector<int>& weights, int k) {
        int n = weights.size();
        vector<int>v;
        for(int i = 0 ; i <  n - 1 ; i ++){
            v.push_back(weights[i] + weights[i + 1]);
        }
        sort(v.begin(),v.end());
        long long sum = 0;
        for(int i =0  ;i  <  k -1 ; i  ++){
            sum -= v[i];
        }
        sort(v.rbegin(),v.rend());
        for(int i = 0 ; i < k - 1 ; i ++){
            sum += v[i];
        }
        return sum;
    }
};
```







### 3、选数异或(蓝桥杯)

>思路
>a ^ b = x   等价宇 a = x ^ b
>所以我们要找出 l 到  r中   a = x ^ b  是否存在
>我们令  f(i) 为   A(j) ^ x  =  A(i) 的最大下标  
>那么只要找到 l <= i < =r  且  f(i) >= l 就有解
>同时 f(i) < i 所以i < r  f(i)肯定小于r
>所以题目变成 1 到  r中找到一个i  使得f(i) >= l
>我们维护 1 到  r中  f(i)的最大值，用g(x)表示，g(x)表示  1 到  x中  f(i)最大值  g(i) = max(g(i - 1),f(i))
>最后判断g(i)是不是大于等于l就行了

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230131011730.png" alt="微信截图_20230131011730" style="zoom:67%;" />

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>

using namespace std;

int main(){
    int n,m,x;
    cin>>n>>m>>x;
    vector<int>v(n + 1);
    unordered_map<int,int>pre;
    vector<int>dp(n + 1,0);
    for(int i = 1 ; i <= n ; i ++){
        scanf("%d",&v[i]);
        dp[i] = max(dp[i - 1],pre[v[i] ^ x]);
        pre[v[i]] = i;
    }
    int l,r;
    while(m --){
        scanf("%d%d",&l,&r);
        if(dp[r] >= l)printf("yes\n");
        else printf("no\n");
    }
    return 0;
}
```







### 4、修改两个数最小分数

>我们先不考虑最小，考虑最大，首先排序，因为首尾相差是最大的，所以我们首先考虑首尾，有三种情况
>
>+ 去掉最大元素和最小元素算首尾
>+ 去掉两个最小元素
>+ 去掉两个最大元素
>
>这里去掉是把他们变成和下一个元素相同的，这样保证了最小可以取到0
>这三种情况取一个最小就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230219090250.png)

```cpp
class Solution {
public:
    int minimizeSum(vector<int>& nums) {
        int n = nums.size();
        if(n == 3)return 0;
        sort(nums.begin(),nums.end());
        return min(nums[n - 1] - nums[2],min(nums[n - 2] - nums[1],nums[n - 3] - nums[0]));
        
    }
};
```







### 5、最小无法得到的或值

>| 是指只要两个数相同位置有一个为1就行了
>然后我们看一下性质 :
>1 -> 0001
>2 -> 0010
>3 -> 0011
>4 -> 0100
>5 -> 0101
>6 -> 0110
>7 -> 0 111
>8 -> 1111
>
>我们发现   1 | 1 ->1     1 | 2 可以的到  1 - 3   1 | 2  |4 可以得到    1 - 7
>所以我们只要找最小2的次幂不在数组中就行了，这个数就是不能得到的最小数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230219090634.png)

```cpp
class Solution {
public:
    int minImpossibleOR(vector<int>& nums) {
        set<int>s;
        for(int  i = 0 ; i < nums.size() ;i  ++){
            s.insert(nums[i]);
        }
        for(int i = 0 ;i  <=30 ; i  ++){
            if(!s.count(1 << i))return 1 <<i;
        }
        return -1;
    }
};
```









### 6、变为0

>我们可以把一个数变为二进制  比如39  100111000
>这样子我们要把一消掉，我们可以把加上左边的1或者减去左边的一，可以用回溯来搞

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230226003610.png)

```cpp
class Solution {
public:
    int lobwit(int x){
        return x&(-x);
    }
    int dfs(int x){
        if((x &(x - 1) )== 0)return 1;
        int w = lobwit(x);
        return min(dfs(x + w),dfs(x - w)) + 1;
    }
    int minOperations(int n) {
        return dfs(n);
    }
};
```











## 二十六、递推

### 1、费解大的开关

你玩过“拉灯”游戏吗？

2525 盏灯排成一个 5×55×5 的方形。

每一个灯都有一个开关，游戏者可以改变它的状态。

每一步，游戏者可以改变某一个灯的状态。

游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。

我们用数字 11 表示一盏开着的灯，用数字 00 表示关着的灯。

下面这种状态

```
10111
01101
10111
10000
11011
```

在改变了最左上角的灯的状态后将变成：

```
01111
11101
10111
10000
11011
```

再改变它正中间的灯后状态将变成：

```
01111
11001
11001
10100
11011
```

给定一些游戏的初始状态，编写程序判断游戏者是否可能在 66 步以内使所有的灯都变亮。

#### 输入格式

第一行输入正整数 n，代表数据中共有 n个待解决的游戏初始状态。

以下若干行数据分为 n 组，每组数据有 55 行，每行 55 个字符。

每组数据描述了一个游戏的初始状态。

各组数据间用一个空行分隔。

#### 输出格式

一共输出 n� 行数据，每行有一个小于等于 66 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。

对于某一个游戏初始状态，若 66 步以内无法使所有灯变亮，则输出 −1−1。

#### 数据范围

0<n≤500



>思路
>枚举第一行按开关的所有方式
>然后遍历1到4行，如果当前位置为0，必须按下面的开关
>最后遍历最后一行是不是全为1就行了
>
>其中，op保存的根本就不是第一行的灯所有可能的状态，不然它第j位都为1了还按它干嘛？ k单纯只是保存了第一行按开关的32种方式，与输入数据无关。
>
>且大多数题解代码中都规定了op在二进制下某位为1就代表我们选择按下这一位所在编号的开关，你也可以自己规定k在二进制下某位为0才代表我们选择按下这一位所在编号的开关，这都无所谓。
>
>比如k在二进制下表示为10001，就代表我们选择按第一行编号为0和编号为4的开关，然后对输入数据中第一行这两位执行turn操作。

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
char g[6][6],bg[6][6];
int h1[5] = {1,-1,0,0,0};
int h2[5] = {0,0,-1,1,0};

//按开关
void turn(int x,int y){
   for(int i = 0 ;i < 5 ; i ++){
       int a = x + h1[i];
       int b = y + h2[i];
       if(a < 0 || b < 0 || a >=5 || b >= 5)continue;
           g[a][b]  ^= 1; 
   }
} 

void solve(){
    int res = 10;
   //备份数组
   for(int i = 0 ; i< 5 ; i ++){
       scanf("%s",bg[i]);
   }
   int cnt;
   for(int op = 0 ; op < 32; op ++){
       cnt = 0;
       memcpy(g,bg,sizeof(g));
       for(int i = 0 ; i < 5 ; i ++){
           //当前位置是1
           if(op >> i & 1){
               turn(0,i);
               cnt ++;
           }
       }
       
       //递推过程
       for(int i = 0 ;i < 4 ; i ++){
           for(int j = 0 ; j< 5 ; j ++){
               if(g[i][j] == '0'){
                   turn(i + 1,j);
                   cnt ++;
               }
           }
       }
       
      bool success = true;
      //检查最后一行
      for(int i = 0 ; i < 5 ; i ++){
          if(g[4][i] == '0'){
              success = false;
              break;
          }
      }
      if(success)res = min(res,cnt);
   }
   if(res > 6)cout<<-1<<endl;
   else cout<<res<<endl;
}

int main(){
    int t;
    cin>>t;
    while(t --)
    solve();
}
```







## 二十七、单调队列



### 1、最大子数组

给一个长度为n的数组，然后找出长度不超过m的最大值子数组的值

>思路
>可以用前缀和预处理
>我们本质找出l  r  ,求r - l + 1 <= m
>
>+ 前缀和求出l 到r的值
>+ 用单调队列，让s[i]从小到大在队列中 
>+ 从前往后遍历，对于i ，因为是单调队列，所以队列顶部的下标对应的s是最小的，s(i) - s(q.pop()) 最大，求最值
>+ 注意还要判断队列顶部的元素下标距离当前下标是不是小于等于m



```cpp
using namespace std;
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>

int main(){
    int n,m;
    cin>>n>>m;
    vector<int>v(n + 1);
    v[0] = 0;
    for(int i = 1 ; i <= n ; i ++){
        cin>>v[i];
        v[i] += v[i - 1];
    }
    deque<int>q;
    q.push_back(0);
    int mx = v[1];
    for(int i = 1 ; i <= n ; i ++){
        while(q.size() && q.front()< i - m)q.pop_front();
        mx = max(mx,v[i] - v[q.front()]);
        while(q.size() > 0 && v[q.back()] >= v[i])q.pop_back();
        q.push_back(i);
    }
    cout<<mx<<endl;
    return 0;
}
```

