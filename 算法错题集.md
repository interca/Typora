# 算法错题集

## 周赛难度网站

[rating (zerotrac.github.io)](https://zerotrac.github.io/leetcode_problem_rating/#/)

## 周赛积分预测

[Search | biweekly-contest-85 | Leetcode Rating Predictor (lcpredictor.herokuapp.com)](https://lcpredictor.herokuapp.com/contest/biweekly-contest-85/ranking/search)





## 常用容器

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171710.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171808.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825171857.png)

## 一、队列

### 1、单调队列

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220711182601.png" style="zoom: 67%;" />

思路，可以用一个队列，然后让他单调递减，每次滑动窗口的时候，队列末尾找，边找边删除末尾，直到遇到比这个数

大的值，入队列

同时，队列的头是这个窗口的最大值，移动了窗口，保证删除的窗口值和队列头不一样，如果一样，pop出来；

重复如此

具体代码：

```java
class Solution1 {

    LinkedList<Integer>queue;

    public int[] maxSlidingWindow(int[] nums, int k) {

        int n = nums.length;
        int[] a = new int[n + 1 - k];
        queue = new LinkedList<>();
        for (int i = 0; i < k; i++) {
            add(nums[i]);
        }
        int index = 0;
        a[index++] = get();
        for (int i = k; i < n; i++) {
            pop(nums[i - k]);
            add(nums[i]);
            a[index++] = get();

        }

        return a;
    }
     
    //添加值到队列，找到不小于它的值才添加，边找边Pop
    public void add(int a) {

        while (queue.size() > 0 && queue.get(queue.size() - 1) < a) {
            queue.remove(queue.size() - 1);
        }

        queue.add(a);
    }

    //只有当删除的窗口值等于队列最大值，才pop
    public void pop(int a) {
        if (queue.size() > 0 && queue.get(0) == a) {
            queue.remove(0);
        }
    }
    public int get() {

        return queue.get(0);
    }

}
```

```java
class Solution {//双端队列
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        Deque<Integer> deque = new LinkedList<Integer>();
        for (int i = 0; i < k; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
        }

        int[] ans = new int[n - k + 1];
        ans[0] = nums[deque.peekFirst()];
        for (int i = k; i < n; ++i) {
            while (!deque.isEmpty() && nums[i] >= nums[deque.peekLast()]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            while (deque.peekFirst() <= i - k) {
                deque.pollFirst();
            }
            ans[i - k + 1] = nums[deque.peekFirst()];
        }
        return ans;
    }
}
```

### 2、两个队列实现一个堆栈

```java

class MyStack {
    Queue<Integer>queue1;
    Queue<Integer>queue2;
    public MyStack() {
        queue1=new LinkedList<>();
        queue2=new LinkedList<>();
    }

public void push(int x) {
    queue2.add(x);
    while(queue1.size()>0){
        queue2.add(queue1.poll());
    }
    Queue<Integer>help;
    help=queue1;
    queue1=queue2;
    queue2=help;
}

public int pop() {
    return queue1.poll();
}

public int top() {
    return queue1.peek();
}

public boolean empty() {
    return queue1.size()==0&&queue2.size()==0;
}
```
}



### **3、循环队列**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815004447.png)

参考算法汇总里面循环队列

```java
class MyCircularDeque {
    //循环队列
    int []queue;
    int max;
    int size;
    int preindex;
    int lastindex;
    public MyCircularDeque(int k) {
        queue=new int[k];
        max=k;
        preindex=0;
        lastindex=1;
    }

    public boolean insertFront(int value) {
        if(size==max)return false;
        queue[preindex]=value;
        size++;
        if(preindex-1>=0)preindex--;
        else preindex=max-1;
        return true;
    }

    public boolean insertLast(int value) {
        if(size==max)return false;
        queue[lastindex]=value;
        size++;
        if(lastindex+1<max)lastindex++;
        else lastindex=0;
        return true;
    }

    public boolean deleteFront() {
        if(size==0)return false;
        if(preindex+1<max)preindex++;
        else preindex=0;
        size--;
        return true;
    }

    public boolean deleteLast() {
        if(size==0)return false;
        if(lastindex-1>=0)lastindex--;
        else lastindex=max-1;
        size--;
        return true;
    }

    public int getFront() {
        if(size==0)return -1;
        if(preindex+1<max)return queue[preindex+1];
        else return queue[0];
    }

    public int getRear() {
        if(size==0)return -1;
        if(lastindex-1>=0)return queue[lastindex-1];
        else return queue[max-1];
    }

    public boolean isEmpty() {
        return size==0;
    }

    public boolean isFull() {
        return size==max;
    }
}
```



### 4、石头下落

思路分析：

每一行进行操作，从后向前遍历，维护一个队列，如果遇到空，加入队列，如果是障碍物，则全部清空队列，如果是石头

弹出队列第一个位置，变成石头，然后石头的位置变为空，然后加入队列。

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220907181820.png)

```cpp
class Solution {
    public:
    vector<vector<char>> rotateTheBox(vector<vector<char>>& box) {
        int n=box.size();
        int m=box[0].size();
        deque<int>q;
        for(int i=0;i<n;i++){
            for(int j=m-1;j>=0;j--){
                if(box[i][j]=='.')q.push_back(j);
                else if(box[i][j]=='*')q.clear();
                else {
                    if(q.size()>0){
                        box[i][j]='.';
                        int k=q.front();
                        q.pop_front();
                        box[i][k]='#';
                        q.push_back(j);
                    }

                }
            }
            q.clear();
        }
        vector<vector<char>>v(m,vector<char>(n));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                v[j][n-i-1]=box[i][j];
            }
        }

        return v;
    }
};
```



### 5、最大堆

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910024334.png)

```cpp
class Solution {
    public:
    int halveArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        priority_queue<double>heap;//最大堆
        double sum=0.0;
        int count=0.0;
        for(int k:nums){
            sum+=k;
            heap.push(k);
        }
        double flag=sum/2;
        while(sum>flag){
            double k=heap.top();
            heap.pop();
            sum-=k/2;
            heap.push(k*1.0/2);
            count++;
        }
        return count;
    }
};
```



## 二、数组

### 1、拆分数组



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712104954.png" style="zoom:67%;" />

如果用模拟，可能过程有点繁琐

可以这样想，把每一秒都看成一个时刻，然后算这段时间人数，最后在用前缀和遍历

```java
class Solution {
    public boolean carPooling(int[][] trips, int capacity) {
        int []num=new int[1001];
        for(int []a:trips){
            num[a[1]]+=a[0]; //num[a[1]]表示a[1]路程有a[0]个人上车
            num[a[2]]-=a[0];  
        }
        if(num[0]>capacity)return false;  //判断第一次有没有超载
        for(int i=1;i<1001;i++){
            num[i]=num[i-1]+num[i];
            if(num[i]>capacity)return false;
        }
        return true;
    }
}
```



### 2、数组操作

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220716204527.png" style="zoom:50%;" />

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int k=in.nextInt();
        long[]num=new long[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextInt();
        }
        Arrays.sort(num);
        int index=0;
        long sum=0;
        long []s=new long[1000000];
        for(int i=0;i<n;i++) {
            while(i<n&&num[i]-sum<=0)i++;
            if(i<n){
                s[index++]=num[i]-sum;
                sum=num[i];
            }
        }
        for(int i=0;i<k;i++){
            System.out.println(s[i]);
        }
    }

}
```





### **3、力扣周赛可否被整除**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717140710.png)





一个思路是找出numsDivide数组所有数字的最大公约数，然后在让第一个数组能不能整除最大公约数，这里用了辗转相除法

```Java
class Solution {
    public int minOperations(int[] nums, int[] numsDivide) {
        int sum=0;
        int n1=nums.length;
        int n2=numsDivide.length;
        Arrays.sort(numsDivide);
        Arrays.sort(nums);
        HashSet<Integer>set=new HashSet<>();
        int index=numsDivide[0];
        //求出最大公约数
        for(int i=1;i<n2;i++){
            index=find(index,numsDivide[i]);
            if(index==-1)return -1;
        }
        //System.out.println(index);
        for(int i=0;i<nums.length;i++){
            if(index%nums[i]!=0)sum++;
            else break;
        }
        if(sum==n1)return -1;
        return sum;
    }
    public int find(int a,int b){
        return b > 0 ? find(b, a % b) : a;
    }
}
```





### 4、差分

先算出每个位置移动的情况，用差分然后再求前缀和，最后别忘记要取余

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821011550.png)



```java
class Solution {
    public String shiftingLetters(String s, int[][] shifts) {
        int n=s.length();
        char[]a=s.toCharArray();
        int []num=new int[n+1];
        //差分
        for(int i=0;i<shifts.length;i++){
            int k1=shifts[i][0];
            int k2=shifts[i][1];
            int k3=shifts[i][2];
            int w;
            if(k3==1)w=1;
            else w=-1;
            num[k1]+=w; num[k2+1]-=w;
        }
        //前缀和
        for(int i=1;i<n;i++){
            num[i]+=num[i-1];
        }
        for(int i=0;i<s.length();i++){
            if(num[i]==0)continue;
            if(num[i]>0){
                int k=num[i]%26;
                if(a[i]+k>'z')a[i]= (char) (a[i]+k-1-'z'+'a');
                else a[i]= (char) (a[i]+k);
            }else if(num[i]<0){
                int k=num[i]%26;
                if(a[i]+k<'a')a[i]=(char)('z'+a[i]+k+1-'a');
                else a[i]= (char) (a[i]+k);
            }
        }

        return new String(a);
    }
}
```



### 5、倒置

首先局部倒置一定是全局倒置，全局倒置不一定是局部倒置，所以问我们找出多的全局倒置，也就是不是局部倒置的情况

找出num[i]>num[j]  并且j>i+1

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220823005802.png)

```java
class Solution {
    public boolean isIdealPermutation(int[] nums) {
        int n=nums.length;
        int []dp=new int[n];
        if(n<=2)return true;
        dp[n-1]=nums[n-1];
        dp[n-2]=Math.min(nums[n-1],nums[n-2]);
        for(int i=n-3;i>=0;i--){
            dp[i]=Math.min(dp[i+1],nums[i]);
            if(nums[i]>dp[i+2])return false;
        }
        return true;
    }
}
```



### 6、长度为k的子数组最大和(滑动窗口)

维护一段区间的有多少个不同的数

然后移动窗口

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221107014039.png)

```cpp
class Solution {
public:
    long long maximumSubarraySum(vector<int>& nums, int k) {
        int n = nums.size();
        nums.insert(nums.begin(),0);
        vector<long long>pre(n +1,0);
        //前缀和
        for(int i = 1 ; i <= n ; i ++){
            pre[i] =  pre[i - 1] + nums[i];
        }
        nums.push_back(0);
        int l  = 1;
        int r  = k;
        long long  count = 0;
        map<int,int>m;
        int c = 0;
        for(int i = 1 ;i <= k ;i ++){
            m[nums[i]] ++;
            if(m[nums[i]] == 1)c ++;
        }
        while(r <= n){
             //cout<<l<<" "<<r<<" "<<c<<endl;
            if(c == k){
                count = (long long )max(count,pre[r] - pre[l - 1]);
            }
            m[nums[l]] --;
            if(m[nums[l]] == 0)c --;
            r ++;
            l ++;
             m[nums[r]] ++;
            if(m[nums[r]] == 1)c ++;
        }
        return count;
    }
};
```





## 三、哈希

### 1、哈希表排序



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712105458.png)

用定制排序对哈希表的value进行排序，这是核心

```java
class Solution {
    public int[] topKFrequent(int[] nums, int k) {

        sort p=new sort();
        int []str=new int[k];
        int index=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<nums.length;i++){
            if(map.get(nums[i])==null)map.put(nums[i],0);
            map.put(nums[i],map.get(nums[i])+1);
        }
        Set<Map.Entry<Integer,Integer>> set=map.entrySet();
        List<Map.Entry<Integer, Integer>> list = new ArrayList<>(set);
        Collections.sort(list,p);
        for(Map.Entry<Integer,Integer> s:list){
            int w=s.getKey();
            str[index++]=w;
            if(index==k)break;
        }
        return str;
    }
}
class sort implements Comparator<Map.Entry<Integer,Integer>>{

    @Override
    public int compare(Map.Entry<Integer, Integer> o1, Map.Entry<Integer, Integer> o2) {
        return o2.getValue()-o1.getValue();
    }
}
```



### 2、哈希计数

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714023226.png" style="zoom:67%;" />

用哈希表记录数组的值，如果有了，就计算长度，并且和min比较，记得吧新的值和坐标加回去

```Java
class Solution {
    public int minimumCardPickup(int[] cards) {
        int min=1000000;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<cards.length;i++){
            if(map.get(cards[i])==null)map.put(cards[i],i);
            else {
                min=Math.min(i-map.get(cards[i])+1,min);
                map.put(cards[i],i);
            }
        }
        if(min==1000000)return -1;
        return min;
    }
}
```



### 3、哈希找最大数组对

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717133739.png)

具体做法用哈希表存每个位置之和，然后遇到相同的，那就把哈希表值和算出的每位数之和相加，最后在更新哈希表，未来下一次计算

```java
class Solution {
    public int maximumSum(int[] nums) {
        HashMap<Integer,Integer>map=new HashMap<>();
        int max=-1;
        for(int i=0;i<nums.length;i++){
            int sum=0;
            int k=nums[i];
            while(k>0){
                sum=sum+k%10;
                k=k/10;
            }
            if(map.get(sum)==null)map.put(sum,nums[i]);
            else{
                max=Math.max(map.get(sum)+nums[i],max);
                if(map.get(sum)<nums[i])map.put(sum,nums[i]);
            }
        }
        return max;
    }
}
```





### **4、图论加哈希表**

每次DFS遍历，用Map记录结点和长度

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731122317.png)



```java
class Solution {
    int []vist;
    int sum;
    public int closestMeetingNode(int[] edges, int node1, int node2) {
          HashMap<Integer,Integer>map1=new HashMap<>();
         HashMap<Integer,Integer>map2=new HashMap<>();
        vist=new int[edges.length];
        map1.put(node1,0);
        vist[node1]=1;
        sum=0;
        dfs(map1,edges,edges[node1]);
        vist=new int[edges.length];
        vist[node2]=1;
        map2.put(node2,0);
        sum=0;
        dfs(map2,edges,edges[node2]);
        int max=1000000;
        int index=0;
        for(int k:map1.keySet()){
            int k1= map1.get(k);
            if(map2.get(k)==null)continue;
            int k2=map2.get(k);
           int min=Math.max(k1,k2);
           if(min<max){
               max=min;
               index=k;
           }

        }
        if(max==1000000)return -1;
        return index;
    }
    public  void dfs(HashMap<Integer,Integer>map,int[]edges,int k){
        if(k!=-1&&vist[k]==0){
            vist[k]=1;
            sum=sum+1;
            map.put(k,sum);
            dfs(map,edges,edges[k]);
        }
    }
}
```



### **5、坏数**

把左右两边移位置，记录i-num[i]

然后遍历，下标i表示前面多少数字，然后i-map[num[i]]就是不等于的，sum+=i-map[num[i]]; 然后map++;

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807004143.png)

```java
class Solution {
    public long countBadPairs(int[] nums) {
        int n=nums.length;
        long sum=0;
        for(int i=0;i<n;i++){
            nums[i]=nums[i]-i;
        }
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            if(map.get(nums[i])==null)sum+=i;
            else sum+=i-map.get(nums[i]);
            if(map.get(nums[i])==null)map.put(nums[i],1);
            else map.put(nums[i],map.get(nums[i])+1);
        }
        return sum;
    }
}
```



### 6、连接成数组

把pieces第一个数和整个数组放到map中

然后循环arr

如果arr[i]不在map 返回false

否则取出map中数组  对比数组和arr[i];

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827021052.png)

```java
class Solution {
    public boolean canFormArray(int[] arr, int[][] pieces) {
        HashMap<Integer,int[]>map=new HashMap<>();
        //把数组的第一个值和数组放入Map中
        for(int []a:pieces){
            map.put(a[0],a);
        }

        for(int i=0;i<arr.length;){
            if(map.containsKey(arr[i])==false)return false;
            int []a=map.get(arr[i]);
            for(int j=0;j<a.length;i++,j++){
                if(a[j]!=arr[i])return false;
            }
        }
        return true;
    }
}
```



### 7、计算重复字符串(非常难)

思路：

就是统计每个字符串出现的位置，用哈希表记录

找出只含有当前字符个数唯一的字符串

然后对应下标为i的字符串，向前找重复的下标为x1   向后为x2

(i-x1)*(x2-i)就是字符串个数

记住前面加-1,后面甲长度

记录只有一个字符情况

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220906031843.png)



```cpp
class Solution {
    public:
    int uniqueLetterString(string s) {
        map<char,vector<int>>m;
        for(int i=0;i<s.size();i++){
            char a=s[i];
            m[a].push_back(i);
        }
        int sum=0;
        for(auto k:m){
            vector<int>v=k.second;
            v.push_back(s.size());
            v.insert(v.begin(),-1);
            for(int i=1;i<v.size()-1;i++){
                sum+=(v[i]-v[i-1])*(v[i+1]-v[i]);
            }
        }
        return sum;
    }
};
```





### 8、摧毁目标

思路：

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030015554.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030004127.png)

```cpp
ppclass Solution {
public:
    int destroyTargets(vector<int>& nums, int space) {
      map<int,int>m;
      sort(nums.rbegin(),nums.rend());
      int max = 0;
      int flag = -1;
      for(auto k : nums){
          int r = k % space;
          m[r]++;
          if(m[r] >= max ){
              max = m[r];
              flag = k;
          }
      }
      return flag;
    }
};
```



## 四、树



### 1、堂兄弟

给你两个值，，判断是否为堂兄弟结点

无脑递归即可，找到这个结点后，记录这个结点的父节点

```java
class Solution {
    int h1;
    int h2;
    TreeNode root1;
    TreeNode root2;
    public boolean isCousins(TreeNode root, int x, int y) {
        dfs(root,0,x,y,null);
        return h1==h2&&root1!=root2;
    }
    public void dfs(TreeNode root,int sum,int x,int y,TreeNode parent){
        if(root==null)return ;
        if(root.val==x){
            h1=sum;
            root1 =parent;
            return;
        }else if(root.val==y){
            h2=sum;
            root2=parent;
            return;
        }

        dfs(root.left,sum+1,x,y,root);
        dfs(root.right,sum+1,x,y,root);
    }
}
```





### 2、翻转二叉树

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220712112805.png" style="zoom: 67%;" />



```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root==null)return null;
        TreeNode left=invertTree(root.left);
        TreeNode right=invertTree(root.right);
        root.left=right;
        root.right=left;
        return root;
    }
}
```

非递归

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if (root == null) return null;
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        while (queue.size() > 0) {
            int size = queue.size();
            TreeNode head = queue.poll();
            TreeNode help = head.left;
            head.left = head.right;
            head.right = help;
            if (head.left != null) queue.add(head.left);
            if (head.right != null) queue.add(head.right);
            size--;
        }
        return root;
    }
}
```



### 3、完全二叉树结点个数

```java
class Solution {
    public int countNodes(TreeNode root) {
        if(root==null)return 0;
        int left=countNodes(root.left);
        int right=countNodes(root.right);
        return left+right+1;
    }
}
```



### 4、二叉树的最小高度

找左儿子为null的结点，最小一点在右，反之在左，最后比较

```java
class Solution {
    public int minDepth(TreeNode root) {
        if(root==null)return 0;
        int left=minDepth(root.left);
        int right=minDepth(root.right);
        if(root.left==null&&root.right!=null){
            return 1+right;
        }
        if(root.left!=null&&root.right==null){
            return 1+left;
        }
        return  Math.min(right,left)+1;
    }
}
```



### 5、最左下角的结点

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717000946.png" style="zoom:67%;" />

因为要最右边的左结点，所以我们采取前序遍历，然后贪心

```java
class Solution {
    int value;
    int deepmax=-1;
    public int findBottomLeftValue(TreeNode root) {
        value=root.val;
        dfs(root,0);
        return value;
    }
    public void dfs(TreeNode root,int deep){
        if(root==null)return;
        if(root.left==null&&root.right==null){
            if(deep>deepmax){
                deepmax=deep;
                value=root.val;
            }
        }
        dfs(root.left,deep+1);
        dfs(root.right,deep+1);
    }
}
```





### **6、验证一棵树是不是二插搜索树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718034405.png)

思路，在左子树中找到最大值，在右子树中小于最小值，如果当前的结点值小于等于左子树最大且大于等于右子树最小，return FALSE

然后分别递归

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root==null)return true;
        int k1=0;
        int k2=0;
        if(root.left!=null)
            k1=findmax(root.left);
        if(root.right!=null)
            k2=findmin(root.right);
        if(root.left!=null&&root.val<=k1||root.right!=null&&root.val>=k2)return false;
        return isValidBST(root.left)&&isValidBST(root.right);
    }

    public int findmax(TreeNode head){
        while(head.right!=null){
            head=head.right;
        }
        return head.val;
    }
    public int findmin(TreeNode head){
        while(head.left!=null){
            head=head.left;
        }
        return head.val;
    }
}
```



### **7、最大二叉树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719003214.png)

可以这样想，就是每次从数组里找出最大值的下标，然后人让他成为根，然后递归创建左右子树

```java
class Solution {
    public TreeNode constructMaximumBinaryTree(int[] nums) {
        return  dfs(nums,0,nums.length-1);
    }
    public TreeNode dfs(int []nums,int l,int r){

        if(l>r)return null;
        int index=findmax(nums,l,r);
        TreeNode root=new TreeNode(nums[index]);
        root.left=dfs(nums,l,index-1);
        root.right=dfs(nums,index+1,r);
        return root;
    }
    public int  findmax(int []nums,int l,int r){
        int max=nums[l];
        int index=l;
        for(int i=l;i<=r;i++){
            if(nums[i]>max){
                max=nums[i];
                index=i;
            }
        }
        return index;
    }
}
```



### 8、二叉树两个结点最近的公共祖先

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719014425.png)

递归，看看这棵树的根结点是不是等于p,或者q

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root==null)return null;
        if(root==q||root==p)return root;
        var left=lowestCommonAncestor(root.left,p,q);
        var right=lowestCommonAncestor(root.right,p,q);
        if(left!=null&&right!=null)return root;
        if(left!=null)return left;
        if(right!=null)return right;
        return null;
    }
}
```



### 9、删除结点

找到要删除的结点，找左子树最大的结点或者右子树最小的结点替换当前结点

```java
class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        TreeNode temp=new TreeNode();
        if(root==null)return null;
        if(key>root.val)root.right=deleteNode(root.right,key);
        else if(key<root.val)root.left=deleteNode(root.left,key);
        else {
            if(root.left!=null&&root.right!=null){
                temp.val=findmax(root.left);
                root.val=temp.val;
                root.left=deleteNode(root.left,root.val);
            }else{
                if(root.left==null){
                    root=root.right;
                }else root=root.left;
            }
        }
        return root;

    }
    //找左边最大的值
    public int findmax(TreeNode root){
        while(root.right!=null)root=root.right;
        return root.val;
    }
}
```



### 10、修剪树

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220720152514.png)

```java
class Solution {
    public TreeNode trimBST(TreeNode root, int low, int high) {
        if(root==null)return null;
        if(root.val<low)return trimBST(root.right,low,high);
        if(root.val>high)return trimBST(root.left,low,high);
        root.left=trimBST(root.left,low,high);
        root.right=trimBST(root.right,low,high);
        return root;
    }
}
```



### 11、层序遍历加队列

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725022256.png)

核心思想：用层序遍历找到两个结点都不是有值的结点，然后存储到另一个队列

```java
class CBTInserter {
    TreeNode head;
    Queue<TreeNode>queue=new LinkedList<>();
    TreeNode parent;
    public CBTInserter(TreeNode root) {
        Queue<TreeNode>help=new LinkedList<>();
        head=root;
        TreeNode root1=root;
        help.add(root1);
        //只把最底层的结点装入队列中
        while(help.size()>0){
            root1=help.poll();
            if(root1.left!=null)help.add(root1.left);
            if(root1.right!=null)help.add(root1.right);
            if(!(root1.left!=null&&root1.right!=null))queue.add(root1);
        }
    }

    public int insert(int val) {
        TreeNode node=new TreeNode(val);
        node.left=node.right=null;
        if(parent==null||parent.left!=null&&parent.right!=null)parent=queue.poll();
        if(parent.left==null){
            parent.left=node;
        }else if(parent.right==null){
            parent.right=node;
        }
        queue.add(node);
        return parent.val;
    }

    public TreeNode get_root() {
        return head;
    }
}
```



### 12、等价翻转

<img src="C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220729200558.png" style="zoom: 67%;" />



```java
class Solution {
    public boolean flipEquiv(TreeNode root1, TreeNode root2) {
        if(root1==null&&root2==null)return true;
        if(root1==null&&root2!=null||root1!=null&&root2==null)return false;
        if(root1.val!=root2.val)return false;
        return flipEquiv(root1.left,root2.left)&&flipEquiv(root1.right,root2.right)||
                flipEquiv(root1.left,root2.right)&&flipEquiv(root1.right,root2.left);
    }
}
```





### 13、删点成林

很简单，后序遍历每一个点，如果当前点的值在数组中，那么就记录当前点的两个左右儿子，同时让当前点的父节点的指向当前的指针为空，记住，递归开始前要先判断根结点，

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820140835.png)

```java
class Solution {
    HashSet<Integer>set;
    public List<TreeNode> delNodes(TreeNode root, int[] to_delete) {
        List<TreeNode>list=new ArrayList<>();
        set=new HashSet<>();
        for(int k:to_delete){
            set.add(k);
        }
        if(set.contains(root.val)==false){
            list.add(root);
        }
        dfs(root,list,null,0);
        return list;
    }

    public void dfs(TreeNode root,List<TreeNode>list,TreeNode p,int n){
        if(root==null)return;
        dfs(root.left,list,root,1);
        dfs(root.right,list,root,2);
        if(set.contains(root.val)==true){
            if(root.left!=null)list.add(root.left);
            if(root.right!=null)list.add(root.right);
            if(n==1)p.left=null;
            else if(n==2)p.right=null;
        }
    }
```





### **14、二叉树最大宽度**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827010554.png)

```java
class Solution {
    public int widthOfBinaryTree(TreeNode root) {
        int index=1;
        Queue<TreeNode>queue=new LinkedList<>();
        queue.add(root);
        HashMap<TreeNode,Integer>map=new HashMap<>();
        int max=1;
        int pre=0;
        map.put(root,1);
        while(queue.size()>0){
            int size=queue.size();
            pre=map.get(queue.peek());
            while(size>0){
                size--;
                root=queue.poll();
                if(root!=null){
                    max=Math.max(max,map.get(root)-pre+1);
                }
                if(root.left!=null){
                    queue.add(root.left);
                    map.put(root.left,map.get(root)*2);
                }
                if(root.right!=null){
                    queue.add(root.right);
                    map.put(root.right,map.get(root)*2+1);
                }
            }
        }
        return max;
    }
}
```





### 15、最深结点的父节点

思路：

递归看左边深度和右边深度

如果一样，返回根结点

否则如果左边高度大，递归左边，否则右边

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830172122.png)



```java
class Solution {
    public TreeNode subtreeWithAllDeepest(TreeNode root) {
        int l=deep(root.left);
        int r=deep(root.right);
        if(l==r)return root;
        else if(l>r)return subtreeWithAllDeepest(root.left);
        else return subtreeWithAllDeepest(root.right);
    }
    public int deep(TreeNode root){
        if(root==null)return 0;
        int l=deep(root.left)+1;
        int r=deep(root.right)+1;
        return Math.max(l,r);
    }
}
```



### **16、最大二叉树(题目傻逼)**

首先先描述题目：

这里的树是按照数组的二分来构造的

根结点左边的全部是左子树

根结点右边的全部是右子树

题目的意思是在数组的末尾加一个值

返回新的树的根结点



思路：

首先加到数组的右边，那么当前值肯定在跟结点的右边，不可能在左边

首先要先判断，如果值比根还大，那么当前值作为根结点，当前值的左儿子指向原来的根结点，返回当前结点

否则向右递归

如果当前结点为Null说明这个值是要接到叶子结点，直接返回新的结点就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830173034.png)



```java
class Solution {
    TreeNode last=null;
    int flag=0;
    public TreeNode insertIntoMaxTree(TreeNode root, int val) {
        if(root==null)return new TreeNode(val);
        if(root.val<val){
            TreeNode root1=new TreeNode(val);
            root1.left=root;
            return root1;
        }
        root.right=insertIntoMaxTree(root.right,val);
        return root;
    }

}
```



### **17、重复子树(难)序列化**

把数序列化，这样子可以判断有没有重复



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220906000627.png)



```java
class Solution {
   HashMap<String,TreeNode>map;
   HashSet<TreeNode>set;
   public List<TreeNode> findDuplicateSubtrees(TreeNode root) {
      map=new HashMap<>();
      set=new HashSet<>();
      dfs(root);
      return new ArrayList<TreeNode>(set);
   }
   public String dfs(TreeNode root){
      if(root==null)return "";
      StringBuilder s = new StringBuilder();
      s.append(root.val+"");
      s.append("(");
      s.append(dfs(root.left));
      s.append(")(");
      s.append(dfs(root.right));
      String str=s.toString();
      if(map.get(str)!=null){
         set.add(map.get(str));
      }else map.put(str,root);
      return str;
   }
}
```



### **18、平衡树**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911035259.png)

```cpp
class Solution {

    public:
    vector<int>v;
    TreeNode* balanceBST(TreeNode* root) {
        dfs(root);
        sort(v.begin(),v.end());
        int mid=(v.size()-1)/2;
        TreeNode *root1=new TreeNode(v[mid]);
        root1->left= make(0,mid-1);
        root1->right=make(mid+1,v.size()-1);
        return root1;
    }
    TreeNode *make(int l,int r){
        if(l>r)return NULL;
        int mid=(l+r)/2;
        TreeNode*node=new TreeNode(v[mid]);
        node->left=make(l,mid-1);
        node->right=make(mid+1,r);
        return node;
    }
    void dfs(TreeNode *root){
        if(root==NULL)return ;
        dfs(root->left);
        dfs(root->right);
        v.push_back(root->val);
    }
};
```





### 19、二叉树寻路(难)

思路：

我们先计算总的层数

对于第i层   第一个数是2的i-1次方

整棵树的结点数是2的i次方减一

我们可以根据层数和结点标号来算出它反转的结点是多少

每次结点标号反转然后除以2才是下一个结点的值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221004003255.png)

```cpp
class Solution {
    public:
    vector<int> pathInZigZagTree(int label) {
        vector<int>v;
        int row = 1;
        while(!(label <= pow(2,row) - 1 && label >= pow(2,row-1)))row++;
        int k = label;
        v.push_back(label);
        label = count(label,row--)/2;;
        while(row > 0){
            v.push_back(label);
            label = count(label,row --);
            label = label/2;
        }
        reverse(v.begin(),v.end());
        return v;
    }

    //计算倒置后对应的数
    int count(int number,int row){
        int count = pow(2,row - 1);
        int sum = pow(2,row) - 1;
        int rest = sum - number;
        return count + rest;
    }
};
```

## 五、贪心

### 1、连续子数组最大和

```Java
class Solution {
    public int maxSubArray(int[] nums) {
        int n=nums.length;
        int i,j;
        int max=0;
        int pre=nums[0];
        for(i=0;i<n;i++){
            max=Math.max(nums[i],max+nums[i]);
            pre=Math.max(pre,max);
        }
        return pre;
    }
}
```



### 2、最长山脉

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714022439.png" style="zoom:67%;" />

二分加贪心，从中间向两边延伸，然后贪心

```java
class Solution {
    public int longestMountain(int[] arr) {
        int n=arr.length;
        if(n<=2)return 0;
        int sum=0;
        for(int i=1;i<n-1;i++){
            int count=0;
            if(arr[i-1]>=arr[i]||arr[i+1]>=arr[i])continue;
            int left=i;
            int right=i;
            while(left-1>=0&&arr[left-1]<arr[left]){
                left--;
                count++;;
            }
            while(right+1<=n-1&&arr[right+1]<arr[right]){
                right++;
                count++;
            }
            sum=Math.max(sum,count+1);
        }
        return sum;
    }
}
```



### 3、买股票

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806001333.png)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int min=10000000;
        int max=0;
        for(int i=0;i<prices.length;i++){
            if(prices[i]<min){
                min=prices[i];
            }else {
                max=Math.max(max,prices[i]-min);
            }
        }
        return max;
    }
}
```



### 4、完成任务(我是sb)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807011133.png)

第一种方法，计算这个任务下一次完成在第几天，也就是sum+space+1;

每次遇到这个任务，取出前一天+1和map里值中的最大值，更新sum,然后重新记录map里的值

```java
class Solution {
    public long taskSchedulerII(int[] tasks, int space) {
        int n=tasks.length;
        long sum=0;
        HashMap<Integer,Long>map=new HashMap<>();
        for(int i=0;i<n;i++){
            long k=map.get(tasks[i])==null?0:map.get(tasks[i]);
            sum=Math.max(sum+1,k);
            map.put(tasks[i],sum+(long)(space+1));
        }
        return sum;
    }
}
```

另一种方法是记录现在这个任务要计划多少填，如果Map等于Null,直接sum++就行了，把下一次的任务给记住，否则就从sum+1到当前任务计划天数里面取大的，更新Map

```java
class Solution {
    public long taskSchedulerII(int[] tasks, int space) {
        int n=tasks.length;
        long sum=0;
        HashMap<Integer,Long>map=new HashMap<>();
        for(int k:tasks){
            long pre=0;
            if(map.get(k)==null){
                sum++;
                map.put(k,sum+space+1);
                continue;
            }
            pre=map.get(k);
            sum=Math.max(sum+1,pre);
            map.put(k,sum+space+1);
        }
        return sum;
    }
}
```



### 5、排序数组(数学知识)

我们从后到前，记住上一个数为last

如果当前数小于更新last

否则：

判断如果当前数可以整除last

那么拆分的次数就是整除-1  Last维持

如果不可以，那要平均分k组，使得每组尽可能相等

比如当前数是7 last 是6，我们分两组，分别为3,4这样子后面拆分的操作才能更少，不能拆成1 6

所以k等于当前数除以last+1

因为有分成了K组，所以操作为k-1 

最后last为  当前数除以k  余数全部加到后面去了

比如当前数是8   last=3   所以分成三组   2,3,3

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807023402.png)

```java
class Solution {
    public long minimumReplacement(int[] nums) {
        long sum=0;
        int n=nums.length;
        int last=nums[n-1];
        for(int i=n-2;i>=0;i--){
            // System.out.println(last+" "+sum);
            if(nums[i]<=last)last=nums[i];
            else{
                if(nums[i]%last==0){
                    sum+=nums[i]/last-1;
                }else{
                    int k=nums[i]/last+1;
                    sum+=k-1;
                    last=nums[i]/k;
                }
            }
        }
        return sum;
    }
}
```



### 6、划分k

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220811181453.png)

```java
class Solution {
    public int partitionArray(int[] nums, int k) {
        Arrays.sort(nums);
        int count=1;
        int falg=nums[0];
        for(int i=1;i<nums.length;i++){
            if(nums[i]-falg<=k){

            }else {
                falg=nums[i];
                count++;
            }
        }
        return count;
    }
}
```



### 7、划分数组

如果左边数组最大值大于当前值，那么定位到当前数组，如果更新左边数组的最大值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815191526.png)

```java
class Solution {
    public int partitionDisjoint(int[] nums) {
        int n=nums.length;
        int index=0;
        int leftmax=nums[0];
        int max=nums[0];
        for(int i=0;i<n;i++){
            max=Math.max(nums[i],max);
            if(nums[i]<leftmax){
                index=i;
                leftmax=max;
            }
        }
        return index+1;
    }
}
```



### 8、矩阵二进制

思路，如果都为零全部加零，为一，全部加一，记住Lower和upper要递减，如果加一lower或者upper有等于零直接返回空

然后一个零一个一，优先把一往大的地方放

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818142103.png)

```java
class Solution {
    public List<List<Integer>> reconstructMatrix(int upper, int lower, int[] colsum) {
        List<Integer>list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        List<List<Integer>>list=new ArrayList<>();
        int n=colsum.length;
        for(int i=0;i<n;i++){
            int value=colsum[i];
            if(value==2){
                if(upper==0||lower==0)return list;
                list1.add(1);
                list2.add(1);
                upper--;
                lower--;
            }else if(value==0){
                list1.add(0);
                list2.add(0);
            }else {
                if(upper>lower){
                    list1.add(1);
                    list2.add(0);
                    upper--;
                }else {
                    list1.add(0);
                    list2.add(1);
                    lower--;
                }
            }
        }

        if(lower!=0||upper!=0)return list;
        list.add(list1);
        list.add(list2);
        return list;
    }
}
```





### 9、删除字符串

先记录字符串数量，从小到大排序，然后用哈希表，判断当前字符串数量有没有重复吗，如果重复，就递减，然后操作加一

最后更新哈希表

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819170046.png)

```java
class Solution {
    public int minDeletions(String s) {
        int[]num=new int[26];
        for(int i=0;i<s.length();i++){
            num[s.charAt(i)-'a']++;
        }
        int sum=0;
        HashSet<Integer>set=new HashSet<>();
        Arrays.sort(num);
        for(int i=0;i<26;i++){
            int value=num[i];
            while(value!=0&&set.contains(value)==true){
                value--;
                sum++;
            }
            set.add(value);
        }
        return sum;
    }
}
```





### 10、摆动序列

每次开始检测是不是和前一次一样，记录上一次摆动序列

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827024704.png)

```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n=nums.length;
        if(n<=1)return n;
        int pre=0;
        int last=0;
        int sum=1;
        for(int i=0;i<n-1;i++){
            last=nums[i+1]-nums[i];
            if(last<0&&pre>=0||last>0&&pre<=0){
                sum++;
                pre=last;
            }
        }
        return sum;
    }
}
```



### 11、跳跃游戏

每次看下标和最大距离的大小，并且更新最大距离

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830185049.png)

```c++
class Solution {
    public:
    bool canJump(vector<int>& nums) {
        int max1=nums[0];
        for(int i=1;i<nums.size();i++){

            if(i>max1)return false;
            max1=max(max1,i+nums[i]);
        }
        return true;
    }
};
```



### **12、跳跃游戏2(难)**

思路：

这道题有点意思

首先要维护此时最大距离nextreach

reach是上一步覆盖的氛围

如果下标到达这个范围，就要更新nextreach

能够到最远距离为nextreach的点一定在上一点到reach之间

所以更新count

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220830202007.png)

```java
class Solution {
    public int jump(int[] nums) {
        if(nums.length==1)return 0;
        int n=nums.length;
        int nextreach=nums[0];
        int reach=0;
        int count=0;
        for(int i=0;i<n;i++){
            nextreach=Math.max(nextreach,i+nums[i]);
            if(nextreach>=n-1)return count+1;
            if(reach==i){
                reach=nextreach;
                count++;
            }
        }
        return count;
    }
}
```





### 13、分糖果

思路：先让数组初始值为1

然后从前往后遍历，如果后一个值大于前一个，后一个值等于前一个加一

否则跳过

然后从后向前

如果前一个大于后一个

从后一个加一和当前值这两个选个最大值出来

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220903215848.png)

```java
class Solution {
    public int candy(int[] ratings) {
        int n=ratings.length;
        int []num=new int[n];
        for(int i=0;i<n;i++){
            num[i]=1;
        }
        for(int i=0;i<n-1;i++){
            if(ratings[i+1]>ratings[i])num[i+1]=num[i]+1;
        }
        for(int i=n-1;i>=1;i--){
            if(ratings[i-1]>ratings[i]){
                num[i-1]=Math.max(num[i]+1,num[i-1]);
            }
        }
        int sum=0;
        for(int i=0;i<n;i++){
            sum+=num[i];
        }
        return sum;
    }
}
```



### **14、最小异或**

找出Num2中的1

然后从最高位到最低位吧num1中的1替换为0

如果有剩余的就把num1中的0从最低位到最高位替换为1



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002130820.png)





```cpp
class Solution {
    public:
    int minimizeXor(int num1, int num2) {
        int cnt = 0;
        while(num2){
            cnt += (num2)&1;
            num2 = num2>>1;
        }
        int res=num1;
        for(int i=30;i>=0&&cnt>0;i--){
            if(((num1 >> i) & 1) == 1){
                res -=1<<i;
                cnt --;
            }
        }
        for(int i=0;i<=30&&cnt>0; i ++){
            if(((num1 >> i) & 1) ==0){

                res +=1<<i;
                cnt--;
            }
        }

        return res^num1;
    }
};
```



### 15、k个回文子串

因为构造k个回文

所以奇数的个数小于k

并且长度大于k

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002233040.png)

```cPp
class Solution {
    public boolean canConstruct(String s, int k) {

        int []num=new int[26];
        for(int i=0;i<s.length();i++){
            num[s.charAt(i)-'a']++;
        }
        int sum=0;
        for(int i=0;i<26;i++){
            if(num[i]%2==1)sum++;
        }
        return sum<=k&&s.length()>=k;
    }
}
```



### 16、最小化数组的最大值

求前缀和  每一次求平均数  取最大值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014144.png)



```cPP
class Solution {
    public:
    int minimizeArrayValue(vector<int>& nums) {
        int mx = nums[0];
        long long  sum = nums[0];
        for(int i = 1;i < nums.size(); i ++){
            sum = (sum+nums[i]);
            if(sum%(i+1)==0)
                mx = max(mx,(int)((sum)/(i+1)));
            else mx = max(mx,(int)((sum)/(i+1)+1));
        }
        return mx;
    }
};
```

## 六、动态规划

### 1、最长递增子序列

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220714021803.png" style="zoom:67%;" />

思想动态规划

dp[i]为此时的最长子序列，前面i-1个数，如果dp[j]<dp[i]  dp[i]=dp[j]+1;然后在取大

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < nums.length; i++) {
            //初始肯定为1
            dp[i] = 1;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    //贪心
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```



### **2、子矩阵**

可以先统计每个点向左横向可以形成几个正方形

如果下面动态规划

这个点向上面走，取小，然后相加

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807061701.png)

```java
class Solution {
    public int numSubmat(int[][] mat) {
        int m=mat.length;
        int n=mat[0].length;
        int [][]dp=new int[m][n];
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                if(j==0){
                    dp[i][j]=mat[i][j];
                }else {
                    if(mat[i][j]!=0){
                        dp[i][j]=dp[i][j-1]+1;
                    }
                    else dp[i][j]=0;
                }
            }
        }
        int sum=0;
        for(int i=0;i<m;i++){
            for(int j=0;j<n;j++){
                int min=dp[i][j];
                for(int k=i;k>=0&&min!=0;k--){
                    min=Math.min(min,dp[k][j]);
                    sum=sum+min;
                }
            }
        }
        return sum;
    }
}
```





### **3、组合**(难)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220808112534.png)

dp[i]等于前i-1下标是否可以构成序列，nums[i-1]==nums[i-2]  先不影响前i-2序列，所以保证f[i-2]=true  才能为true   其他都一样



```java
class Solution {
    public boolean validPartition(int[] nums) {
        int  n=nums.length;
        boolean[]dp=new boolean[n+1];
        dp[0]=true;
        dp[1]=false;

        dp[2]=(nums[1]==nums[0]);
        for(int i=3;i<=n;i++){
            if(nums[i-1]==nums[i-2]){
                if(dp[i-2]==true)dp[i]=true;
                if(nums[i-2]==nums[i-3]&&dp[i-3]==true)dp[i]=true;
            }else{
                if(nums[i-1]-nums[i-2]==1&&nums[i-2]-nums[i-3]==1&&dp[i-3]==true)dp[i]=true;
            }
        }
        return dp[n];
    }
}
```



### 4、子数组范围

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220817170544.png)

```java
class Solution {
    public long subArrayRanges(int[] nums) {
        int n=nums.length;
        int [][]max=new int[n][n];
        int [][]min=new int[n][n];
        long sum=0;
        for(int i=0;i<n;i++){
            max[i][i]=nums[i];
            min[i][i]=nums[i];
            for(int j=i+1;j<n;j++){
                max[i][j]=Math.max(nums[j],max[i][j-1]);
                min[i][j]=Math.min(nums[j],min[i][j-1]);
                sum+=max[i][j]-min[i][j];
            }
        }
        return sum;
    }
}
```





### 5、字典元音

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023930.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023134.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220824023156.png)



```java
class Solution {
    public int countVowelStrings(int n) {
        int []dp=new int[]{1,1,1,1,1};
        int sum=0;
        for(int i=2;i<=n;i++){
            sum=0;
            for(int j=4;j>=0;j--){
                sum+=dp[j];
                dp[j]=sum;
            }
        }
        sum=0;
        for(int i=0;i<5;i++)sum+=dp[i];
        return sum;
    }
}
```



### 6、摆动序列

思路：

考虑用动态规划的思想来解决这个问题。

很容易可以发现，对于我们当前考虑的这个数，要么是作为山峰（即nums[i] > nums[i-1]），要么是作为山谷（即nums[i] < nums[i - 1]）。

- 设dp状态`dp[i][0]`，表示考虑前i个数，第i个数作为山峰的摆动子序列的最长长度
- 设dp状态`dp[i][1]`，表示考虑前i个数，第i个数作为山谷的摆动子序列的最长长度

则转移方程为：

- `dp[i][0] = max(dp[i][0], dp[j][1] + 1)`，其中`0 < j < i`且`nums[j] < nums[i]`，表示将nums[i]接到前面某个山谷后面，作为山峰。
- `dp[i][1] = max(dp[i][1], dp[j][0] + 1)`，其中`0 < j < i`且`nums[j] > nums[i]`，表示将nums[i]接到前面某个山峰后面，作为山谷。

初始状态：

由于一个数可以接到前面的某个数后面，也可以以自身为子序列的起点，所以初始状态为：`dp[0][0] = dp[0][1] = 1`。

<img src="C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220827024704.png"  />



```java
class Solution {
    public int wiggleMaxLength(int[] nums) {
        int n=nums.length;
        if(n<=1)return n;
        int [][]dp=new int[n][2];
        dp[0][0]=1;
        dp[0][1]=1;
        for(int i=1;i<n;i++){
            dp[i][0]=dp[i][1]=1;
            for(int j=0;j<i;j++){
                if(nums[j]<nums[i])dp[i][0]=Math.max(dp[i][0],dp[j][1]+1);
                else if(nums[j]>nums[i])dp[i][1]=Math.max(dp[i][1],dp[j][0]+1);
            }

        }
        return Math.max(dp[n-1][0],dp[n-1][1]);
    }
}
```



### 7、走步数(难)



思路：

k属于1到1000

也就是最左边是500 走过去再回来，最右边是1500 从1000位置走过去再回来

所以数组的大小为2000

我们开一个二维的 dp

第一个参数是步数，第二个是位置

同时我们还要把两个下标加500

然后量从两重循环：

第一重是步数，第二重是位置

每一步可以从上一步转移过来

同时两种转移方式

前或者后

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220904200633.png)

```java
class Solution {
    public int numberOfWays(int startPos, int endPos, int k) {
        int e=1000000007;
        int [][]dp=new int[1010][2010];
        startPos+=500;
        endPos+=500;
        dp[0][startPos]=1;
        for(int i=1;i<=k;i++){
            for(int j=0;j<2010;j++){
                if(j!=0)dp[i][j]=dp[i-1][j-1];
                if(j+1<2010)dp[i][j]=(dp[i][j]+dp[i-1][j+1])%e;
            }
        }
        return dp[k][endPos];
    }
}
```



### 8、最短编辑距离

思路：

找到当前状态是从什么地方转移过来的

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910212529.png)

首先当前操作是删除

那么就是f(i-1)(j)+1  f(i-1)(j)表示将a中1到i-1的字符变成b中1到j

还有增加

修改   注意修改的时候要判断a(i)和b(j)是否相等

初始化的时候也要注意

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910214915.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 1010;
        int n,m;
        char a[N],b[N];
        int f[N][N];
        int main()
        {
           scanf("%d%s",&n,a+1);
           scanf("%d%s",&m,b+1);
           for(int i=0;i<=m;i++)f[0][i]=i;
           for(int i=0;i<=n;i++)f[i][0]=i;
           
           for(int i=1;i<=n;i++){
               for(int j=1;j<=m;j++){
                   f[i][j]=min(f[i-1][j]+1,f[i][j-1] + 1);
                    if(a[i]==b[j])f[i][j] = min(f[i][j], f[i-1][j-1]);
                    else f[i][j]=min(f[i][j],f[i-1][j-1]+1);
               }
            }
           cout<<f[n][m];
          return 0;
        }
```





### **9、编辑距离**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910223115.png)





```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include<string.h>
        using namespace std;
        int n,m;
        char str[1010][15];
        int f[15][15];
        int sum=0;
        int find(char a[],char b[]){
            int lena=strlen(a+1);
            int lenb=strlen(b+1);
            for(int i=0;i<=lenb;i++)f[0][i]=i;
            for(int i=0;i<=lena;i++)f[i][0]=i;

            for(int i=1;i<=lena;i++){
                for(int j=1;j<=lenb;j++){
                   f[i][j]=min(f[i-1][j]+1,f[i][j-1]+1);
                  f[i][j]=min(f[i][j],f[i-1][j-1]+(a[i]!=b[j]));
              }
            }
            return f[lena][lenb];
        }


        int main()
        {
           cin>>n>>m;
           for(int i=0;i<n;i++)scanf("%s",str[i]+1);
           for(int i=0;i<m;i++){
           char s[15];
           int limt;
            sum=0;
            scanf("%s%d",s+1,&limt);
            for(int j=0;j<n;j++){
              if(find(str[j],s)<=limt)sum++;
             }
           cout<<sum<<endl;
        }
           return 0;
        }
```



### 10、整数拆分(难)

f(i)表示将i 拆分获得的最大乘积

i  可以分成两部分

j 是拆分的第一个整数

那么剩下的 i - j可以选择继续分或者不分

j  和  i-j   这时候      可以选择将i继续分  f(i-j)*j   或者 不分  j* *(i-j) 

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221011113242.png)



```cpp
class Solution {
    public:
    int integerBreak(int n) {
        vector<int>dp(n+1,0);
        dp[0] = dp[1] = 0;
        int sum = 0;
        for(int i = 2 ; i <= n ; i ++){
            for(int j = 1 ; j < i; j ++){
                sum = max(sum,max(dp[i - j]*j,(i - j) * j));
            }
            dp[i] = sum;
        }
        return dp[n];
    }
};
```







### 11、不同子序列(难)

思路就是统计每个字符作为最后一个单词出现的次序

没次遍历都要对26个字母统计一次

然后总次数加一  更新当前字符     只要sum +1就行了  因为自己本身也算一个

最后在遍历二十六个字母

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221014132945.png)



```cpp
class Solution {
    public:
    int distinctSubseqII(string s) {
        int n = s.size();
        int e = 1e9+7;
        int num[26];
        long sum ;
        memset(num,0,sizeof num);
        for(int i = 0; i < n ; i ++){
            sum = 0;
            for(int j = 0; j < 26 ;j ++){
                sum = (sum + num[j])%e;
            }
            num[s[i] - 'a'] = sum + 1;
        }
        int count = 0;
        for(int i = 0;i < 26 ; i++ ){
            count = (num[i] + count)%e;
        }
        return count;
    }
};
```



### 12、字符串链(哈希加动态规划)

思路：按长度排序，然后map记录每个字符出现的位置

这里吧map加一  因为map初始为0  会和0下标重复

如果就是一个循环  每次循环枚举比当前字符少一个的字符串   取最大值



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221015010709.png)



```cpp
class Solution {
    public:
    static int  cmp(string s1,string s2){
        return s1.size()<s2.size();
    }
    int longestStrChain(vector<string>& words) {
        sort(words.begin(),words.end(),cmp);
        int n=words.size();
        vector<int>dp(n,1);
        int mx=1;
        //记录字符串的位置
        unordered_map<string,int>mp;
        for(int i = 0; i < n ; i++){
            mp[words[i]] = i+1;
        }

        for(int i = 0 ; i < n ; i++){
            if(words[i].size() >= 2){
                for(int j = 0;j < words[i].size();j ++){
                    string str = words[i].substr(0,j) + words[i].substr(j+1,words[i].size() - j);
                    if(mp[str])dp[i] = max(dp[mp[str] - 1]+1,dp[i]);
                }
            }
            mx = max(dp[i],mx);
        }
        return mx;
    }

};
```





### 13、统计构造好字符串的方案数量

动态规划求前缀和就行了 然后记得会超出正常范围  加一个偏移量

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114090218.png)

```cpp
class Solution {
public:
    int countGoodStrings(int low, int high, int zero, int one) {
         int e = 1e9+7;
         long long  dp[high+1];
         memset(dp,0,sizeof(dp));
         dp[0] = 0;
         for(int i = 1; i <= high ; i ++){
             if(i - zero>=0)dp[i] += (+dp[i - zero] + 1)%e;
             if(i - one >=0)dp[i] += (dp[i - one] + 1)%e;
         }
         return (dp[high]  - dp[low - 1] +e)%e;
    }
};
```





### 14、回文字符串个数

用两个三维数组 f(i)(j)(k)  表示 下标为i的位置  前面有多少个jk   以及后面多少个kj   

求出前缀和后缀

最后两个相乘

f(i)(j)(k) = f(i - 1)(j)(k)  还要计算当前下标可以和 0 - 9 构成多少对

所以还要相加

从后到前也是一样

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221127035541.png)

```cpp
const int N = 10010,e = 1e9+7;
int  pre[N][10][10],last[N][10][10];
class Solution {
public:
    int countPalindromes(string s) {
        int n = s.size();
        int cnt[10] = {0};
        memset(pre,0,sizeof pre);
        memset(last,0,sizeof last);
        for(int i = 1 ; i <= n ; i ++){
           for(int j = 0 ;j < 10 ; j ++){
               for(int k = 0 ; k < 10 ;  k ++){
                   pre[i][j][k] = pre[i - 1][j][k];
               }
           }
           int c = s[i - 1] - '0';
           for(int w = 0 ; w < 10 ; w ++){
               pre[i][w][c] += cnt[w];
           }
           cnt[c] ++;
        }
       memset(cnt,0,sizeof cnt);

       for(int i = n ;i > 0 ; i --){
          for(int j = 0 ;j < 10 ; j ++){
               for(int k = 0 ; k < 10 ;  k ++){
                   last[i][j][k] = last[i + 1][j][k];
               }
           }
           int c = s[i - 1] - '0'; 
           for(int w = 0 ; w < 10 ; w++){
               last[i][c][w] += cnt[w];
           }
           cnt[c] ++;
      }
      int sum = 0;
      for(int i = 1 ; i <= n ; i ++){
          for(int j = 0 ;j  < 10 ; j ++){
              for(int k = 0 ; k < 10 ;  k ++){
                 sum = (sum + (long long)pre[i - 1][j][k] * last[i + 1][k][j])%e;
              }
          }
      }
      return sum;
    }
};
```



## 七、搜索(dfs,bfs)

### **1、缓存搜索(难)**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715114227.png" style="zoom:67%;" />

首先可以dfs记录每个点的最大深度，用vist来表示，如果下次访问到了这个点。，直接return回去就行了

```java
class Solution {
    int [][]vist;
    public int dfs(int[][]matrix,int i,int j,int flag ){
        if(i==matrix.length||j==matrix[0].length||i<0||j<0)return 0;
        if(flag>=matrix[i][j]){
            return 0;
        }
        if(vist[i][j]!=0)return vist[i][j];
        int left=dfs(matrix,i+1,j,matrix[i][j]);
        int right=dfs(matrix,i-1,j,matrix[i][j]);
        int up=dfs(matrix,i,j+1,matrix[i][j]);
        int dowm=dfs(matrix,i,j-1,matrix[i][j]);
        vist[i][j]=Math.max(Math.max(left,right),Math.max(up,dowm))+1;
        return vist[i][j];
    }
    public int longestIncreasingPath(int[][] matrix) {
        vist=new int[matrix.length][matrix[0].length];
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                dfs(matrix,i,j,-1);
            }
        }
        int max=1;
        for(int i=0;i<matrix.length;i++){
            for(int j=0;j<matrix[0].length;j++){
                if(vist[i][j]>max)max=vist[i][j];
            }
        }
        return max;
    }
}
```



### 2、三幂次方之和

直接暴力好吧



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818011051.png)

```java
class Solution {
    int flag=0;
    int num;
    public boolean checkPowersOfThree(int n) {
        num=n;
        List<Integer>list=new ArrayList<>();
        int sum=1;
        //把所有可能数字记录下来
        while(sum<=n){
            list.add(sum);
            sum=sum*3;
        }
        dfs(n,-1,list);
        return flag==1;
    }
    public void dfs(int sum,int n,List<Integer>list){
        // System.out.println(sum);
        if(sum<0)return;
        if(flag==1)return;
        if(sum==0){
            flag=1;
            return;
        }
        for(int i=n+1;i<list.size();i++){
            dfs(sum-list.get(i),i,list);
        }
    }
```





### **3、八数码(难，bfs)**

思路，我们可以把初始状态看成第一个结点，把我们想要的状态看成第二个结点，然后可以变化的状态看成当前状态到变化状态的一条边，也就是形成图，然后用bfs处理，这里字符串处理要注意。

把一个3*3的矩阵看成一个字符串  然后向四个方向进行搜索  和bfs一样

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820175828.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <queue>
#include <cmath>
#include <map>
using namespace std;
map<string,int>m;
queue<string>q;
int h1[4] = {1,0,-1,0};
int h2[4] = {0,-1,0,1};
string t = "12345678x";
int dfs(string str){
    q.push(str);
    m[str] = 0;
    int flag = 0;
    while(q.size() > 0){
      
        string s = q.front();
        q.pop();
        if(t == s){
            return m[s];
        }
        int dis = m[s];
        int index = s.find('x');
        int a = index/3;
        int b = index%3;
        
        for(int i = 0 ; i < 4 ; i ++){
            int c = a + h1[i];
            int d = b + h2[i];
            //cout<<c<<" "<<d<<endl;
            if(c < 0 || d < 0 || c >= 3 || d >= 3)continue;
            //转换为一维
            int index2 = c*3+d;
            swap(s[index2],s[index]);
          
            //第一次遍历就入队
            if(m.count(s) == 0){
              q.push(s);
              m[s] = dis + 1;
            }
            swap(s[index2],s[index]);
        }
    }
    return -1;
}
int main(){
    string s;
    string c;
    for(int i = 0 ; i < 9 ;  i++){
        cin>>c;
        s += c;
    }
   // cout<<s<<endl;
    cout<<dfs(s)<<endl;
    return 0;
}
```





```java
import java.util.*;
public class Main{
    static  HashMap<String,Integer>map;
    static Queue<String>queue;
    static int[]h1={1,-1,0,0};
    static  int[]h2={0,0,-1,1};
    static  String end="12345678x";
    public  static  int dfs(String start){
        queue.add(start);
        map.put(start,0);
        while(queue.size()>0){
            String str=queue.poll();
            // System.out.println(str);
            int dis=map.get(str);
            if(str.equals(end))return dis;
            int flag=0;
            //找出x下标
            for(int i=0;i<str.length();i++){
                if(str.charAt(i)=='x'){
                    flag=i;
                    break;
                }
            }
            //映射成二维矩阵
            int x=flag/3;
            int y=flag%3;
            //交换
            StringBuffer help=new StringBuffer(str);
            for(int i=0;i<4;i++){
                int a=x+h1[i];
                int b=y+h2[i];
                if(a<3&&a>=0&&b<3&&b>=0){

                    int c=a*3+b;//映射成一维数组下标
                    char d=help.charAt(c);
                    help.setCharAt(flag,d);
                    help.setCharAt(c,'x');
                    String s=help.toString();
                    if(map.containsKey(s)==false){
                        map.put(s,dis+1);
                        queue.add(s);
                    }
                    help=new StringBuffer(str);
                }
            }
        }
        return -1;
    }

    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        map=new HashMap<>();
        queue=new LinkedList<>();
        String s=in.nextLine();
        String start="";
        //处理字符串
        for(int i=0;i<s.length();i++){
            if(s.charAt(i)!=' ')start+=s.charAt(i);
        }
        System.out.println(dfs(start));
    }
}
```



### 4、感染树

直接建图，bfs

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821130316.png)

```java
class Solution {
    //建图
    int []tree=new int[100010];
    int []dist=new int[100010];
    int []value=new int[200010];
    int []next=new int[200010];
    int index=0;
    int []vist=new int[100010];
    public void dfs(TreeNode root){
        if(root==null)return;
        if(root.left!=null){
            insert(root.val,root.left.val);
            insert(root.left.val,root.val);
            dfs(root.left);
        }
        if(root.right!=null){
            insert(root.val,root.right.val);
            insert(root.right.val,root.val);
            dfs(root.right);
        }
    }
    public void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }
    public int amountOfTime(TreeNode root, int start) {
        for(int i=0;i<100010;i++){
            tree[i]=-1;
        }
        dfs(root);
        Queue<Integer>queue=new LinkedList<>();
        queue.add(start);
        int max=0;
        dist[start]=0;
        vist[start]=1;
        while(queue.size()>0){
            int size=queue.size();
            while(size>0){
                size--;
                int k=queue.poll();
                for(int i=tree[k];i!=-1;i=next[i]){
                    int j=value[i];
                    if(vist[j]==0){
                        vist[j]=1;
                        queue.add(j);
                        if(dist[j]<dist[k]+1){
                            dist[j]=dist[k]+1;
                        }
                        max=Math.max(max,dist[j]);
                    }
                }
            }
        }
        return max;
    }
}
```







### 5、农场

因为每一次从农场的左上角开始，所以每次只要记录pair的值就可以了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908174645.png)



```cpp
class Solution {
    public:
    vector<vector<int>>v1;
    vector<vector<int>> findFarmland(vector<vector<int>>& land) {
        int n=land.size();
        int m=land[0].size();
        vector<int>help;
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                pair<int,int>a(-1,-1);
                if(land[i][j]==1){
                    help.clear();
                    help.push_back(i);
                    help.push_back(j);
                    dfs(land,a,i,j);
                    help.push_back(a.first);
                    help.push_back(a.second);
                    v1.push_back(help);
                }
            }
        }
        return v1;
    }
    void dfs(vector<vector<int>>&land,pair<int,int>&p,int i,int j){
        if(i<0||j<0||i>=land.size()||j>=land[0].size()||land[i][j]==0)return;
        land[i][j]=0;
        if(p.first==-1||i>=p.first&&j>=p.second){
            p.first=i;
            p.second=j;
        }
        dfs(land,p,i+1,j);
        dfs(land,p,i-1,j);
        dfs(land,p,i,j+1);
        dfs(land,p,i,j-1);
    }
};
```





### 6、最短的桥

思路：

先用dfs把一个倒岛标记为1

然后全部放入队列

然后在bfs找另一个岛

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221026123401.png)

```cpp
class Solution {
public:
    queue<pair<int,int>>q;
    int step = 0;
    int a[4] = {1,0,-1,0};
    int b[4] = {0,1,0,-1};
    void dfs(vector<vector<int>>&grid,int i,int j){
        if(i < 0||j < 0||i >= grid.size() || j >= grid[0].size() || grid[i][j] != 1)return ;
        q.push(pair(i,j));
        grid[i][j] = 2;
        dfs(grid,i + 1,j);
        dfs(grid,i - 1,j);
        dfs(grid,i,j + 1);
        dfs(grid,i,j - 1);
    }

    void find(vector<vector<int>>&grid){
      while(q.size() > 0){
         int size = q.size();
       while(size > 0){
         size --;
         pair<int,int>&p = q.front();
         int c = p.first;
         int d = p.second;
         q.pop();
         for(int i = 0; i < 4 ;i ++){
             int x = c + a[i];
             int y = d + b[i]; 
             if(x < 0 || y < 0 || x >= grid.size() || y >= grid[0].size() || grid[x][y] == 2)continue;
             if(grid[x][y] == 1)return;
             grid[x][y] = 2;
             q.push(pair(x,y));
         }
       }
       step ++ ;
      }
    }
    int shortestBridge(vector<vector<int>>& grid) {
        int  n = grid.size();
        int m = grid[0].size();
        //将第一个岛屿标记
        int flag = 0;
        for(int i = 0; i < n ; i ++){
            for(int j = 0 ; j < m ; j ++){
                if(grid[i][j] == 1){
                    dfs(grid,i,j);
                    flag = 1;
                    break;
                }
            }
            if(flag == 1)break;
        }
       find(grid);
       return step;
    }
};
```





### 7、树的重心



![微信截图_20230103033220](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230103033220.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

int tree[100010];
int ne[200010];
int e[200010];
int vist[100010];
int ids = 0;
int mn = 100000000;
int n;
void insert(int a,int b){
    e[ids] = b;
    ne[ids] = tree[a];
    tree[a] = ids++;
}

int dfs(int u){
    vist[u] = 1;
    int res = 0;
    int sum = 1;
    for(int i = tree[u];i!=-1;i = ne[i]){
        int j = e[i];
        if(vist[j] == 0){
            int s = dfs(j);
            sum += s;
            res =  max(res,s);
        }
    }
    res = max(res, n - sum);
    mn = min(res,mn);
    return sum;
}

int main(){
    for(int i = 0 ; i < 100010 ; i ++)tree[i] = -1; 
    cin>>n;
    for(int i = 0; i  < n ; i ++){
        int a,b;
        cin>>a>>b;
        insert(a,b);
        insert(b,a);
    }
    dfs(1);
    cout<<mn<<endl;
}
```







## 八、二分

### **1、寻找大于等于某个数的最左，或者小于等于某个值的最右，左神讲过，用二分**

比如 0 1  1 1 1 1 1 1 2

找出最左边和最右边的1

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715161333.png" style="zoom:67%;" />

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715161345.png" style="zoom:50%;" />

```java
class Main222{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int q=in.nextInt();
        int l;
        int r;
        int mid;
        int index1;
        int index2;
        int []num=new int[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextInt();
        }
        int target;
        for(int i=0;i<q;i++){
            target=in.nextInt();
            l=0;
            r=n-1;
            index1=-1;
            index2=-1;
            //找最左边不小于目标值的下标
            while(l<=r){
                mid=(r+l)/2;
                if(num[mid]>=target){
                    index1=mid;
                    r=mid-1;
                }else l=mid+1;
                System.out.println(index1);
            }
            l=0;
            r=n-1;
            //找最右边小于等于目标值的下标
            while(l<r){
                mid=(r+l)/2;
                if(num[mid]<=target){
                    index2=mid;
                    l=mid+1;
                }else r=mid-1;
            }
            if(index1>=0&&index1<n&&index2>=0&&index2<n&&num[index1]==target&&num[index2]==target){
                System.out.println(index1+" "+index2);
            }else {
                System.out.println(-1+" "+-1);
            }
        }
    }
}
```



### **2、高精度**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807044900.png)



```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        double n=in.nextDouble();
        double l=-10000;
        double r=10000;
        while(r-l>0.00000001){
            double mid=(l+r)/2;
            if(mid*mid*mid<n)l=mid;
            else r=mid;
        }
        System.out.printf("%6f",l);
    }
}
```



### 3、少的数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831182729.png)



```java
class Solution {
    public:
    int missingNumber(vector<int>& nums) {
        int n=nums.size();
        int l=0;
        int r=n;
        while(l<r){
            int mid=(l+r)/2;
            if(nums[mid]!=mid)r=mid;
            else l=mid+1;
        }
        return l;
    }
};
```



### 4、平分和

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220902211542.png)

```java
class Solution {
    public:
    bool isPerfectSquare(int num) {
        int pre=0;
        int last=num;
        int flag=0;
        while(pre<=last){
            int mid=(pre+last)/2;
            if((long long)mid*mid>num)last=mid-1;
          else if((long long)mid*mid<=num){
                pre=mid+1;
                flag=mid;
            }
        }
        return (long long)flag*flag==num;
    }

};
```



### **5、最长上升子序列(难)**

这里构造一个上升的数组，第i个元素是长度为i的上升子序列的末尾

每次遍历，在这个数组中找到小于这个数的最大值，然后更新数组，还有更新一下最长的max

这里用二分处理

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220910210600.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        int a[100010];
        int q[100010];
        int main()
        {
           int n;
           cin>>n;
           for(int i=0;i<n;i++){
              cin>>a[i];
           }
          //最大长度
           int len=0;
           for(int i=0;i<n;i++){
             int  l=0;
             int  r=len;
             while(l<r){
                int mid=(l+r)/2+1;
                if(a[i]>q[mid])l=mid;
                else {
                  r=mid-1;
                 }
          }
            len=max(len,r+1);
            q[r+1]=a[i];
         }
            cout<<len;
            return 0;
        }
```



### 6、旋转数组

找出中间值，然后和最后一个元素比较

如果大于他，那么最小值肯定在mid右边

如果小于，最小值肯定在左边

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220914154309.png)



```cpp
class Solution {
    public:
    int findMin(vector<int>& nums) {
        int flag=nums[nums.size()-1];
        int l=0;
        int r=nums.size()-1;
        while(l<r){
            int mid=(l+r)/2;
            if(nums[mid]<flag)r=mid;
            else  l=mid+1;
        }
        return nums[l];
    }
};
```





### 7、结果不超过最大值最小除数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220925202913.png)



```cpp
class Solution {
    public:
    int smallestDivisor(vector<int>& nums, int threshold) {
        int l=1;
        int r=0;
        int flag=0;
        for(int i=0;i<nums.size();i++)r=max(r,nums[i]);
        while(l<=r){
            int mid=(l+r)/2;
            int total=0;
            for(int k:nums){
                if(k%mid!=0)total+=k/mid+1;
                else total+=k/mid;
            }

            if(total>threshold){
                l=mid+1;
            }else {
                flag=mid;
                r=mid-1;
            }
        }
        return flag;
    }
};
```



### **8、匹配字符串序列**

思路：

记录每一个字符出现的次数

然后匹配的时候用二分

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221117035610.png)

```cpp
class Solution {
public:
    int numMatchingSubseq(string s, vector<string>& words) {
       int n = s.size();
       int m = words.size();
       vector<vector<int>>v(26);
       //存下字符出现的下标
       for(int i = 0 ;i < n ; i ++){
          v[s[i] - 'a'].push_back(i);
       }
       int sum = 0 ;
       for(int i = 0 ; i < words.size() ; i ++){
           int c = words[i].size();
           if(c > n)continue;
           int flag = c ;
           int count = 0 ;
           int w = -1;
          
           for(int j = 0 ;j <c ; j ++){
               auto &h  = v[words[i][j] - 'a'];
               if(h.size() == 0)break;
               if(h[h.size() - 1] < w)break;
               int l = 0;
               int r = h.size() - 1;
               int c = 0;
               while(l <= r){
                   int mid = (l + r)/2;
                
                   if(h[mid] >w){
                       c =h[mid];
                       r = mid - 1;
                   }else if(h[mid] <= w)l = mid + 1;
               }
               if(c <= w)continue;
               w = c;
               count ++;
           }
           if(count == words[i].size())sum ++;
       }
       return sum;
    }
};
```





### **9、最大化城市供电数目**  

> 思路
>
> 最小化最大值和最大化最小值问题用贪心来解决
> 先求前缀和，求出每个城市初始有多少电
> 然后找出最小值，这个最小值就是二分的左端点，然后加上k就是二分的右端点
> 然后我们就开始二分，每次希望一个值，判断他是否可用满足
>
> 二分函数
>
> power就是每个城市的初始供电量
> 现在我们有k做电站，看看能不能分配给power  使得最小值为mid
> need是当前需要的总电站，如果大于k说明不能满足，直接返回false
> 由于贪心，我们对于i来说，要在i + r位置修改，这样子覆盖i这个边界
>
> diff是差分数组，c是前缀和，代表当前城市加了几个电站，用mid减去c和原本的power[i] 就是目前还要几个
> 如果是负数说明满足最小值mid  否则就要让need加上他们的差，然后差分数组起始位置加上m ,差分数组i+r*2 + 1位置减去m
> 


    ```c++
     bool check(long long  mid,vector<long long>&power,int r, int k){
            vector<long long>diff(n,0);
            long long c = 0;
            long long  need = 0;
            for(int i = 0 ; i < n ; i ++){
                //c是当前城市增加的电站数量
                c += diff[i];
                long long m = mid - c - power[i];
                if(m > 0){
                    need += m;
                    //超过了所能建造的电站
                    if(need > k)return false;
                    //由于当前建造了m个电站所以差分数组起始位置要加上m
                    c += m;
                    //新修的电站影响的范围要把后面的减去
                    if(i + r*2 + 1 < n)diff[i + r*2 + 1] -= m;
                }
            }
          return true;
        }
    ```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230115191401.png)

代码

```c++
++class Solution {
public:  
    int n;
    bool check(long long  mid,vector<long long>&power,int r, int k){
        vector<long long>diff(n,0);
        long long c = 0;
        long long  need = 0;
        for(int i = 0 ; i < n ; i ++){
            //c是当前城市增加的电站数量
            c += diff[i];
            long long m = mid - c - power[i];
            if(m > 0){
                need += m;
                //超过了所能建造的电站
                if(need > k)return false;
                //由于当前建造了m个电站所以差分数组起始位置要加上m
                c += m;
                //新修的电站影响的范围要把后面的减去
                if(i + r*2 + 1 < n)diff[i + r*2 + 1] -= m;
            }
        }
      return true;
    }

    long long maxPower(vector<int>& stations, int r, int k) {
        n = stations.size();
        vector<long long>sum(n+1,0);
        vector<long long >power(n,0);
        //计算初始每个城市有多少电用前缀和
        for(int i = 1 ; i <= n ; i ++){
            sum[i] = sum[i - 1] + stations[i - 1];
        }
        long long  left = sum[n];
        for(int i = 0 ; i < n ; i ++){
            power[i] = sum[min(i + r + 1,n)] - sum[max(i - r,0)];
            left = min(left,power[i]);
        }
        
        long long  right = (long long )(left + k + 1);
        while(left + 1 < right){
            long long  mid = (right - left)/2+left;
            if(check(mid,power,r,k))left = mid;
            else right  = mid;
        }
        return left;
    }
};
```







## 九、贪心‘

#### 1、公交车

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220716073406.png)

超级恶心一道题

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        Arrays.sort(buses);
        Arrays.sort(passengers);
        int anx=0;
        Queue<Integer>queue=new LinkedList<>();
        HashSet<Integer>set=new HashSet<>();
        for(int k:passengers){
            queue.add(k);
            set.add(k);
        }

        for(int i=0;i<buses.length;i++){
            int c=capacity;//座位数
            int sum=buses[i];
            while(c>0&&queue.size()>0&&queue.peek()<=sum){
                int k=queue.poll();
                c--;
                if(set.contains(k-1)==false)anx=k-1;

            }
            if(c>0&&set.contains(sum)==false)anx=sum;
        }
        return anx;
    }
}
```



解法二也是类似贪心，不过不用set集合，节省了时间

```java
class Solution {
    public int latestTimeCatchTheBus(int[] buses, int[] passengers, int capacity) {
        int n1=buses.length;
        int n2=passengers.length;
        Arrays.sort(buses);
        Arrays.sort(passengers);
        int c;
        int max=0;
        int sum=0;
        int pre=0;
        int p=0;
        for(int i=0;i<n1;i++){
            sum=buses[i];
            c=0;
            //符合一下条件，才能上去，这个乘客
            while(p<n2&&passengers[p]<=sum&&c<capacity){
                if(p==0||p>0&&passengers[p]-1!=passengers[p-1]){
                    max=Math.max(max,passengers[p]-1);
                }
                c++;
                p++;
            }
            if((c<capacity)&&(p==0||p>0&&passengers[p-1]!=sum)){
                max=sum;
            }
        }
        return max;
    }
}
```



#### 2、区间合并

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719043613.png" style="zoom:67%;" />



具体思路是将左端点从左到右排序，然后每一次遍历一个组合的时候，如果新元素的左端点在当前区间之间，那么判断当前元素的右端点是否大于当前区间的右端点，更新当前区间的右端点，如果新元素左端点不在此区间，那么sum++,并且更新右端点

```java
class Main2222{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int sum=0;
        List<int[]>list=new ArrayList<>();
        for(int i=0;i<n;i++){
            int k1=in.nextInt();
            int k2=in.nextInt();
            int []a=new int[2];
            a[0]=(k1);
            a[1]=(k2);
            list.add(a);
        }
        Sort sort=new Sort();
        Collections.sort(list,sort);
        for(int[]a:list){
            System.out.println(Arrays.toString(a));
        }
        int last=list.get(0)[1];
        int i=1;
        while(i<n){
            int k1=list.get(i)[0];
            int k2=list.get(i)[1];
            if(k1<=last){
                if(last<=k2)last=k2;
            }else if(k1>last){
                last=k2;
                sum++;
            }
            i++;
            System.out.println(last);
        }
        System.out.println(sum+1);
    }
}
class Sort implements Comparator<int[]>{


    @Override
    public int compare(int[] o1, int[] o2) {
        return Integer.compare(o1[0],o2[0]);
    }
}
```



#### 3、加油站

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725171110.png)

贪心，如果总的加油不能大于消耗，直接return -1;



```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int n=gas.length;
        int sum=0;
        int rest=0;
        int index=0;
        for(int i=0;i<n;i++){
            rest=rest+gas[i]-cost[i];
            sum=sum+gas[i]-cost[i];
            if(sum<0){
                index=i+1;
                sum=0;
            }
        }
        if(rest<0)return -1;
        return index;
    }
}
```



## **十、定制排序(重要)**

### 1、定制排序

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220717132349.png)

```java
 public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {
        int n=nums.length;
        int m=queries.length;
        sort []sort=new sort[n];
        int []help=new int[m];
        for(int i=0;i<m;i++){
            int k=queries[i][0];
            int trim=queries[i][1];
            for(int j=0;j<n;j++){
               if(nums[j].length()<trim){
                   sort[j]=new sort("0",j);
               }else {
                   sort[j]=new sort(nums[j].substring(nums[j].length()-trim),j);
               }
            }
           // System.out.println(Arrays.toString(sort));
            Arrays.sort(sort);
            help[i]=sort[k-1].age;
        }
        return help;
    }
}
class sort implements Comparable<sort>{
    String s;
    int age;

    public sort(String s, int age) {
        this.s = s;
        this.age = age;
    }

    @Override
    public int compareTo(sort o) {
        return this.s.compareTo(o.s);
    }

    @Override
    public String toString() {
        return "sort{" +
                "s='" + s + '\'' +
                ", age=" + age +
                '}';
    }
}
```

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730213141.png)

### 2、卡牌

```java
import java.util.*;
public class Main{
    public static void  main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []s=new int[n+1];
        int min=1;
        int sum=0;
        count1 []count1=new count1[n+1];
        TreeSet<count1>set=new TreeSet<>();
        for(int i=1;i<=n;i++){
            count1[i]=new count1(i,0);
            set.add(count1[i]);
        };
        for(int i=0;i<m;i++) {
            int x=in.nextInt();
            set.remove(count1[x]);
            count1[x].value=count1[x].value+1;
            set.add(count1[x]);
            if(set.first().value-sum<1){
                System.out.print(0);
            }else {
                System.out.print(1);
                sum++;
            }
        }
    }
}
class count1 implements Comparable<count1>{
    public  int index;
    public  int value;

    public count1(int index, int value) {
        this.index = index;
        this.value = value;
    }

    public count1() {
    }


    @Override
    public int compareTo(count1 o) {
        if(this.value!=o.value)
            return Integer.compare(this.value,o.value);
        return Integer.compare(this.index,o.index);
    }

}
```



### 3、根据身高重建队列

思路：首先按照身高从大到小，然后如果身高相同就按照k从小到大依次加入集合

因为先把大的放后，小的不会影响大的，而且先按照k小的放置，这样子不会混乱

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802013429.png)

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        help p=new help();
        Arrays.sort(people,p);
        List<int[]>list=new ArrayList<>();
        for(int []a:people){
            list.add(a[1],a);
        }
        for(int i=0;i<people.length;i++){
            people[i]=list.get(i);
        }
        return people;
    }
}

class help implements Comparator<int[]>{
    @Override
    public int compare(int[] o1, int[] o2) {
        if(o1[0]!=o2[0])return Integer.compare(o2[0],o1[0]);
        return Integer.compare(o1[1],o2[1]);
    }
}
```





### 4、权重排序

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819014405.png)

```java
import java.util.*;
class Solution {
    public int getKth(int lo, int hi, int k) {
        List<p2>list=new ArrayList<>();
        for(int i=lo;i<=hi;i++){
            list.add(new p2(i,get(i)));
        }
        Collections.sort(list);
        return list.get(k-1).value;
    }
    public static int  get(int n){
        if(n==1)return 0;
        if(n%2==1)return get(n*3+1)+1;
        return get(n/2)+1;
    }
}

class  p2 implements Comparable<p2>{
    int value;
    int flag;

    public p2(int value, int flag) {
        this.value = value;
        this.flag = flag;
    }

    @Override
    public int compareTo(p2 o) {
        if(this.flag!=o.flag)return Integer.compare(this.flag,o.flag);
        return Integer.compare(this.value,o.value);
    }
}
```



### 5、标签

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815235856.png)

```java
class Solution {

    public int largestValsFromLabels(int[] values, int[] labels, int numWanted, int useLimit) {
        //构建大顶堆
        PriorityQueue<node> queue = new PriorityQueue<>(new com());
        for(int i=0;i<values.length;i++){
            queue.add(new node(values[i],labels[i]));
        }
        int sum=0;
        int count=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        while(count<numWanted){
            node nodes=queue.poll();
            //System.out.println(nodes);
            if(nodes==null)break;
            int value=nodes.value;
            int lab=nodes.lab;
            if(map.get(lab)==null||map.get(lab)<useLimit){
                sum+=value;
                count++;
                if(map.get(lab)==null)map.put(lab,1);
                else map.put(lab,map.get(lab)+1);
            }
        }
        return sum;
    }
}

class com implements  Comparator<node>{

    @Override
    public int compare(node o1, node o2) {
        if(o1.value!=o2.value)
            return o2.value-o1.value;
        return o1.lab-o2.lab;
    }
}
class node{

    public int value;
    public  int lab;

    public node(int value, int lab) {
        this.value = value;
        this.lab = lab;
    }


}
```



### **6、数字容器系统**(难)

思路：

就是两个map

一个对应下标和值的关系

一个对应值的下标的关系

因为一个值可能多个下标

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908183023.png)



```cpp
class NumberContainers {
    //自动排序set
    map<int,int>map1;
    map<int,set<int>>map2;
    public:
    NumberContainers() {

    }

    void change(int index, int number) {
        if(map1.count(index)!=0){
            int pre=map1[index];
            map2[pre].erase(index);
        }map1[index]=number;
        map2[number].insert(index);
    }

    int find(int number) {
        set<int>&s=map2[number];
        if(s.size()<=0)return -1;
        return *(s.begin());
    }
};
```





十一、回溯

1、组合加减枝

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718035907.png)

每一次回溯，记得如果list1的数加上w后面的数小于k时候，代表后面不能凑齐k个数，可以直接返回了

```java
class Solution {
    List<List<Integer>>list1;
    public List<List<Integer>> combine(int n, int k) {
        list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        dfs(list2,n,k,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int n,int k,int w){
        if(n-w+list2.size()<k)return ;
        if(list2.size()==k){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=w+1;i<=n;i++){
            list2.add(i);
            dfs(list2,n,k,i);
            list2.remove(list2.size()-1);
        }
    }
}
```



## 十一双指针

### **1、最长连续序列(双指针加哈希)**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220718091005.png" style="zoom:50%;" />

具体思路是来两个指针pre, last last往后走，如果map存在Num[last],并且map.get(num[last])>=pre (只要在pre到last之间重复的元素才不能添加进来)，更新max,让pre=num[last]在的位置，更新map 中Num[last]的值，last++;

比如 1  0 2 3 4 5 6 2 9 10

pre 等于0  last=7时候，2重复，并且map中的2下标在pre和last之间，所以更新max,让pre等于2的下标加一，并且让map中的2更新为7，然后last++;

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int pre=0;
        int last=1;
        int [] nums=new int[n];
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            nums[i]=in.nextInt();
        }
        int max=1;
        map.put(nums[0],0);
        while(last<n){
            if(map.containsKey(nums[last])==true&&map.get(nums[last])>=pre){
                max=Math.max(last-pre,max);
                int k=map.get(nums[last]);
                if(k+1>=n)break;
                map.put(nums[last],last);
                last++;
                pre=k+1;
            }else{
                max=Math.max(max,last-pre+1);
                map.put(nums[last],last);
                last++;
            }
        }
        System.out.println(max);
    }
}
```

解法2

每一次添加Num[i]的时候

s[num[i]]++;

如果大于一，说明有重复，让j++,并且同时让s[nums[j]]--;

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int pre=0;
        int last=0;
        int [] nums=new int[n];
        int []s=new int[100001];
        int max=0;
        for(int i=0;i<n;i++){
            nums[i]=in.nextInt();
        }
        while(last<n){
            s[nums[last]]++;
            while(s[nums[last]]>1){
                s[nums[pre]]--;
                pre++;
            }
            max=Math.max(max,last-pre+1);
            last++;
        }
        System.out.println(max);
    }
}
```

### 2、字符串版本

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220726031318.png)



```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        if(s.length()==0)return 0;
        int []num=new int[128];
        int last=0;
        int pre=0;
        int sum=1;
        while(last<s.length()){
            int k=s.charAt(last);
            num[k]++;
            while(num[s.charAt(last)]>1){
                num[s.charAt(pre)]--;
                pre++;
            }
            sum=Math.max(last-pre+1,sum);
            last++;
        }
        return sum;
    }
}
```

### **3、两个数组**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220719033955.png" style="zoom:67%;" />

双指针，让一个指针在前，一个在后，每次让j往前移动

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int x=in.nextInt();
        int []a=new int[n];
        int []b=new int[m];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        for(int j=0;j<m;j++){
            b[j]=in.nextInt();
        }
        int sum=0;
        int pre=0;
        int last=m-1;
        while(pre<n){
            while(b[last]+a[pre]>x)last--;
            if(b[last]+a[pre]==x){
                System.out.println(pre+" "+last);
                break;
            }
            pre++;
        }
    }
}
```



### 4、重叠部分

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220727011347.png)



```java
class Solution {
    public int[] intersect(int[] nums1, int[] nums2) {
        List<Integer> list=new ArrayList<>();
        int index1=0;
        int index2=0;
        Arrays.sort(nums1);
        Arrays.sort(nums2);
        while(index1<nums1.length&&index2<nums2.length){
            if(nums1[index1]<nums2[index2]){
                index1++;
            }else if(nums1[index1]>nums2[index2]){
                index2++;
            }else {
                list.add(nums1[index1]);
                index1++;
                index2++;
            }
        }
        int []a=new int[list.size()];
        for(int i=0;i<list.size();i++){
            a[i]=list.get(i);
        }
        return a;
    }
}
```



### 5、字符二进制

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220817012456.png)

```java
class Solution {
    int sum;
    public boolean hasAllCodes(String s, int k) {
        HashSet<String>set=new HashSet<>();
        int left=0;
        int right=k;
        while(right<=s.length()){
            set.add(s.substring(left,right));
            left++;
            right++;
        }
        return set.size()==Math.pow(2,k);
    }
}
```



### 6、下标最大



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820150819.png)

```java
class Solution {
    public int maxDistance(int[] nums1, int[] nums2) {
        int n1=nums1.length;
        int n2=nums2.length;
        int i=0;
        int j=0;
        int max=0;
        while(i<n1&&j<n2){
            if(nums1[i]>nums2[j])i++;
            else {
                max=Math.max(j-i,max);
                j++;
            }
        }
        return max;
    }
}
```



### **7、摘苹果**

双指针，数组记录每一个数的大小，然后两个指针滑动

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821171442.png)

```java
class Solution {
    public int totalFruit(int[] fruits) {
        HashSet<Integer>set=new HashSet<>();
        int []num=new int[100001];
        int n=fruits.length;
        if(n==1)return 1;
        if(n==2)return 2;
        set.add(fruits[0]);
        set.add(fruits[1]);
        int left=0;
        int right=2;
        int max=2;
        num[fruits[0]]++;
        num[fruits[1]]++;
        while(right<n){
            if(set.size()>=2&&set.contains(fruits[right])==false){
                num[fruits[left]]--;
                if(num[fruits[left]]==0)
                    set.remove(fruits[left]);
                left++;
            }else {
                set.add(fruits[right]);
                num[fruits[right]]++;
                max=Math.max(right-left+1,max);
                right++;
            }
        }
        return max;
    }
}
```



### 8、找k个最接近的元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220825144800.png)

第一种方法，删除两边最大元素

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        int n=arr.length;
        int l=0,r=n-1;
        for(int i=0;i<n-k;i++){
            if(Math.abs(arr[l]-x)<=Math.abs(arr[r]-x))r--;
            else l++;
        }
        List<Integer>list=new ArrayList<>();
        for(int i=l;i<=r;i++){
            list.add(arr[i]);
        }
        return list;
    }
}
```



第二种：二分

找到中间最接近的，然后往两边找

```java
class Solution {
    public List<Integer> findClosestElements(int[] arr, int k, int x) {
        Arrays.sort(arr);
        int n=arr.length;
        int left=0;
        int right=n-1;
        int index=0;
        while(left<right){
            int mid=(left+right)/2;
            if(arr[mid]>=x){
                right=mid;
            }else {
                left=mid+1;
            }
        }
        List<Integer>list=new ArrayList<>();
        int pre=left-1;
        int last=left;
        while(k>0){
            k--;
            if(pre<0)last++;
            else if(last>=n)pre--;
            else if(x-arr[pre]<=arr[last]-x)pre--;
            else last++;
        }
        for(int i=pre+1;i<last;i++)list.add(arr[i]);
        return list;
    }
}
```



### **9、长度为3的不同回文子串**

双指针从前往后枚举就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002234431.png)

```cpp
class Solution {
    public:
    int countPalindromicSubsequence(string s) {
        int n = s.size();
        int sum = 0;
        for(char i = 'a';i <= 'z'; i ++){
            int pre = 0;
            int last = s.size()-1;
            while(pre<n&&s[pre]!=i) pre ++;
            while(last>=0&&s[last]!=i) last --;
            if(last - pre<2)continue;
            set<char>st;
            for(int j = pre+1;j <last;j++){
                st.insert(s[j]);
            }
            sum += st.size();
        }
        return sum;
    }
};
```

## **十二、回溯**

### 1、组合

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725171556.png)

可以适当剪枝

```java
class Solution {
    List<List<Integer>>list1;
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        list1=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        Arrays.sort(candidates);
        dfs(list2,candidates,target,0,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int []candidates,int target,int sum,int n){
        if(n+1>candidates.length)return;
        if(sum==target){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=n;i<candidates.length;i++){
            if(candidates[i]+sum<=target){
                list2.add(candidates[i]);
                dfs(list2,candidates,target,sum+candidates[i],i);
                list2.remove(list2.size()-1);
            }
        }
    }
}
```

### **2、组合剪枝**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220725172013.png" style="zoom:67%;" />

因为不能重复，而且数组中可能有重复的数字，所以先排序，如果canditates[i]==codnitates[i-1]并且i-1没有被访问，说明有重复动作，所以要减枝

```java
class Solution {
    public List<List<Integer>> combinationSum2(int[] candidates, int target) {
        List<List<Integer>>list=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        int []help=new int[candidates.length];
        Arrays.sort(candidates);
        dfs(list,list2,candidates,target,0,-1,help);
        return list;
    }
    public void dfs(List<List<Integer>>list,List<Integer>list2,int []candidates,int target
            ,int sum,int n,int []help){
        if(sum==target){
            list.add(new ArrayList<>(list2));
            return;
        }
        if(sum>target){
            return;
        }
        for(int i=n+1;i<candidates.length;i++){
            if(i>0&&candidates[i]==candidates[i-1]&&help[i-1]==0)continue;
            list2.add(candidates[i]);
            help[i]=1;
            dfs(list,list2,candidates,target,sum+candidates[i],i,help);
            if(list2.size()>0)list2.remove(list2.size()-1);
            help[i]=0;
        }
    }
}
```



### 3、回文数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220727205402.png)

```java
class Solution {
    List<List<String>>list1=new ArrayList<>();
    public List<List<String>> partition(String s) {
        List<String>list2=new ArrayList<>();
        dfs(s,list2,0);
        return list1;
    }
    public void dfs(String s,List<String>list2,int n){
        if(n>=s.length()){
            list1.add(new ArrayList<>(list2));
            return;
        }
        for(int i=n;i<s.length();i++){
            String str=s.substring(n,i+1);
            if(judge(str)==true){
                list2.add(str);
                dfs(s,list2,i+1);
                list2.remove(list2.size()-1);
            }
        }
    }
    public boolean judge(String s){
        int pre=0;
        int last=s.length()-1;
        while(pre<=last){
            if(s.charAt(pre)!=s.charAt(last))return false;
            pre++;
            last--;
        }
        return true;
    }
}
```



### 4、子集(减枝)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220728154542.png)

```java
class Solution {
    int []vist;
    List<List<Integer>>list1=new ArrayList<>();
    public List<List<Integer>> subsetsWithDup(int[] nums) {
        vist=new int[nums.length];
        Arrays.sort(nums);
        List<Integer>list2=new ArrayList<>();
        dfs(list2,nums,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int []nums,int n){
        if(n>nums.length)return;
        list1.add(new ArrayList<>(list2));
        for(int i=n;i<nums.length;i++){
            if(i>0&&vist[i-1]==0&&nums[i-1]==nums[i])continue;
            vist[i]=1;
            list2.add(nums[i]);
            dfs(list2,nums,i+1);
            list2.remove(list2.size()-1);
            vist[i]=0;
        }
    }
}
```



### **5、减枝(set)难点**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220728214918.png)

这里我们不能用之前排序的减枝，因为这里顺序是不固定的，所以我们要用set  [1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]这是一个极端样例

每一层我们放一个set来记录每一层收入的点，在这一层中这一个点只能出现一次，因为第一次就可以把后面所以情况全部枚举出来，所以后面相同的值直接跳过

```java
class Solution {
    List<List<Integer>>list1=new ArrayList<>();
    public List<List<Integer>> findSubsequences(int[] nums) {
        List<Integer>list2=new ArrayList<>();
        int []vist=new int[nums.length];
        dfs(list2,nums,vist,-1000,0);
        return list1;
    }
    public void dfs(List<Integer>list2,int[]nums,int[]vist,int pre,int n){
        if(list2.size()>=2)list1.add(new ArrayList<>(list2));
        HashSet<Integer>set=new HashSet<>();
        for(int i=n;i<nums.length;i++){
            if(set.contains(nums[i]))continue;
            if(nums[i]>=pre){
                list2.add(nums[i]);
                set.add(nums[i]);
                dfs(list2,nums,vist,nums[i],i+1);
                list2.remove(list2.size()-1);
            }
        }
    }
}
```





### 6、机场回溯加字典排序

思路：用Map嵌套map  表示第一个点到其他点有几次，然后第二个map要用treemap，便于字典排序，因为有treemap如果集合塞满了就是最优解，回溯的目的是保证要有解

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220803023344.png)



```java
class Solution {
    List<String>list;
    HashMap<String,TreeMap<String,Integer>>map;

    public void dfs(int size){
        if(list.size()==size)return;
        //获取最后一个元素
        String s=list.get(list.size()-1);
        //最后一个元素有目的地
        if(map.get(s)!=null){
            var help=map.get(s);
            for(Map.Entry<String,Integer> set:map.get(s).entrySet()){
                if(set.getValue()>0){
                    // System.out.println(set.getKey());
                    list.add(set.getKey());
                    //System.out.println(set.getKey());
                    int count=set.getValue();
                    set.setValue(count-1);
                    dfs(size);
                    if(list.size()==size)return;
                    list.remove(list.size()-1);
                    set.setValue(count);
                }
            }
        }
    }

    public List<String> findItinerary(List<List<String>> tickets) {
        map=new HashMap<>();
        list=new ArrayList<>();
        for(List<String>k:tickets){
            String s1=k.get(0);
            String s2=k.get(1);
            if(map.get(s1)==null){
                TreeMap<String,Integer>map2=new TreeMap<>();
                map2.put(s2,1);
                map.put(s1,map2);
            }else{
                var map3=map.get(s1);
                if(map3.get(s2)==null){
                    map3.put(s2,1);
                }else {
                    map3.put(s2,map3.get(s2)+1);
                }

            }
        }
        //System.out.println(map);
        list.add("JFK");
        //所有的机票要用一次
        dfs(tickets.size()+1);
        return list;
    }
}
```



### 7、n皇后

有一个小技巧，可以用两个集合装横坐标和纵坐标的和与差

因为横坐标和纵坐标之和一样的两个点肯定在一条斜线上，

横坐标和纵坐标之差一样的点肯定也在一条斜线上

这样子优化查找效率

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220805225303.png)

```java
class Solution {
    int n;
    List<List<String>>list1;
    HashSet<Integer>set1;
    HashSet<Integer>set2;
    HashSet<Integer>set3;
    public List<List<String>> solveNQueens(int m) {
        set1=new HashSet<>();
        set2=new HashSet<>();
        set3=new HashSet<>();
        list1=new ArrayList<>();
        n=m;
        int[][]s=new int[n][n];
        dfs(s,0);
        return list1;
    }
    public void dfs(int[][]num,int count){
        //System.out.println(count);
        if(count==n){
            add(num);
            return;
        }
        for(int i=0;i<n;i++){
            if(judge(num,count,i)==true){
                num[count][i]=1;
                set1.add(count+i);
                set2.add(count-i);
                set3.add(i);
                dfs(num,count+1);
                set1.remove(count+i);
                set2.remove(count-i);
                set3.remove(i);
                num[count][i]=0;
            }

        }
    }
    public boolean judge(int [][]num,int i,int j){
        if(set3.contains(j)==true)return false;
        if(set1.contains(i+j)||set2.contains(i-j))return false;
        return true;
    }

    public void add(int[][]s){
        List<String> list2=new ArrayList<>();
        String w="";
        for(int i=0;i<n;i++){
            w="";
            for(int j=0;j<n;j++){
                if(s[i][j]==0)w=w+".";
                else w=w+"Q";
            }
            list2.add(w);
        }
        list1.add(list2);

    }
}
```

## 十三、栈



### 1、用栈实现队列

```java
class CQueue {
    Stack<Integer>stack1;
    Stack<Integer>stack2;
    public CQueue() {
        stack1=new Stack<>();
        stack2=new Stack<>();
    }

    public void appendTail(int value) {
        stack1.push(value);
    }

    public int deleteHead() {
        if(stack2.size()==0){
            while(stack1.size()!=0){
                stack2.add(stack1.pop());
            }
        }
        if(stack2.size()==0)return -1;
        return stack2.pop();
    }
}
```





### 2、最小堆栈

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220801063605.png)

```java
class MinStack {

   Stack<Integer>stack=new Stack();
   Stack<Integer>min=new Stack();
   public MinStack() {

   }

   public void push(int val) {
      stack.push(val);
      if(min.size()==0)min.push(val);
      else {
         if(val<=min.peek())min.push(val);
      }
   }

   public void pop() {
      int x=stack.pop();
      if(min.size()>0&&min.peek()==x)min.pop();
   }

   public int top() {
      return stack.peek();
   }

   public int getMin() {
      return min.peek();
   }
}
```



### **3、栈的输入输出顺序**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807062117.png)

```java
class Solution {
    public boolean validateStackSequences(int[] pushed, int[] popped) {
        int n=pushed.length;
        int left=0;
        int right =0;
        Stack<Integer>stack=new Stack<>();
        for(int i=0;i<n;i++){
            stack.push(pushed[i]);
            while(right<n&&!stack.isEmpty()&&stack.peek()==popped[right]){
                right++;
                stack.pop();
            }
        }
        return right==n;
    }
}
```









### 4、有效括号

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813213223.png)



```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character>stack=new Stack<>();
        int n=s.length();
        for(int i=0;i<n;i++){
            var a=s.charAt(i);
            if(a=='(')stack.push(')');
            else if(a=='{')stack.push('}');
            else if(a=='[')stack.push(']');
            else if(stack.size()==0||stack.peek()!=a)return false;
            else stack.pop();
        }
        return stack.size()==0;
    }
}
```

### 5、折扣(单调栈)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220901221854.png)



```c++
class Solution {
    public:
    vector<int> finalPrices(vector<int>& prices) {
        stack<int>s;
        int n=prices.size();
        vector<int>v(n);
        for(int i=n-1;i>=0;i--){
            while(s.size()>0&&s.top()>prices[i]){
                s.pop();
            }
            if(s.size()==0)v[i]=prices[i];
            else v[i]=prices[i]-s.top();
            s.push(prices[i]);
        }
        return v;
    }
};
```



### 6、删除重复项

思路：如果当前元素和上一个不同，堆栈加1这个元素

否则堆栈顶部加一

如果大小到了，删除字符串这K个元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220912033910.png)

```cpp
class Solution {
    public:
    string removeDuplicates(string s, int k) {
        int n=s.size();
        stack<int>st;
        for(int i=0;i<s.size();i++){
            if(i==0||s[i]!=s[i-1])st.push(1);
            else {
                st.top()++;
                if(st.top()==k){
                    s.erase(i+1-k,k);
                    i=i-k;
                    st.pop();
                }
            }
        }
        return s;
    }
};
```







### **7、括号的分数(难)**

先压入0  表示分数是0

如果遇到左括号  就压入0表示  加一个0  因为() 分数为1   (s)为s*2

所以遇到)  弹出堆栈顶部

然后判断是哪种形式  



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009013939.png)

```cpp
class Solution {
    public:
    int scoreOfParentheses(string s) {
        int n = s.size();
        stack<int>st;
        st.push(0);
        for(int i = 0;i<n ;i++){
            if(s[i] == '('){
                st.push(0);
            }else {
                int k = st.top();
                st.pop();
                if(k == 0)st.top() += 1;
                else st.top() += 2*k;
            }
        }
        return st.top();
    }
};
```



### **8、机器人打印**

可以把题目理解为给定一个字符串

运用一个堆栈能得到的最小字典序字符串

因为最多26个字母

所以我们记录每个字母出现的最后一个位置

然后每次枚举 从a开始

先判断堆栈顶部的元素是不是比当前枚举的小  然后加入字符串末尾

遇到枚举的字母，加入字符串末尾  否则入堆栈

最好把堆栈的字符串加回去

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009135011.png)



```cpp
class Solution {
    public:
    string robotWithString(string s) {
        string res,t;
        int index = 0 ;
        vector<int>pos(26,-1);
        for(int i = 0;i<s.size();i++)
            pos[s[i]-'a'] = i;

        for(int i = 0,k=0;i<26&&k<s.size();i++){
            char c = i+'a';
            while(t.size()&&t.back()<=c){
                res +=t.back();
                t.pop_back();
            }
            while(k<=pos[i]){
                if(s[k]==c)res += c;
                else  t += s[k];
                k++;
            }
        }
        reverse(t.begin(),t.end());
        return res + t;
    }
};
```





### 9、股票的跨度

思路：可以转变为找出第一个比当前值大的元素的下表加一

所有每次遇到一个值  把小于他的弹出

这里堆栈要用pair 记录每个值的下标是多少

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221021032218.png)

```cpp
class StockSpanner {
    public:
    stack<pair<int,int>>st;
    int index = 0;
    StockSpanner() {

    }

    int next(int price) {
        int sum = 1;
        while(st.size() > 0 && st.top().first <= price){
            st.pop();
        }
        if(st.size() > 0) sum = index-(st.top().second);
        else sum = index + 1;
        pair<int,int>m(price,index);
        index ++;
        st.push(m);
        return sum;
    }
};
```

## 十四、并查集

### 1、按公因数计算最大组件

这里用了数学思维，就是求公约数用了一个方法

 ![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730003126.png)

```java
class Solution {
    int[]parent;
    public int largestComponentSize(int[] nums) {
        int n=0;
        for(int i=0;i<nums.length;i++){
            n=Math.max(n,nums[i]);
        }
        parent=new int[n+1];
        for(int i=0;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<nums.length;i++){
            int k=nums[i];
            for(int j=2;j*j<=k;j++){
                if(k%j==0){
                    union(j,k);
                    union(j,k/j);
                }
            }
        }
        int max=0;
        int []count=new int[n+1];
        for(int i=0;i<nums.length;i++){
            int root=findroot(nums[i]);
            count[root]++;
            max=Math.max(max,count[root]);
        }
        return max;
    }

    //联通
    public void union(int root1,int root2){
        int k1=findroot(root1);
        int k2=findroot(root2);
        if(k1==k2)return;
        if(k1<k2)
            parent[k1]=k2;
        else parent[k2]=k1;
    }

    //寻找跟，路径压缩
    public int findroot(int x){
        if(parent[x]!=x){
            parent[x]=findroot(parent[x]);
        }
        return parent[x];
    }
}
```



### **2、吃动物**(难)

我们可以这样，用一个parent表示父节点，然后一个dist数组表示整个点到父亲点的距离

一个点到根节点距离取余3等于1  可以吃根

如果等于2   被根吃

等于0是同类

所以我们只要算出两个点的dist值就可以判断这两只动物的关系



在找根的时候，我们要先保存根根节点是谁，也就是路径压缩

让dist[x]+=dist[parent(x)];当前结点到根的距离等于当前结点到父节点的距离dist[x]+父节点到根结点的距离

因为是递归，x的父节点的dist刚好是根的距离，因为x的父节点直接指向了根，但是dist[x]只是单纯的父节点距离



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806040500.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806033827.png)



```java
import java.util.*;
public class Main{
    static int []parent;
    static int sum;
    static int[]dist;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        parent=new int[50005];
        dist=new int[50005];
        sum=0;
        int n=in.nextInt();
        int k=in.nextInt();
        for(int i=1;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<k;i++){

            int d=in.nextInt();
            int x=in.nextInt();
            int y=in.nextInt();
            if(x>n||y>n)sum++;
            else{
                int root1=findroot(x);
                int root2=findroot(y);
                if(d==1){
                    if(root1==root2&&(dist[x]-dist[y])%3!=0)sum++;
                    else if(root1!=root2){
                        parent[root1]=root2;
                        dist[root1]=dist[y]-dist[x];
                    }
                }else{
                    if(root1==root2&&(dist[x]-dist[y]-1)%3!=0){
                        sum++;
                    }else  if(root1!=root2){
                        parent[root1]=root2;
                        dist[root1]=dist[y]-dist[x]+1;
                    }
                }
            }
        }
        System.out.println(sum);
    }

    public static int findroot(int x){
        if(parent[x]!=x){
            int t=findroot(parent[x]);
            dist[x]+=dist[parent[x]];
            parent[x]=t;
        }
        return parent[x];
    }
}
```





### **3、删除后最大子段和(难)**

我们可以倒序，添加，然后逐一统计区间的最大数量

用并查集

s表示添加后这段区间的大小

同时，对于x两边的数，如果s[x]大于0，表示添加过，加入并查集，记住，先找出它的根，然后加s[根],最后将根指向x，一层层叠加下去，然后加入吧max加入集合，更新max

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220821021848.png)



```java
class Solution {
    long max;
    int[]p;
    long []s;
    public int find(int a){
        if(p[a]!=a)p[a]=find(p[a]);
        return p[a];
    }
    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {
        max=0;
        int n=nums.length;
        p=new int[n];
        s=new long[n];
        List<Long>list=new ArrayList<>();
        for(int i=0;i<n;i++){
            p[i]=i;
            s[i]=0;
        }
        for(int i=n-1;i>=0;i--){
            int x=removeQueries[i];
            s[x]=nums[x];
            for(int j=x-1;j<=x+1;j=j+2){
                //点的左右两边都有值,加入并查集
                if(j>=0&&j<n&&s[j]>0){
                    s[x]+=s[find(j)];
                    p[find(j)]=x;
                }
            }
            list.add(max);
            // System.out.println(max);
            max=Math.max(max,s[x]);
        }
        long []a=new long[list.size()];
        int index=0;
        for(int i=list.size()-1;i>=0;i--){
            a[index]=list.get(i);
            index++;
        }
        return a;
    }
}
```





### 4、无法到达的点队数

思路：

明显并查集，因为无法到达的带你肯定不在一个集合里面

所以我们算出多少个集合

这里算出每个集合多少个元素，然后统计出来

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220903024405.png)



```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        int []parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
        for(int i=0;i<edges.length;i++){
            merge(edges[i][0],edges[i][1],parent);
        }
        long sum=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        HashSet<Integer>set=new HashMap<>();
        for(int i=0;i<n;i++){
            int root=findroot(i,parent);
            set.add(root);
            if(map.get(root)==null)map.put(root,1);
            else map.put(root,map.get(root)+1);
        }
        for(int k:map.keySet()){
            long count=map.get(k);
            sum+=(n-count)*count;
        }

        public void merge(int a,int b,int []parent){
            int k1=findroot(a,parent);
            int k2=findroot(b,parent);
            if(a==b)return;
            parent[k1]=k2;
        }
        //路径压缩
        public int findroot(int a,int []parent){
            if(parent[a]!=a)parent[a]=findroot(parent[a],parent);
            return parent[a];
        }
    }
```



### 5、城市最小分数

找一个联通分量中最小的边就行了

用并查集

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221205003910.png)

```cpp
class Solution {
public:
    int parent[1000010];
    int findroot(int x){
        if(parent[x] != x)parent[x] = findroot(parent[x]);
        return parent[x];
    }
    int minScore(int n, vector<vector<int>>& roads) {
          for(int i = 1 ; i <= n ; i ++){
              parent[i] = i;
          }
          int w = 100000;
          int m = roads.size();
          for(int i = 0 ; i < m ; i ++){
             int a = roads[i][0];
             int b = roads[i][1];
             int c= roads[i][2];
             int root1 = findroot(a);
             int root2 = findroot(b);

             if(root1 == 1)parent[root2]  = 1;
             else parent[root1] = root2; 
          }
          for(int i = 0  ; i < m ; i ++){
               int a = roads[i][0];
             int b = roads[i][1];
             int c= roads[i][2];
             int root1 = findroot(a);
             int root2 = findroot(b);
             if(root1 == 1 || root2 == 1)
             w = min(w,c);
          }
          return w;
    }
};
```





## 十五、模拟

### 1、卡牌

![](C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220730213141.png)

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []s=new int[n+1];
        int total=0;
        for(int i=0;i<m;i++){
            int c=in.nextInt();
            s[c]++;
            if(s[c]==1)total++;
            if(total==n){
                System.out.print(1);
                for(int j=1;j<=n;j++){
                    s[j]--;
                    if(s[j]==0)total--;
                }
            }else {
                System.out.print(0);

            }

        }
    }
}
```





### 2**、矩阵螺旋**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220806003247.png)

1、暴力模拟

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        List<List<Integer>>list=new ArrayList<>();
        List<Integer>list2=new ArrayList<>();
        int m=mat.length;
        int n=mat[0].length;
        int []num=new int[m*n];
        int index=0;
        int flag=1;
        for(int i=0;i<m;i++){
            int k=i;
            int j=0;
            list2=new ArrayList<>();
            while(k>=0&&j<n){
                list2.add(mat[k][j]);
                k--;
                j++;
            }
            if(flag%2==0){
                Collections.reverse(list2);
            }
            flag++;
            list.add(list2);
        }

        for(int j=1;j<n;j++){
            int k=m-1;
            int w=j;
            list2=new ArrayList<>();
            while(k>=0&&w<n){
                list2.add(mat[k][w]);
                k--;
                w++;
            }
            if(flag%2==0){
                Collections.reverse(list2);
            }
            flag++;
            list.add(list2);
        }
        for(int i=0;i<list.size();i++){
            for(int j=0;j<list.get(i).size();j++){
                num[index++]=list.get(i).get(j);
            }
        }
        return num;
    }
}
```



第二种直接模拟，比较技巧

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int n=mat.length;
        int m=mat[0].length;
        int []num=new int[m*n];
        int index=0;
        int k1=0;
        int k2=0;
        //指引方向
        int flag=1;
        while(index<m*n){
            num[index++]= mat[k1][k2];
            if(index==m*n)break;
            if(flag==1){
                //转向
                if(k1-1<0||k2+1>=m){
                    if(k2+1<m)k2=k2+1;
                    else k1=k1+1;
                    flag=0;
                }else{
                    k1=k1-1;
                    k2=k2+1;
                }
            }else{
                if(k1+1>=n||k2-1<0){
                    if(k1+1<n)k1=k1+1;
                    else k2=k2+1;
                    flag=1;
                }else{
                    k1=k1+1;
                    k2=k2-1;
                }
            }
        }
        return num;
    }
}
```





### 3、提莫攻击

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220809181607.png)





```java
class Solution {
    public int findPoisonedDuration(int[] timeSeries, int duration) {
        int n=timeSeries.length;
        int last=0;
        int sum=0;
        for(int i=0;i<n;i++){
            if(timeSeries[i]>=last){
                sum+=duration;
            }else{
                sum+=duration;
                sum-=last-timeSeries[i];
            }
            last=timeSeries[i]+duration;
        }
        return sum;
    }
}
```







### 4、表面积

计算每个点上的正方形的贡献就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819041659.png)

```java
class Solution {
    public int surfaceArea(int[][] grid) {
        int n=grid.length;
        int m=grid[0].length;
        int sum=0;
        int []k1={1,-1,0,0};
        int []k2={0,0,1,-1};
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(grid[i][j]>0)sum=sum+2;
                for(int w=0;w<4;w++){
                    int x=i+k1[w];
                    int y=j+k2[w];
                    if(x<0||y<0||x>=n||y>=m)sum+=grid[i][j];
                    else if(grid[x][y]<grid[i][j])sum+=grid[i][j]-grid[x][y];
                }
            }
        }
        return sum;
    }
}
```



## 十六、字典树

### 1、最大异或对



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813072448.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220813062526.png)

就是相同为0不同唯一，从最高位置开始，往和当前数位置不同的地方走

可以用字典树

```java
import java.util.*;
class Main{
    static int[][]root=new int[3100010][2];
    static int index=0;
    static int  []a;

    static void insert(int x){
        int p=0;
        for(int i=30;i>=0;i--){
            //取出最第i位的数字
            int u=x>>i&1;
            if(root[p][u]==0)root[p][u]=++index;
            p=root[p][u];
        }
    }

    static int query(int x){
        int p=0;
        int res=0;
        for(int i=30;i>=0;i--){
            int u=x>>i&1;
            int w;
            if(u==0)w=1;
            else w=0;
            if(root[p][w]!=0){
                p=root[p][w];
                res=res*2+w;
            }else {
                p=root[p][u];
                res=res*2+u;
            }
        }
        //System.out.println(res);
        return res;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        a=new int[n+1];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        int res=0;
        for(int i=0;i<n;i++){
            insert(a[i]);
            int t=query(a[i]);
            res=Math.max(res,t^a[i]);
        }
        System.out.println(res);
    }
}
```





### **2、字符串前缀和(经典)**

将所有字符串加入前缀树

每一次加入到同一个字符串都有吧总数加一

然后再来一次循环，寻找这个字符串出现了多少次前缀

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220919013831.png)



```cpp
class Solution {
    public:
    int a[(int)4e5][26];
    int index=0;
    int sum[(int)4e5];
    vector<int> sumPrefixScores(vector<string>& words) {
        int n=words.size();
        for(int i=0;i<n;i++){
            insert(words[i]);
        }
        vector<int>v(n);
        for(int i=0;i<n;i++){
            v[i]=query(words[i]);
        }
        return v;
    }

    int  query(string s){
        int count=0;
        int q=0;
        for(int i=0;i<s.size();i++){
            int k=s[i]-'a';
            if(a[q][k]==0)break;
            q=a[q][k];
            count+=sum[q];
        }
        return count;
    }

    void insert(string s){
        int q=0;
        for(int i=0;i<s.size();i++){
            int k=s[i]-'a';
            if(a[q][k]==0)a[q][k]=++index;
            q=a[q][k];
            sum[q]++;
        }
    }
};
```



## 十六、迪杰斯拉

### 1、序列

找出每次最小距离和数组最小距离相比=就可以判断

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731060354.png)

```java
import java.util.*;
public class Main{
    //有权图单源最短路
    static int[][] graph;
    static int dist[];
    static int flag;
    static int index;
    static int []help;
    static HashSet<Integer> set = new HashSet<>();//判断是否被收录

    //初始化
    public static void creat(int []a) {
        for (int i = 0; i <a.length; i++) {
            dist[a[i]] = 100000000;
        }
        dist[a[0]]=0;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        //初始化图
        graph=new int[1010][1010];
        for(int i=0;i<m;i++){
            int k1=in.nextInt();
            int k2=in.nextInt();
            int k3=in.nextInt();
            graph[k1][k2]=graph[k2][k1]=k3;
        }
        int count=in.nextInt();
        int []a=new int[n];
        for(int i=0;i<count;i++){
            help=new int[1010];
            dist=new int[1010];
            set=new HashSet<>();
            for(int j=0;j<n;j++){
                a[j]=in.nextInt();
            }
            index=0;
            creat(a);
            Dijkstra(a);
        }
    }

    //具体算法
    public static void Dijkstra(int []a) {
        while (true) {
            int v = -1;
            long min = 1000000000;
            //对于没有被收录进去的结点，找出dist最小的
            for (int i = 1; i <=a.length; i++) {
                if (set.contains(i) == false) {
                    if (dist[i] < min) {
                        min = dist[i];
                        v = i;
                    }
                }
            }
            //已经全部收录了
            if (min == 1000000000) break;
            if(dist[v]<dist[a[index++]]){
                System.out.println("No");
                return;
            }
            help[v]=dist[v];
            set.add(v);
            for (int i = 1; i <=a.length; i++) {
                if (graph[v][i] > 0 && set.contains(i) == false) {
                    if (dist[v] + graph[v][i] < dist[i]) {
                        dist[i] = dist[v] + graph[v][i];
                    }
                }
            }
        }
        System.out.println("Yes");

    }

}
```







## 十七、图论

### **1、最长环**(难)

思路：

首先我们遍历，遇到一个被访问过的点，如果他是这次访问过得，就用总距离减去这个点的深度

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220802002156.png)

```java
class Solution {
   int []vist;
   int []length;
   int max;
   public int longestCycle(int[] edges) {
      int n=edges.length;
      length=new int[n];
      vist=new int[n];
      max=-1;
      for(int i=0;i<n;i++){
         if(vist[i]==0){
            dfs(edges,i,1);
         }
      }
      return max;
   }
   public void dfs(int []edges,int i,int sum){
      if(i==-1)return;
      if(vist[i]==0){
         vist[i]=1;
         length[i]=sum;
         dfs(edges,edges[i],sum+1);
         length[i]=0;
      }else {
         if(length[i]>0){
            max=Math.max(max,sum-length[i]);
         }
      }
   }
}
```



### 2、负环

算法分析
使用spfa算法解决是否存在负环问题

求负环的常用方法，基于SPFA，一般都用方法 2（该题也是用方法 2）：

方法 1：统计每个点入队的次数，如果某个点入队n次，则说明存在负环
**方法 2：统计当前每个点的最短路中所包含的边数，如果某点的最短路所包含的边数大于等于n，则也说明存在环**

所以要把每个点初始化都入队列

y总的原话
每次做一遍spfa()一定是正确的，但时间复杂度较高，可能会超时。初始时将所有点插入队列中可以按如下方式理解：
在原图的基础上新建一个虚拟源点，从该点向其他所有点连一条权值为0的有向边。那么原图有负环等价于新图有负环。此时在新图上做spfa，将虚拟源点加入队列中。然后进行spfa的第一次迭代，这时会将所有点的距离更新并将所有点插入队列中。执行到这一步，就等价于视频中的做法了。那么视频中的做法可以找到负环，等价于这次spfa可以找到负环，等价于新图有负环，等价于原图有负环。得证。

1、dist[x] 记录虚拟源点到x的最短距离

2、cnt[x] 记录当前x点到虚拟源点最短路的边数，初始每个点到虚拟源点的距离为0，只要他能再走n步，即cnt[x] >= n，则表示该图中一定存在负环，由于从虚拟源点到x至少经过n条边时，则说明图中至少有n + 1个点，表示一定有点是重复使用

3、若dist[j] > dist[t] + w[i],则表示从t点走到j点能够让权值变少，因此进行对该点j进行更新，并且对应cnt[j] = cnt[t] + 1,往前走一步

注意：该题是判断是否存在负环，并非判断是否存在从1开始的负环，因此需要将所有的点都加入队列中，更新周围的点



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220823165402.png)



```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];   //值
    public  static  int[]next=new int[200000];    //下一个指针
    public  static  int[]weight=new int[200000];   //权重
    public  static  int index=0;
    static  int n;
    public static int []cnt;
    static int max=1000000000;

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }



    public  static  boolean  spfa(){
        //全部点加入队列
        Queue<Integer>queue=new LinkedList<>();
        for(int i=1;i<=n;i++){
            visit[i]=1;
            queue.add(i);
        }
        while(queue.size()>0){
            int k=queue.poll();
            // System.out.println(k);
            visit[k]=0;
            for(int i=graph[k];i!=-1;i=next[i]){
                int j=value[i];
                if(dist[k]+weight[i]<dist[j]){
                    dist[j]=weight[i]+dist[k];
                    cnt[j]=cnt[k]+1;
                    if(cnt[j]>n)return true;
                    if(visit[j]==0){
                        visit[j]=1;
                        queue.add(j);
                    }
                }
            }
        }
        return false;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        cnt=new int[n+1];
        for(int i=1;i<=n;i++)graph[i]=-1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        boolean s=spfa();
        if(s==true) System.out.println("Yes");
        else System.out.println("No");
    }
}
```





### **3、二分图(难)**

意思就是分成两组  每组内的成员不能有边链接

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014610.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016014422.png)

![]()

```java
class Solution {
    int []g=new int[100010];
    int[]next=new int[200020];
    int[]value=new int[200010];
    int[]color=new int[100010];
    int index=0;
    void insert(int a,int b){
        value[index]=b;
        next[index]=g[a];
        g[a]=index++;
    }
    public boolean dfs(int u,int c){
        color[u]=c;
        for(int i=g[u];i!=-1;i=next[i]){
            int j=value[i];
            if(color[j]==0){
                if(dfs(j,3-c)==false)return false;
            }
            else {
                if(color[j]==c)return false;
            }
        }
        return true;
    }
    public boolean possibleBipartition(int n, int[][] dislikes) {
        for(int i=1;i<=n;i++)g[i]=-1;
        for(int i = 0;i<dislikes.length;i++){
            insert(dislikes[i][0],dislikes[i][1]);
            insert(dislikes[i][1],dislikes[i][0]);
        }
        boolean flag=true;
        for(int i=1;i<=n;i++){
            if(color[i]==0){
                if(dfs(i,1)==false){
                    flag=false;
                    break;
                }
            }
        }
        return flag;
    }
}
```



### 4、添加边让结点成为偶数



思路：

最多添加两个结点，每一次造成的影响有：

两个奇数  奇数结点 - 2

链接两个偶数  奇数结点+2

链接一奇数一偶数   奇数结点不变



所以添加两条边最多减少4个奇数结点

所以先预处理  大于4直接返回false

不可能有奇数个结点

所以剩下  0 2 4

如果为0 直接返回true

为2

有两种情况  ：

1-将两个奇数结点相连

2-两个奇数结点共同连一个结点

如果为4：

只能是两个奇数结点两两匹配

全排列，这里用了一个函数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221218134629.png)

```cpp
class Solution {
public:
    //哈希值
    long long   hs(int a,int b){
        if(a > b)swap(a,b);
        return  (long long )((long long) a * 1000000 + b);
    }


    bool isPossible(int n, vector<vector<int>>& edges) {
        set<long long >s;
        vector<int>d(n + 1,0);
        for(auto & k : edges){
            int a = k[0],b = k[1];
            d[a] ++;
            d[b] ++;
            s.insert(hs(a,b));
        }


        vector<int>v;
        for(int i = 1 ; i <= n ; i ++){
           if(d[i] % 2 == 1){
               v.push_back(i);
           }
        }
    
        if(v.size() == 0)return true;
        if(v.size() > 4)return false;
        if(v.size() == 2){
           int a = v[0];
           int b = v[1];
           if(s.count(hs(a,b)) == 0)return true;
           for(int i = 1 ;i <= n ; i ++){
               if(i !=a && i != b && s.count(hs(i,a)) == 0 && s.count(hs(i,b)) == 0)return true;
           }
           return false;
        }else if(v.size() == 4) {
            for(int i = 0 ;i <24 ; i ++){
                int a = v[0],b = v[1],c = v[2],d = v[3];
                if(s.count(hs(a,b)) == 0 && s.count(hs(c,d)) == 0)return true;
                //下一个排列
                next_permutation(v.begin(),v.end());
            }

        }
        return false;
    }
};
```





## 十八、数学

### **1、拼长方体**

首先n是奇数直接排除  因为2*两边之和等于周长   所以n%4==1   n%4==3直接输出0

如果N是4的倍数  那么先组成一个正方形，然后让两条边分别减一，另外两条边加一  总共有n/4-1总方法

否则n%4==2

分成四份，两条边长，两条短，短的长度是n/4,  短的可以从1到四分之n变化， 所以总的方案是n/4

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807051707.png)

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        while(in.hasNext()){
            int n=in.nextInt();
            if(n%4==0)System.out.println(n/4-1);
            else{
                if(n%4==1||n%4==3)System.out.println(0);
                else
                    System.out.println(n/4);
            }
        }
    }
}
```





### 2、最大公约数

找出一堆数的最大公约数  分别求相邻两个数的最大公约数然后取最小

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221028014132.png)

```cpp
class Solution {
public:
    int count(int a,int b){
        int m = min(a,b);
        for(int i = m ; i >= 0 ; i --){
            if(a % i ==0 && b % i == 0)return i;
        }
        return 1;
    }
    int subarrayGCD(vector<int>& nums, int k) {
        int n = nums.size();
        int sum = 0;
        for(int i = 0 ;i< n ; i++){
            int mx = nums[i];
            for(int j = i;j < n ; j++){
                if(nums[i] % k !=0)break;
                mx = min(mx,count(mx,nums[j]));
                if(mx == k)sum ++;
            }
        }
        return sum;
    }
};
```



### 3、美丽数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221030133436.png)

```cpp
class Solution {
public:
    long long makeIntegerBeautiful(long long n, int target) {
        long long sum = n;
        long long index = 1;
        while(get(sum) > target){
           long long c = sum/index%10;
           if(c == 0){
               index = index*10;
               continue;
           }
           c = c*index;
           sum = sum +10*index-c;
           index = index*10;
        }
        return sum - n;
    }
    int get(long long  n){
        int sum = 0 ;
        while(n>0){
            sum += n%10;
            n = n / 10;
        }
        return sum;
    }
};
```



## 十九、字符串

### 1、字符串和2的幂次方

找出长度一样的2的幂次方，一个个比较

![](C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220817173853.png)

```java
class Solution {
    public boolean reorderedPowerOf2(int n) {
        int sum=1;
        List<String> list=new ArrayList<>();
        while((sum+"").length()<=(n+"").length()){
            if((sum+"").length()==(n+"").length())list.add(sum+"");
            sum=sum*2;
        }
        char[]a;
        char[]b;
        for(int i=0;i<list.size();i++){
            String str=list.get(i);
            if((str).length()!=(n+"").length())return false;
            a=(str).toCharArray();
            b=(n+"").toCharArray();
            Arrays.sort(a);
            Arrays.sort(b);
            if(new String(a).equals(new String(b)))return true;
        }
        return false;
    }
}
```



### 2、最长回文

先找出首字母，如果首字母为空，那么就找出最大的数字，返回

不是空串，那就一个个加

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220822011520.png)

```java
class Solution {
    public String largestPalindromic(String num) {
        int []a=new int[10];
        int max=0;
        String s="";
        for(int i=0;i<num.length();i++){
            a[num.charAt(i)-'0']++;
        }
        for(int i=9;i>0;i--){
            if(a[i]>=2){
                a[i]-=2;
                s=i+"";
                break;
            }
        }
        if(s.equals("")){
            for(int i=9;i>=0;i--){
                if(a[i]>0)return i+"";
            }
        }  
        else {
            for (int j = 9; j >= 0; j--) {
                while (a[j] >= 2) {
                    a[j] -= 2;
                    s += j;
                }
            }
        }
        
        StringBuffer stringBuffer=new StringBuffer(s);
        String s2=stringBuffer.reverse().toString();
        for(int i=9;i>=0;i--){
            if(a[i]==1){
                s+=i;
                break;
            }
        }
        return s+s2;
    }
}
```





### 3、两个字符串接近

思路很简单：

先判断长度

然后计算两个字符串各自出现的次数，并且一个字符串是否都出现过

第一个操作可以忽略不计

第二个操作只要将次数从小到大排序就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220828181815.png)



```java
class Solution {
    public boolean closeStrings(String word1, String word2) {
        if(word1.length()!=word2.length())return false;
        int []num1=new int[26];
        int []num2=new int[26];
        int sum1=0;
        int sum2=0;
        for(int i=0;i<word2.length();i++){
            int a=word1.charAt(i)-'a';
            int b=word2.charAt(i)-'a';
            num1[a]++;
            num2[b]++;
        }
        for(int i=0;i<26;i++){
            if(num1[i]==0&&num2[i]!=0||num1[i]!=0&&num2[i]==0)return false;
        }
        if(sum1!=sum2)return false;
        Arrays.sort(num2);
        Arrays.sort(num1);
        for(int i=1;i<26;i++){
            if(num1[i]!=num2[i])return false;
        }
        return true;
    }
}
```





### **4、匹配字符串(傻逼题)**



思路：

每次遍历数组中字符串，然后匹配，如果相同下标加一，如果大写字母，直接false

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908024221.png)

```cpp
class Solution {
    public:
    vector<bool> camelMatch(vector<string>& queries, string pattern) {
        vector<bool>v;
        int n=queries.size();
        int index=0;
        for(int i=0;i<n;i++){
            index=0;
            string s=queries[i];
            int flag=0;
            for(char c:s){
                if(index<pattern.size()&&pattern[index]==c)index++;
                else if(c>='A'&&c<='Z'){
                    flag=1;
                    break;
                }
            }
            v.push_back(flag==0&&index==pattern.size());
        }
        return v;
    }
};
```



### 5、删除子文件夹

思路这里先排序

如果用Last表示主文件夹

遍历整个数组

如果数组中的元素不包含last  或者last长度的位置不是   "/"  符合条件  更新Last 

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221003134200.png)

```cPP
class Solution {
    public:
    vector<string> removeSubfolders(vector<string>& folder) {
        int n = folder.size();
        sort(folder.begin(),folder.end());
        vector<string>v;
        string last="/";
        string s="abc";

        for(auto &s:folder){
            if(s.find(last)!=0||s[last.size()]!='/'){
                v.push_back(s);
                last=s;
            }
        }
        return v;
    }
};
```





### **6、可以形成最多字符串(贪心)**

形成最多字符串无疑就是把首字母放或者把第二个字母放最后

我们设立两个变量分别统计两个字母

并且统计中间过程可以形成多少个匹配的单词

最后加上两个字符数量大的值

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221011154652.png)

```cpp
class Solution {
    public:
    long long maximumSubsequenceCount(string text, string pattern) {
        int n = text.size();
        long long sum = 0;
        int sum1 = 0;
        int sum2 = 0;
        for(int i = 0 ; i < n ;i ++){
            if(text[i] == pattern[1]){
                sum += sum1;
                sum2 ++;
            }
            if(text[i] == pattern[0]) sum1 ++;
        }
        if(sum1>sum2)sum += sum1;
        else sum += sum2;
        return  sum;
    }
};
```

## 二十、异或

### 1、查询每个异或值

思路：

先算出全部异或， 由于a^b^b=a;

所以我们算出了总异或后    前i个数的异或和等于  i个数的异或和再异或低i个数

由于k小于2max次方，所以k最大只能取到2max次方减一

我们求出这个k    也就k^前i个异或和=2max-1

**这时候k等于2max-1^前i个异或和**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220826213400.png)

```java
class Solution {
    public int[] getMaximumXor(int[] nums, int maximumBit) {
        //可以达到的最大值
        int  flag=(int)Math.pow(2,maximumBit)-1;
        int sum=0;
        //求出异或
        for(int i=0;i<nums.length;i++){
            sum^=nums[i];
        }
        int []a=new int[nums.length];
        a[0]=sum^flag;
        int index=1;
        for(int i=nums.length-1;i>0;i--){
            sum=sum^nums[i];//得到去掉末尾位置数字的异或和
            a[index++]=sum^flag;
        }
        return a;
    }
}
```





### **2、两个异或相等的三元组(难)**

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827175730.png)

方法一：三重

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827180024.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220827180035.png)

```java
class Solution {
    public int countTriplets(int[] arr) {
        int n = arr.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int j = i + 1; j < n; ++j) {
                for (int k = j; k < n; ++k) {
                    if (s[i] == s[k + 1]) {
                        ++ans;
                    }
                }
            }
        }
        return ans;
    }
}
```



优化二重：

当si==sk+1时候

i+1到k也是符合的

所以有k-i个

```java

class Solution {
    public int countTriplets(int[] arr) {
        int n = arr.length;
        int[] s = new int[n + 1];
        for (int i = 0; i < n; ++i) {
            s[i + 1] = s[i] ^ arr[i];
        }
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            for (int k = i + 1; k < n; ++k) {
                if (s[i] == s[k + 1]) {
                    ans += k - i;
                }
            }
        }
        return ans;
    }
}
```



**转换法：**

我们要求a[i]^...a[i-1]==a[j]^...a[k]

也就是a[i]^....a[k]==0

中间求多少个j

```java
/**
 * a ^ b = a[i]^...^a[k] = 0, 题目转化为求子串的异或结果等于0
 */
public static int countTriplets(int[] arr) {
    int res = 0;

    for (int i = 0; i < arr.length; i++) {
        int t = arr[i];
        for (int k = i + 1; k < arr.length; k++) {
            t ^= arr[k];
            if (t == 0) {
                // j 无所谓呐，i~k任意一个数都行
                res += k - i;
            }
        }
    }
    return res;
}
```





### 3、&运算

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831023931.png)

```c++
class Solution {
    public:
    bool isPowerOfTwo(int n) {
        return n>0&&(n&(-n))==n;
    }
};
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831023621.png)





### 4、二进制&

比较最右边是不是相等的

&1就行了，如果相等就表示右边一位相等

然后右移一位

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220905171632.png)



```c++
class Solution {
   public:
   int minBitFlips(int start, int goal) {
      int sum=0;
      while(start>0||goal>0){
         if((start&1)!=(goal&1))sum++;
         start=start>>1;
         goal=goal>>1;
      }
      return sum;
   }
};
```



### 5、按位或 |

意思：

因为| 运算是并集，也就是我们要找到1最多的子数组

我们可以用一个辅助数组记录第j位是1的元素的下标

然后贪心

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220918030701.png)



```cpp
class Solution {
    public:
    vector<int> smallestSubarrays(vector<int>& nums) {
        int n = nums.size();
        vector<int>a(n);
        vector<int>help(32);
        int mx=0;
        for(int i = n-1;i>=0;i--){
            mx = mx|nums[i];
            for(int j = 0;j<32;j++){
                if(nums[i]>>j&1)help[j]=i;
            }
            int t=1;
            for(int j=0;j<32;j++){
                if(((mx>>j)&1)==1){
                    t=max(t,help[j]-i+1);
                }
            }
            a[i]=t;
        }
        return a;
    }
};
```









### 6、数组中最大异或值  



思路：

^相同为0   不同为1

我们有a^b = c   ->   a^c = b  -> b^c = a

我们找到max   只要遍历max ^ 数组中的元素   =  b  且b在数组中   那么就存在a^b = max

由于贪心法则  我们从最高位开始  验证当前位能否取1  依次类推

我们假设 第一次遍历 

 可以取1  那么我们把数组的最高位存入set  然后用这个数去和数组每一个数^  如果结果在set中  表示当前数可以取1

否则取0

第二次遍历我们假设当前为1    当前已经有两位了  分别是_1

_是上一次得出的结果

我们可以把上一次结果*2+1  就是当前位置的值变成1

如果最后不满足  就是把当前结果-1



比如11  ->111   就是3*2+1；

11 ->110   3*2

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230105020337.png)

```cpp
class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        int res = 0;
        int x = 0;
        for(int i = 30; i >= 0 ; i --){
            unordered_set<int>s;
            for(auto k : nums){
                s.insert(k>>i);
            }
            int id = x*2 + 1;
            int flag = 0;
            for(auto k : nums){
                if(s.count(id^(k>>i)) !=0){
                   flag = 1;
                   break;
                }
            }
            if(flag == 0)x = id -1;
            else x = id;
        }
        return x;
    }
};
```





## 二十一、拓扑排序

### 1、构造矩阵

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220828141527.png)

```java
class Solution {
    public int[][] buildMatrix(int k, int[][] rowConditions, int[][] colConditions) {
        int [][]g=new int[k][k];
        int []num1=new int[k+1];
        int []num2=new int[k+1];
        int sum1=topu(rowConditions,k,num1);
        int sum2=topu(colConditions,k,num2);
        if(sum1!=k)return new int[0][0];
        if(sum2!=k)return new int[0][0];

        for(int i=1;i<=k;i++){
            g[num1[i]][num2[i]]=i;
        }
        return g;
    }
    public  int  topu(int [][]num,int k,int []nums){

        int [][]g=new int[k+1][k+1];
        int []degree=new int[k+1];
        for(int []w:num){
            int a=w[0];
            int b=w[1];
            if(g[a][b]==1)continue;
            g[a][b]=1;
            degree[b]++;
        }

        Queue<Integer>queue=new LinkedList<>();
        for(int i=1;i<=k;i++){
            if(degree[i]==0)queue.add(i);
        }
        int sum=0;
        int index=0;
        while (queue.size()>0) {
            int w = queue.poll();
            sum++;
            nums[w] = index;
            for (int i = 1; i <= k; i++) {
                if (g[w][i] == 1) {
                    degree[i]--;
                    if (degree[i] == 0) queue.add(i);
                }
            }
            index++;
        }
        return sum;
    }
}
```







## 二十二、堆

### 1、区间划分

我们用小根堆来记录区间的第二个数，先对数组进行排序，第一个数从小到大，然后依次加入堆

如果堆中元素为0直接插入

如果堆顶元素大于当前数组第一个元素，那么直接入堆，不能合并

如果堆顶元素小于当前数组第一个元素

那么弹出堆顶，然后插入当前数组第二个元素

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911134605.png)

```cpp
class Solution {
    public:
    int minGroups(vector<vector<int>>& intervals) {
        int n=intervals.size();
        sort(intervals.begin(),intervals.end());
        //定义小顶堆
        priority_queue<int,vector<int>,greater<int>>heap;
        for(auto &k:intervals){
            if(heap.size()==0)heap.push(k[1]);
            else if(heap.top()>=k[0]){
                heap.push(k[1]);
            }else {
                heap.pop();
                heap.push(k[1]);
            }
        }
        return heap.size();
    }
};
```



### 2、将数组减半

用大根堆维护最大的数

每次减半

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221009000148.png)



```cpp
class Solution {
    public:
    int halveArray(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        priority_queue<double>heap;//最大堆
        double sum=0.0;
        int count=0.0;
        for(int k:nums){
            sum+=k;
            heap.push(k);
        }
        double flag=sum/2;
        while(sum>flag){
            double k=heap.top();
            heap.pop();
            sum-=k/2;
            heap.push(k*1.0/2);
            count++;
        }
        return count;
    }
};
```





### 3、雇佣k个工人最少花费

思路 :

当2*candidates>数组的长度  放入堆中找最小值

反之

用两个堆维护两端

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221107024335.png)

```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();
        priority_queue<int,vector<int>,greater<int>>heap1;
        priority_queue<int,vector<int>,greater<int>>heap2;
        long long  sum = 0 ;
        if(candidates *2 > n){
           for(int i = 0 ;i < n ; i ++)heap1.push(costs[i]);
           for(int i = 0 ;i < k ; i++){
               sum += heap1.top();
               heap1.pop();
           }
        }else {
            int l;
            int r;
           for(l = 0 ;l < candidates ; l ++)heap1.push(costs[l]);
           for(r = n -1 ; r >= n - candidates ; r --)heap2.push(costs[r]);
           for(int i = 0 ;i < k ; i ++){
            //cout<<heap1.top()<<" "<<heap2.top()<<endl;
              if(heap1.size() == 0){
                  sum += heap2.top();
                  heap2.pop();
              }else if(heap2.size() == 0){
                  sum += heap1.top();
                  heap1.pop();
              }else {
                if(heap1.top() <= heap2.top()){
                      sum += heap1.top();
                      heap1.pop();
                      if(l <= r){
                          heap1.push(costs[l]);
                          l ++;
                      }
                  }else if(heap1.top() > heap2.top()) {
                      sum +=heap2.top();
                      heap2.pop();
                      if(l<= r){
                          heap2.push(costs[r]);
                          r --;
                      }
                  }
               }
           }
        }
      return sum;
    }
};
        
                
```







## 二十三、前缀和

### 1、子数组绝对值最大值

算出前缀和

然后求出前缀和最大和最小的

将这两个的绝对值和他们两个差的绝对值取最大

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220912192531.png)

```cpp
class Solution {
    public:
    int maxAbsoluteSum(vector<int>& nums) {
        int n=nums.size();
        int mx=nums[0];
        int mn=nums[0];
        for(int i=1;i<n;i++){
            nums[i]=nums[i-1]+nums[i];
            mx=max(nums[i],mx);
            mn=min(nums[i],mn);
        }
        return max(abs(mx-mn),max(abs(mx),abs(mn)));
    }
};
```





### 2、美丽数

直接前缀和 



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221212024854.png)

```cpp
class Solution {
public:
    int beautySum(string s) {
      int n = s.size();  
      int a[n + 1][26];
      memset(a,0,sizeof a);
      for(int i = 1 ; i <= n ; i ++){
        
          a[i][s[i - 1] - 'a'] ++;
          for(int j = 0 ; j < 26 ; j ++){
              a[i][j] += a[i - 1][j];
          }
      }
     
      int sum = 0;
      for(int i = 1 ; i <= n ; i ++){
          for(int j = i ; j <= n; j ++){
               int mn = 100000000000;
               int mx = -10000000000;
              for(int k = 0 ;k < 26 ; k ++){
                  mx = max(a[j][k] - a[i - 1][k],mx);
                  if(a[j][k] - a[i - 1][k] != 0)
                  mn = min(a[j][k] - a[i - 1][k],mn);
              }
           
              sum += mx - mn;
          }
      }
      return sum;
    }
};
```





## 二十四、滑动窗口

### 1、每种字符取k个

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221227031955.png)

```cpp
class Solution {
public:
    int takeCharacters(string s, int k) {
        int num[3] = {0};
        int n = s.size();
        for(int i = 0 ; i < n ; i ++){
            num[s[i] - 'a'] ++;
        }
        for(int i = 0 ; i < 3 ; i ++){
            if(num[i] < k)return -1;
        }
        int l =0,r = 0;
        int mx = 0;
        for(;r < n ;  r ++){
            num[s[r] - 'a'] --;
            while(l < r && (num[0]< k || num[1] < k || num[2] < k)){
                num[s[l] - 'a'] ++;
                l ++;
            }
            if(num[0] >= k && num[1] >= k && num[2] >= k){
               mx = max(mx,r - l + 1);
            }
        }
        return n - mx;
    }
};
```







### 2、好子数组数目

思路

>我们可以用map记录每个数字出现的次数，然后从前往后遍历 
>设左端点为l,右端点为r
>然后我们一直向右扩张，直到数对数目等于k
>我们怎么计算数对数目呢，如果l向有移动，那么减少map[l]  - 1个数对，r向右移动，就会加map[r] 个数对
>所以，我们找到r后，r后面的所有下标都是符合的，那么只要移动l就行了 

题目

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230116231151.png)

```cpp
class Solution {
public:
    long long countGood(vector<int>& nums, int k) {
        int n = nums.size();
        int l = -1;
        int r = 0;
        unordered_map<int,int>m;
        long long sum = 0;
        long long c = 0;
        while(l < n){
            if(l != -1){ 
               m[nums[l]] --;
               c -= m[nums[l]];
            }
            l ++;
            while(r < n){
               if(c >= k)break;
               c += m[nums[r]];
               m[nums[r]] ++;
               r ++;
            }
            if(c >= k)
            sum += (n - r + 1);
        }
        return sum;
    }
};
```





## 二十四、树状数组  



### 1、找出牛的身高

> 描述：
> 给一组数据，表示第i头牛前面有多少头比他矮的牛，牛的的身高是1 - n  最后输出所有牛的身高

解：

+ 从后往前找，找出没有出现过的第w[i]小的数，然后加一就是当前牛的身高
+  用一个数组a  表示数字i 还可以用几次
+ 用树状数组维护前缀和
+ 在剩余的数中找到第k小的数就是找到一个最小的x满足sum(x) = k,用二分求



代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
const int N = 100100;
int a[N];
int tre[N];
int n;
int ans[N];
int lowbit(int x)  // 返回末尾的1
{
    return x & -x;
}

int sum(int x){
    int res = 0;
    for(int i = x; i;i -= lowbit(i)){
        res += tre[i];
    }
    return res;
}

void add(int x,int c){
    for(int i = x  ;i <= n ; i += lowbit(i)){
        tre[i] += c;
    }
}
int main(){
    scanf("%d",&n);
    for(int i = 2 ; i <= n ; i ++){
        scanf("%d",&a[i]);
    }
    
    //构建树状数组
    for(int i = 1 ; i<= n ;i ++){
        add(i,1);
    }
    
    for(int i = n  ; i >= 1 ; i --){
        int l = 1;
        int r = n;
        //当前排名是第k小
        int k = a[i] + 1;
        while(l < r){
            int mid = (l + r)/2;
            int value = sum(mid);
            if(value >= k)r = mid;
            else l = mid + 1;
        }
        ans[i] = r;
        add(r,-1);
    }
    
    for(int i = 1 ; i <= n;  i ++){
        printf("%d\n",ans[i]);
    }
    return 0;
}
```

