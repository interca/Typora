# 算法汇总



## 没搞懂的

1、堆

3、kmp

<br/><br/>

## 注意点

> 稠密图用矩阵，稀疏图用邻接表
>
> 这里的邻接表也用数组来模拟，参考下面图论代码
>
> 邻接表就是用一个g数组表示各个点  初始为-1
>
> 然后next数组表示下一下点的位置
>
> value数组表示值
>
> Index表示下标

<br/><br/>

## 技巧  

> 判断图的两个点是否有边可以用哈希来存储，因为用矩阵可能会爆Int

```
 //哈希值
    long long   hs(int a,int b){
        if(a > b)swap(a,b);
        return  (long long )((long long) a * 1000000 + b);
    }
```


```
 //取出右边的一
 int lobwit(int x){
        return x&(-x);
    }
```





x&(x - 1) == 0判断是否 是二的次幂

<br/><br/>
<br/><br/>

## **一、时间复杂度**

<br/><br/>

### 1、算法优劣的核心指标

时间复杂度  额外空间复杂度 常数项时间(细节) 



### 2、常见的常数时间操作



> 加减乘除     位运算(>>  >>>   <<  |  &  ^)     赋值，比较，自增减     数组寻址
>
> 位运算简介：
>
> + />>把二进制全部向右移动一位，前面第一位补没有移动前的第一位
> + />>>前面第一位补零
>
>    n>>2  等价n/2 
>
>    比如常见的冒泡，选择，插入都是O(n2)时间复杂度
>
>

<br/><br/>


### 3、确认时间复杂度

1. 按照最坏情况考虑
2. 把整个流程拆分为一个个基本动作，保证每个动作都是常数时间
3. 数据量为n，看基本动作和n的关系
4. 得到表达式后，把最高阶系数去掉并且只保留最高阶

<br/><br/>



### 4、额外的空间复杂度

和目的有关的开辟空间不算额外

<br/><br/>


### 5、对数器

用暴力解和你想出来的优解比较，验证解的准确性

<br/><br/>


### 6、Master公式求复杂度

> 这种公式只能用递归问题，并且子问题规模一样的时候才可以用，比如二分，子问题规模n/2
>
<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220803032629.png" width="70%" height="70%" />





## 二、二分法

### 模版

```cpp
bool check(int x) {/* ... */} // 检查x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：
int bsearch_1(int l, int r)
{
    while (l < r)
    {
        int mid = l + r >> 1;
        if (check(mid)) r = mid;    // check()判断mid是否满足性质
        else l = mid + 1;
    }
    return l;
}

// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：
int bsearch_2(int l, int r)
{
    while (l < r)
    {
        int mid = l + r + 1 >> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}

```



### 1、普通二分查找

<br/><br/>

### 2、在一个有序的数组中找>=某个值的最左侧位置

> 算法如下

```Java
int index=-1;

while(l<=r){

  mid=(l+r)/2
  if(a[mid]>=value) index =mid;r=mid-1 
   else l=mid+1

}
return index
```


<br/><br/>

### **3、局部最小值**

> 1. 先判断0位置和n-1位置是不是局部最小值
>    a[1]>a[0]或者a[n-1]<a[n-2]这两个都是局部最小值
>    如果端点没有，那么局部最小值一定在中间，因为先下降再上升，所以可以用二分
>     mid、left=1、right=n-2
>
> 2. 如果a[mid-1]<a[mid]那么局部最小值在mid左边，r=mid-1；
>
> 3. 如果a[mid+1]<a[mid]在右边
>
> 4. 反之两边都大于a[mid]，那么mid就是局部最小值的坐标，返回
>
> 5. 结尾return left

<br/><br/>

### 4、例题

>还有给一个不降序的数组，让你找出一个数，小于等于这个数的最右边，大于等于这个数的最左边
>
>也就是 1 2 2 2 2 3 找出2区间的头和尾坐标
>
>具体题目看代码笔记本

```java
while(l<=r){
        mid=(r+l)/2;
        if(num[mid]>=target){
        index1=mid;
        r=mid-1;
        }else l=mid+1;
        }
```

```java
while(l<=r){
        mid=(r+l)/2;
        if(num[mid]<=target){
        index2=mid;
        l=mid+1;
        }else r=mid-1;
 }
```

<br/><br/>



### 5、最小化最大值问题

这种很可能用二分，具体看错题集



## 三、异或运算

### 1、异或运算概念

>把两个数化为二进制
>然后上下对其(长的前面补零)
>相同为0不同为1
>
>比如：1001110000
>
>​           0111101110
>
>结果是：1110011110
>
>这就是异或运算

<br/><br/>

### 2、性质(重点)

> + 0^n=n;
> + n^n=0
> + 满足交换律和结合律


<br/><br/>

### 3、交换两个数

> int a=甲   int b=已
>
> a=a^b       a变成甲^乙
>
> b=a^b         甲^乙^乙=甲
>
> a=a^b          甲^乙^甲=乙

<br/><br/>

### 4、题目

1、找出一个数组中一种数出现了奇数次，其余全是偶数

> 直接让数组全部异或运算,最后结果就是这个数

<br/><br/>

2、把一个int类型的数最右侧的1取出来

> 结论：n&(~(n)+1)
>
> &相同为1，不同为0

<br/><br/>

3、找数组中两个数是奇数个的

解法：

> 假设这两个数分别是a,b
>
> 首先让数组全部异或运算，得到e=a^b
>
> 然后用上面的结合计算把e最右侧1取出来 记作w
>
> 在这个位置上，a,b两个数肯定一个是1,一个是0
>
> 然后遍历数组和w&运算,因为w只有一位为1,其余为0,

```java
public void find(int []arr){
    int eor=0;
    for(int i=0;i<arr.length;i++){
        eor=eor&arr[i];
    }
    //eor=a^b 且！=0
    int rightone=eor&(~(eor)+1);
    int onlyone=0;
    for(int i=0;i<arr.length;i++){
        if((arr[i]&(rightone))!=0){
            onlyone=onlyone^arr[i];
        }
    }
    System.out.println(onlyone+"  "+(eor^onlyone));
}
```


<br/><br/>


### 5、&运算

**同时为1才取1**

 //取出第i位的数字
            int u=x>>i&1;

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724075216.png" width="70%" height="70%" />



<br/><br/>

a&-a可以得到最右边的1

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            int sum=0;
            int x=in.nextInt();
            while(x>0){
                int a=method(x);
                x=x-a;
                sum++;
            }
            System.out.print(sum+" ");
        }
    }
    public static int method(int a){
        return a&(-a);
    }
}
```

<br/><br/>

>取出二进制为1的数

```c++
 for(int i = 0;i<32;i++){        
     if((n>>i&1)==1)list.add((n>>i&1)<<i);     
 }
```
<br/><br/>

### 5、移位

a<<b  a乘了b个2


<br/><br/>

### 6、|  

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220915025144.png" width="70%" height="70%" />


<br/><br/>


## 四、排序

### 1、快速排序

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        long []num=new long[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextLong();
        }
        quick_sort(num,0,n-1);
        for(int i=0;i<n;i++){
            System.out.print(num[i]+" ");
        }
    }
    public static void quick_sort(long[]num,int l,int r){
        if(l>=r)return;
        int left=l-1;
        int right=r+1;
        long mid=num[(l+r)/2];
        while(left<right){
            while(num[++left]<mid);
            while(num[--right]>mid);
            if(left<right){
                long temp=num[left];
                num[left]=num[right];
                num[right]=temp;
            }
        }
        quick_sort(num,l,right);
        quick_sort(num,right+1,r);
    }
}
```

<br/><br/>

```cpp
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        while (q[++ i] < x);
        while (q[-- j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}

```



### 2、插入排序

```java
public class insert {
    public static void main(String[] args) {
        int []a={2000000,9,-1,40,2,5,99,32,10000,-10000};
        int n=a.length;
        for(int i=1;i<n;i++){
            int num=a[i];
            int index=i;
            while(index-1>=0&&a[index-1]>num){
                a[index]=a[index-1];
                index--;
            }
            a[index]=num;
        }
        System.out.println(Arrays.toString(a));
    }
}
```

<br/><br/>

### 3、希尔排序

```java
public class xiersort2 {
    public static void main(String[] args) {
        int []a={111,4,5,6,7,-1,1,10,9};
        int n=a.length/2;
        for(;n>0;n=n/2){
            //从n开始，对其所在的组直接插入
            for(int i=n;i<a.length;i++){
                int j=i; 
                int temp=a[i];
                    while(j-n>=0&&temp<a[j-n]){
                        a[j]=a[j-n];
                        j=j-n;
                    }
                 a[j]=temp;
            }
        }
        System.out.println(Arrays.toString(a));
    }
}
```

<br/><br/>

### 4、归并排序

```java
public class dividsort {
    public static void mag(int []a,int left,int right){
        if(left==right)return;
        int mid=(left+right)/2;
        //向左递归
        mag(a,left,mid);
        //向右
        mag(a,mid+1,right);
        sort(a,left,right,mid);
    }
    //并的过程
    public static void sort(int []a,int left,int right,int mid){
        //左侧从left到Mid，右侧从Mid+1到right
        int p1=left;
        int p2=mid+1;
        int []help=new int[right-left+1];

        int index=0;
        while(p1<=mid&&p2<=right){
            if(a[p1]<=a[p2]){
                help[index++]=a[p1++];
            }else {
                help[index++]=a[p2++];
            }
        }

        while(p1<=mid){
            help[index++]=a[p1++];
        }
        while(p2<=right){
            help[index++]=a[p2++];
        }
        for(int i=0;i<help.length;i++){
            a[i+left]=help[i];
        }
    }
    public static void main(String[] args) {
        int []a={99,45,333,-11,1,6,9,2,7,0};
         mag(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }
}
```

<br/><br/>

```cpp
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);

    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}

```




#### 题目

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220805022546.png" width="70%" height="70%" />

<br/><br/>


<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807034332.png" width="70%" height="70%" />




<br/><br/>

### 5、基数排序

只能对正数进行排序

```java
public class radixsory {
    public void radsort(int []a) {
        int max = a[0];//得出大的数
        for (int i = 1; i < a.length; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }
        String s = max + "";
        int maxsize = s.length();//计算最高位是多少
        int[][] radix = new int[10][a.length];//定义十个桶，每个桶长度为数组长度
        int[] number = new int[10];//记录每个桶有多少个元素

        for (int i = 0, n = 1; i < maxsize; i++, n = n * 10) {
            for (int j = 0; j < a.length; j++) {
                int dignumber = a[j] / n % 10;//取出每个元素对应位数的值
                radix[dignumber][number[dignumber]] = a[j];//将对应值放入桶中
                number[dignumber]++;//将对应桶元素个数加一
            }
            //将桶中元素俺顺序放回原来数组
            int index = 0;
            for (int j = 0; j < 10; j++) {
                if (number[j] != 0) {
                    for (int w = 0; w < number[j]; w++) {
                        a[index++] = radix[j][w];
                    }
                }
                number[j] = 0;
            }
        }
    }
    public static void main(String[] args) {
        int []a={4,5,33,12,1,45,1,12,222,3};
        radixsory p=new radixsory();
        p.radsort(a);
        System.out.println(Arrays.toString(a));
    }
}
```


<br/><br/>


### **6、堆排序**

```java
import java.util.*;
public class Main{
    static int size;
    static int[]heap;
    public static void down(int i){
        int parent=i;
        int child=0;
        int temp=heap[i];
        for(;parent*2+1<size;parent=child){
            child=parent*2 + 1;
            if(child+1<size&&heap[child+1]>heap[child])child++;
            if(temp>=heap[child])break;
            heap[parent]=heap[child];
        }
        heap[parent]=temp;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        heap=new int[n];
        size=n;
        for(int i=0;i<n;i++){
            heap[i]=in.nextInt();
        }
        for(int i=n/2;i>=0;i--){
            down(i);
        }
        for(int i=0;i<n;i++){
            int temp=heap[0];
            heap[0]=heap[--size];
            heap[size]=temp;
            down(0);
        }
        for(int i=0;i<n;i++){
            System.out.print(heap[i]+" ");
        }
    }
}
```


<br/><br/>


## 五、前缀和

### 1、一维

> 概念：比如一个数组a   a0 a1 a2 a3 a4.... an
>
> 又有一个数组S    s1=s1   s2=a1+a2  s3 =a1+a2+a3  前缀和一般数组重下标为1开始



**求S：所以  Sn=an+Sn-1**

用途 求数组中a一个区间[l,r]的和

可以用Sr-Sl-1;
<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715163138.png" width="70%" height="70%" />



```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int l;
        int r;
        //下标从一开始
        int []num=new int[n+1];
        int []dp=new int[n+1];
        for(int i=1;i<=n;i++){
            num[i]=in.nextInt();
            dp[i]=dp[i-1]+num[i];
        }
        for(int i=0;i<m;i++){
            l=in.nextInt();
            r=in.nextInt();
            System.out.println(dp[r]-dp[l-1]+" ");
        }
    }
}


```

<br/><br/>

### 2、二维**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/v2-164e5df46fcfaaa6a3bc9ce325b08f4a_720w.jpg" width="70%" height="70%" />





求一块区域的面积,一般让下标从零开始

  a00         a01       a02      a03     a04

  a10        a11        a12       a13     a14

  a20        a21        a22      a23     a24

  a30         a31       a32      a33     a34

 a40         a41         a42     a 43     a44

> Sij右下角下标为i j 的矩形的面积
>
> 这时候有递推Sij=s(i-1)j+si(j-1)-s[i-1] [j-1]+a[i]  [i]
>
> 比如要求x1,y1为左上角，x2,y2为右下角面积
>
> 减去重复的，要加上
>
> 总的面积是S(x2)(y2) -S(x2)(y-1)-S(x1-1)(y2)+S(x1-1)(y1-1)
>
> 最后算出结果

输入一个数组，并且循环次数，给出左上角和右下角下标，求子矩阵的面积

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int q=in.nextInt();
        int [][]num=new int[n+1][m+1];
        int [][]s=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                num[i][j]=in.nextInt();
            }
        }
        //构造S
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+num[i][j];
                //System.out.println(s[i][j]);
            }
        }
        for(int i=0;i<q;i++){
            int x1=in.nextInt();
            int y1=in.nextInt();
            int x2=in.nextInt();
            int y2=in.nextInt();
            int sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1];
            System.out.println(sum);
        }
    }
}
```

<br/><br/>

## 六、差分**

### 1、一维差分

差分就是前缀和的逆运算

两个数组： 

+ a数组
+ b数组
+ ai=b0+...bi

a是b的前缀和，b是a的差分数组

**b1=a1    b2=a2-a1   b3=a3-a2    b4=a4-a3       大概是这样**



>  具体运用：比如要在原数组a中一段【l,r】中的每一个数都加c，那么可以运用差分数组，降低时间复杂度

   可以让 b(l)+c    让 b(r+1)-c；

>  一般下标从一开始，比较好处理数据

原理可以看：b1   b2  b3  b4  b5  b6  b7 

要在a1到a4每个数加一

**可以让b1+1     结果是a1到后面每一个前缀和都加一   但是我们只希望加到下标为4的地方 ，所以b(5)-1  让a5后面的数减一，一加一减抵消了，只有1到4是加了1**

因为a是b的前缀和，最后在求一遍前缀和  b[i]=b[i-1]+b[i];

输出b[i]就行了，就是改变后的a数组

下面看一道例题：

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []num=new int[n+2];
        int []b=new int[n+2];
        for(int i=1;i<=n;i++){
            num[i]=in.nextInt();
            insert(b,i,i,num[i]);
        }
        for(int i=0;i<m;i++){
            int l=in.nextInt();
            int r=in.nextInt();
            int c=in.nextInt();
            insert(b,l,r,c);
        }
        for(int i=1;i<=n;i++){
            b[i]=b[i]+b[i-1];
        }
        for(int i=1;i<=n;i++)System.out.print(b[i]+" ");
    }
    public static void insert(int []num,int i,int j,int c){
        num[i]+=c;
        num[j+1]-=c;
    }
}
```



**值得注意的是，我们不用特意构造b数组，我们可以想象a数组初始为0，然后，然后在i到i上加a[i],也就是差分运算，最后得出的就是b数组**

<br/><br/>

### 2、二维差分

二维差分也是一样，我们的目的是让子矩阵中的每个元素加一个常数c

  a00         a01       a02      a03     a04

  a10        a11        a12       a13     a14

  a20        a21        a22      a23     a24

  a30         a31       a32      a33     a34

 a40         a41         a42     a 43     a44

```
再次说明，我们下标一般从一开始，这样子就不用判断下标等于0的时候怎么操作了，比较方便

我们假设子矩阵的左上角x1,y1,右下角为x2,y2

我们让b(x1)(y1)+=c这样右下角整块大的矩阵就全部加上了c

所以b(x2+1)(y1)-=c       b(x1)(y2+1)-=c    又因为重复减了   所以b(x2+1)(y2+1)+=c

最后我们在用老办法前缀和求二维数组b
```



> **记住，我们初始化b也可以用上面的公式，不用刻意去记住怎么初始化b**

下面是例题，给出，n,m,q 然后输入数组，在输入q组数据x1,y1,x2,y2  c 这块区域加c最后输出数组的样子

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int q=in.nextInt();
        int [][]a=new int[n+2][m+2];
        int [][]b=new int[n+2][m+2];
        //构造a数组和b数组
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                a[i][j]=in.nextInt();
                insert(i,j,i,j,b,a[i][j]);
            }
        }
        //差分数组b的构建
        for(int i=0;i<q;i++){
            int x1=in.nextInt();
            int y1=in.nextInt();
            int x2=in.nextInt();
            int y2=in.nextInt();
            int c=in .nextInt();
            insert(x1,y1,x2,y2,b,c);
        }
        //和前缀和数组一样，求出来
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                a[i][j]=b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
                System.out.print(a[i][j]+" ");
            }
            System.out.println();
        }


    }
    public static void insert(int x1,int y1,int x2,int y2,int [][]b,int c){
        b[x1][y1]+=c;
        b[x2+1][y1]-=c;
        b[x1][y2+1]-=c;
        b[x2+1][y2+1]+=c;
    }

}
```

<br/><br/>

## 七、图论

### 1、迪杰斯拉算法

```java
public class Dijkstra {
    //有权图单源最短路
    static int[][] graph;
    static int node;//结点数
    static int edge;//边数
    static int[] path;
    static int dist[];
    static int flag;
    static HashSet<Integer> set = new HashSet<>();//判断是否被收录

    //初始化
    public static void creat() {
        for (int i = 1; i < node; i++) {
            dist[i] = 1000;
            path[i] = -1;
        }
        dist[flag] = 0;
        graph[1][2] = 2;
        graph[1][4] = 1;
        graph[2][4] = 3;
        graph[2][5] = 10;
        graph[3][1] = 4;
        graph[3][6] = 5;
        graph[4][3] = 2;
        graph[4][6] = 8;
        graph[4][7] = 4;
        graph[4][5] = 2;
        graph[5][7] = 6;
        graph[6][7] = 1;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("输入结点和边");
        node = in.nextInt();
        edge = in.nextInt();
        graph = new int[node][node];
        path = new int[node];
        dist = new int[node];
        flag = 1;
        creat();
        Dijkstra();
        printpath();
    }

    //具体算法
    public static void Dijkstra() {
        while (true) {
            int v = -1;
            int min = 100000;
            //对于没有被收录进去的结点，找出dist最小的
            for (int i = 1; i < node; i++) {
                if (set.contains(i) == false) {
                    if (dist[i] < min) {
                        min = dist[i];
                        v = i;
                    }
                }
            }

            //已经全部收录了
            if (min == 100000) break;
            set.add(v);
            for (int i = 1; i < node; i++) {
                if (graph[v][i] > 0 && set.contains(i) == false) {
                    if (dist[v] + graph[v][i] < dist[i]) {
                        dist[i] = dist[v] + graph[v][i];
                        path[i] = v;
                    }
                }
            }
        }
    }

    public static void printpath() {
        Scanner in = new Scanner(System.in);
        Stack<Integer> queue = new Stack<>();
        while (true) {
            System.out.println("输入结点");
            int n;
            n = in.nextInt();
            System.out.println("最短路径为" + dist[n]);
            while (n != -1) {
                queue.add(n);
                n = path[n];
            }
            while (!queue.isEmpty()) {
                System.out.print(queue.pop() + " ");
            }
        }
    }
}
```

<br/><br/>

### 2、floyd算法

递归打印路径

```java
class floyd {
    static int [][]graph;
    static int node;
    static int edge;
    static int[][]path;

    public static void insert(){
        for(int i=1;i<node;i++){
            for(int j=1;j<node;j++){
                graph[i][j]=1000;
                path[i][j]=-1;
            }
        }
        graph[1][2]=2;
        graph[1][4]=1;
        graph[2][4]=3;
        graph[2][5]=10;
        graph[3][1]=4;
        graph[3][6]=5;
        graph[4][3]=2;
        graph[4][6]=8;
        graph[4][7]=4;
        graph[4][5]=2;
        graph[5][7]=6;
        graph[7][6]=1;
    }

    public static void printpath(){
        Scanner in=new Scanner(System.in);
        while(true){
            System.out.println("输入两个结点");
            int n1= in.nextInt();
            int n2= in.nextInt();
            if(graph[n1][n2]==1000) System.out.println("两点之间无通路");
            else{
                System.out.println("路径长度为"+graph[n1][n2]);
                System.out.print("最短路径为："+n1+" ");
                dfs(n1,n2);
                System.out.print(n2);
            }
        }
    }
    public static void dfs(int i,int j){
        if(path[i][j]>=0){
            dfs(i,path[i][j]);
            System.out.print(path[i][j]+" ");
            dfs(path[i][j],j);
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        System.out.println("输入定点和边");
        node= in.nextInt();
        edge= in.nextInt();
        graph=new int[node][node];
        path=new int[node][node];
        insert();
        flyed();
        printpath();
    }

    //具体算法floyed
    public static void flyed(){
        for(int k=1;k<node;k++){
            for(int i=1;i<node;i++){
                for(int j=1;j<node;j++){
                    if(graph[i][k]+graph[k][j]<graph[i][j]){
                        graph[i][j]=graph[i][k]+graph[k][j];
                        path[i][j]=k;
                    }
                }
            }
        }
    }
}
```

<br/><br/>

### **3、最小生成树**

```java
public class prime {
    //prime求最小生成树
    static int [][]graph;//图本身
    static int [][]tree;//最小生成树
    static int node;//结点数
    static int edge;//边数
    static boolean []vist;
    static boolean[]flag;
    static int start=4;
    //图的初始化
    public static void creat(){
        graph=new int[node+1][node+1];
        tree=new int[node+1][node+1];
        vist=new boolean[node+1];
        flag=new boolean[node+1];
        //图初始化为-1，表示两个结点之间没有联通
        for(int i=1;i<=node;i++){
            for(int j=1;j<=node;j++){
                graph[i][j]=-1;
                tree[i][j]=-1;
            }
        }
       graph[1][2]=graph[2][1]=2;
       graph[1][3]=graph[3][1]=4;
       graph[1][4]=graph[4][1]=1;
       graph[2][4]=graph[4][2]=3;
       graph[2][5]=graph[5][2]=10;
       graph[3][6]=graph[6][3]=5;
       graph[3][4]=graph[4][3]=2;
       graph[4][5]=graph[5][4]=7;
       graph[5][7]=graph[7][5]=6;
       graph[4][6]=graph[6][4]=8;
       graph[4][7]=graph[7][4]=4;
       graph[6][7]=graph[7][6]=1;
    }
    public static void MakeTree(){
        int sum=0;
        int h1=-1;
        int h2=-1;
        int min=100000;
        vist[start]=true;
        for(int k=1;k<node;k++){
            min=100000;
            for(int i=1;i<=node;i++){
                for(int j=1;j<=node;j++){
                    if(vist[i]==false)break;
                    else {
                        if(vist[j]==false&&graph[i][j]>0){
                           if(min>graph[i][j]){
                               h1=i;
                               h2=j;
                               min=graph[i][j];
                           }
                        }
                    }
                }
            }
            sum=sum+graph[h1][h2];
            System.out.println("收录定点为<"+h1+","+h2+">"+"权重"+graph[h1][h2]);
            tree[h1][h2]=graph[h1][h2];
            vist[h2]=true;
        }
        System.out.println("总权等于:"+sum);
    }
    public static void dfs(int v){
        Queue <Integer>queue=new LinkedList<>();
        queue.add(v);
        while(!queue.isEmpty()){
            v=queue.poll();
            System.out.println(v);
            for(int i=1;i<=node;i++){
                if(tree[v][i]>0&&flag[i]==false){
                    flag[i]=true;
                    queue.add(i);
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        System.out.println("输入结点数和边数");
        node= 7;
        edge= 12;
        creat();
        MakeTree();
        //遍历树
        dfs(start);
    }
}
```

<br/><br/>

并查集加最小堆

```java
public class Kruskal {
    static int[][]graph;
    static  int[][]tree;
    static  int node;
    static  int edge;
    static boolean[]flag;
    static int start=1;
    //把边加入里面，按从小到大排序
    static List<Edge> list=new ArrayList<>();
    //并查集
    static int[]num;
    //并查集主体
     static HashMap<Integer,Integer>map=new HashMap<>();
    //初始化
    public static void creat(){
        graph=new int[node+1][node+1];
        tree=new int[node+1][node+1];
        flag=new boolean[node+1];
        //图初始化为-1，表示两个结点之间没有联通
        for(int i=1;i<=node;i++){
            for(int j=1;j<=node;j++){
                graph[i][j]=-1;
                tree[i][j]=-1;
            }
        }
        graph[1][2]=graph[2][1]=2;
        graph[1][3]=graph[3][1]=4;
        graph[1][4]=graph[4][1]=1;
        graph[2][4]=graph[4][2]=3;
        graph[2][5]=graph[5][2]=10;
        graph[3][6]=graph[6][3]=5;
        graph[3][4]=graph[4][3]=2;
        graph[4][5]=graph[5][4]=7;
        graph[5][7]=graph[7][5]=6;
        graph[4][6]=graph[6][4]=8;
        graph[4][7]=graph[7][4]=4;
        graph[6][7]=graph[7][6]=1;
        //把边加入集合
        for(int i=1;i<=node;i++){
            map.put(i,i);
            for(int j=1;j<=node;j++){
                if(graph[i][j]>0&&i<=j){
                    list.add(new Edge(i,j,graph[i][j]));
                }
            }
        }
        Collections.sort(list);
        //验证
       for(Edge k:list){
           System.out.println(k);
       }
        System.out.println(map);
    }
    public static void main(String[] args) {
        node= 7;
        edge= 12;
        creat();
        num=new int[node+1];
        Kruskal();
        dfs(start);
    }
    //算法本身
    public static void Kruskal(){
        int n=list.size();
        for(int i=0;i<n;i++){
            Edge p=list.get(0);
            list.remove(0);
            int k1=p.start;
            int k2=p.end;
            int weight=p.weight;
            //寻找根
            int root1=root(k1);
            int root2=root(k2);

            if(root1==root2)continue;
            else {
                map.put(root1,root2);
                tree[k1][k2]=tree[k2][k1]=weight;
            }
        }
    }
    //并查集
    public static int root(int i){
        while(map.get(i)!=i){
            i=map.get(i);
        }
        return i;
    }
    public static void dfs(int v){
        Queue<Integer> queue=new LinkedList<>();
        queue.add(v);
        flag[v]=true;
        while(!queue.isEmpty()){
            v=queue.poll();
           System.out.println(v);
            for(int i=1;i<=node;i++){
                if(tree[v][i]>0&&flag[i]==false){
                    flag[i]=true;
                    queue.add(i);
                }
            }
        }
    }
}
//记录两点的边
class Edge implements Comparable<Edge>{
    public int start;
    public int end;
    public int weight;

    public Edge(int start, int end, int weight) {
        this.start = start;
        this.end = end;
       this.weight=weight;
    }

    @Override
    public String toString() {
       return start+"->"+end+",权重是"+weight;
    }

    //按权重大小排序
    @Override
    public int compareTo(Edge o) {
        return Double.compare(this.weight,o.weight);
    }
}
```

<br/><br/>

### **4、哈夫曼树**

> 每次选出最小的连个值，加起来生成新的结点，加入到集合中，重复操作，运用到最小堆

```java
public class huffmantree {
    //返回哈夫曼树
    public static Node1 creathuffmantree(int []a) {
        //将每个元素转换为Node然后放到集合中
        List<Node1> list = new ArrayList<>();
        for (int k : a) {
            list.add(new Node1(k));
        }
        while (list.size() > 1) {
            //从小到大排序
            Collections.sort(list);
            //取出权值最小的两颗二叉树,构建新的二叉树
            Node1 leftNode = list.get(0);
            Node1 rightNode = list.get(1);
            Node1 parent = new Node1(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            //删除掉两个最小结点
            list.remove(0);
            list.remove(0);
            list.add(parent);
        }
        return list.get(0);
    }
    //哈夫曼树
    public static void main(String[] args) {
        int []a={13,7,8,3,29,6,1};
        //得到哈夫曼树的头结点
        Node1 head=creathuffmantree(a);
        Node1 p=new Node1();
        p.pre(head);
    }
}
//创建结点
//让Node支持排序,实现comparable接口
class Node1 implements Comparable<Node1>{
    int value;//结点的权值
    Node1 left=null;
    Node1 right=null;

    public Node1(){

    }
    public Node1(int value){
        this.value=value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }


    @Override
    public int compareTo(Node1 o) {
        return Double.compare(this.value,o.value);
    }
    public void pre(Node1 head){
        if(head==null)return;
        System.out.println(head);
        pre(head.left);
        pre(head.right);
    }
}
```

​	

<br/><br/>

## 八、双指针	

一般先找出暴力做法，然后优化，具体题目不同，可以看错题集


<br/><br/>

## 九、合并区间


<br/><br/>


## 十、定制排序(重要)

定制排序如果多个参数，比较的时候要多次比较，比如这个参数不想等，返回另一个参数

### 1、TreeSet
<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724171353.png" width="70%" height="70%" />



```java
class FoodRatings {
    HashMap<String,count>map1=new HashMap<>();///对象名加类
    HashMap<String, TreeSet<count>>map2=new HashMap<>();//烹饪方式加类
    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        for(int i=0;i<foods.length;i++){
            String s=foods[i];
            String s2=cuisines[i];
            int score=ratings[i];
            count p=new count(s,score,s2);
            map1.put(s,p);
            if(map2.get(s2)==null){
                TreeSet<count>set=new TreeSet<>();
                set.add(p);
                map2.put(s,set);
            }else {
                map2.get(s2).add(p);
            }
        }
    }

    public void changeRating(String food, int newRating) {
         count p=map1.get(food);
         String s=p.cuisinesname;
         map2.get(s).remove(p);
         p.score=newRating;
         map2.get(s).add(p);

    }

    public String highestRated(String cuisine) {
         return map2.get(cuisine).last().cuisinesname;
    }
}
class count implements Comparable<count> {
    public String foodname;
    public int score;
    public String cuisinesname;

    public count(String foodname, int score, String cuisinesname) {
        this.foodname = foodname;
        this.score = score;
        this.cuisinesname = cuisinesname;
    }

    public void setFoodname(String foodname) {
        this.foodname = foodname;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public void setCuisinesname(String cuisinesname) {
        this.cuisinesname = cuisinesname;
    }

    public String getFoodname() {
        return foodname;
    }

    public int getScore() {
        return score;
    }

    public String getCuisinesname() {
        return cuisinesname;
    }


    @Override
    public int compareTo(count o) {
        if(this.score!=o.score)return Integer.compare(this.score,o.score);
        return -this.foodname.compareTo(o.foodname);
    }
}
```

<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724171542.png" width="70%" height="70%" />



```java
class NumberContainers {
    HashMap<Integer,Integer>map1;
    HashMap<Integer,TreeSet<Integer>>map2;
    public NumberContainers() {
        map1=new HashMap<>();
        map2=new HashMap<>();
    }
    public void change(int index, int number) {
        if(map1.get(index)==null){
            map1.put(index,number);
        }else{
            //System.out.println(map1.get(index));
            TreeSet<Integer>set=map2.get(map1.get(index));
            set.remove(index);
            map1.put(index,number);
        }
        if(map2.get(number)==null){
            TreeSet set1=new TreeSet<>();
            set1.add(index);
            map2.put(number,set1);
        }else {
            map2.get(number).add(index);
        }
    }

    public int find(int number) {
        if(map2.get(number)==null||map2.get(number).size()==0)return-1;
        return map2.get(number).first();
    }
}
```


<br/><br/>

## 十一、并查集

### 简介：

> 简单思路就是把相关的边全部放到一起，两个方法，一个找出根，这里用路径压缩，减少查询次数，还有一个方法是联通，如果根不同，直接联通。这里不用判断哪个根链接哪个，除非特殊情况。
>


<br/><br/>

### 1、无法达到的点数

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724195813.png" width="70%" height="70%" />





> 把所有元素并查集串起来，查找根的时候可以用路径压缩，然后遍历的时候用Map可以降低时间复杂度。同时这题可以用dfs做



```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        int []parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
        for(int i=0;i<edges.length;i++){
            merge(edges[i][0],edges[i][1],parent);
        }
        long sum=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            int root=findroot(i,parent);
            if(map.get(root)==null)map.put(root,1);
            else map.put(root,map.get(root)+1);
        }
        for(int k:map.keySet()){
            long count=map.get(k);
            sum+=(n-count)*count;
        }
        return sum/2;
    }
    public void merge(int a,int b,int []parent){
        int k1=findroot(a,parent);
        int k2=findroot(b,parent);
        if(a==b)return;
        parent[k1]=k2;
    }
    //路径压缩
    public int findroot(int a,int []parent){
        if(parent[a]!=a)parent[a]=findroot(parent[a],parent);
        return parent[a];
    }
}
```

<br/><br/>



### 2、联通数(难)

<img src="C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220730003126.png" width="70%" height="70%" />



```java
class Solution {
    int[]parent;
    public int largestComponentSize(int[] nums) {
        int n=0;
        for(int i=0;i<nums.length;i++){
            n=Math.max(n,nums[i]);
        }
        parent=new int[n+1];
        for(int i=0;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<nums.length;i++){
            int k=nums[i];
            for(int j=2;j*j<=k;j++){
                if(k%j==0){
                    union(j,k);
                    union(j,k/j);
                }
            }
        }
        int max=0;
        int []count=new int[n+1];
        for(int i=0;i<nums.length;i++){
            int root=findroot(nums[i]);
            count[root]++;
            max=Math.max(max,count[root]);
        }
        return max;
    }

    //联通
    public void union(int root1,int root2){
        int k1=findroot(root1);
        int k2=findroot(root2);
        if(k1==k2)return;
        if(k1<k2)
            parent[k1]=k2;
        else parent[k2]=k1;
    }

    //寻找跟，路径压缩
    public int findroot(int x){
        if(parent[x]!=x){
            parent[x]=findroot(parent[x]);
        }
        return parent[x];
    }
}
```


<br/><br/>


### 拓展

>+ 记录每个集合的大小，和根绑定
>+ 记录每个点到根节点的距离

<br/><br/>

### 格子游戏

> 思路：在划线的时候，判断两个点是否在一个集合，如果是，就结束，否则用并查集并起来
>            把二维坐标转换为一个数

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230114105348.png" width="70%" height="70%" />





代码：

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 40010;
int p[N];
int n,m;

int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

//将一维坐标映射为二维只不过要求坐标从0开始
int get(int a,int b){
    return a*n + b;
}

int main(){
   cin>>n>>m;
   for(int i = 0;  i <= n*n ; i ++){
       p[i] = i;
   }
  
   int sum = 0;
   for(int i = 1 ;i <=m ; i ++){
       int x,y;
       char d;
       cin>>x>>y>>d;
       x --;
       y --;
       //坐标的编号
       int a = get(x,y);
       int b;
       
       if(d == 'D')b = get(x + 1,y);
       else b = get(x,y + 1);
       
       int root1 = find(a);
       int root2 = find(b);
       if(root1 == root2){
           sum = i;
           break;
       }
       p[root1] = root2;
   }
   
   if(sum == 0){
       cout<<"draw"<<endl;
   }else {
       cout<<sum<<endl;
   }
}
```


<br/><br/>

### 搭配购买  

> 思路：
> 用并查集来联通相同的云，然后维护这个区域的最大价值
> 然后用01背包求最大值

代码1

>背包还可以简化，这个代码可能会超时
>因为上一个物品不一定是 i -1所以要维护一个last

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 10010;
int p[N];
//价值和价钱
int w[N],v[N];
int f[N][N];
int n,m,vol;

int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin>>n>>m>>vol;
    for(int i = 0 ; i<= n ; i ++)p[i] = i;
    for(int i = 1 ; i<= n ; i ++)cin>>v[i]>>w[i];
    
    while(m --){
        int a,b;
        cin>>a>>b;
        int root1 = find(a),root2 = find(b);
        if(root1 != root2){
            w[root2] += w[root1];
            v[root2] += v[root1];
            p[root1] = root2;
        }
    }
    
    int mx = 0;
    //01背包
    int last = -1;
    int sum = 0;
    for(int i = 1 ;i <= n ;i  ++){
        if(p[i] != i)continue;
        for(int j = 0; j <= vol ; j ++){
            if(last == -1){
                if(v[i] <= j)
                f[i][j] = max(f[i][j],w[i]);
               
            }
            else {
                f[i][j] = f[last][j];
                if(j >= v[i])
                f[i][j] = max(f[i][j],f[last][j - v[i]] + w[i]);
            }
        }
        last = i;
    }

    cout<<f[last][vol]<<endl;
}
```

<br/><br/>

代码2

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 10010;
int p[N];
//价值和价钱
int w[N],v[N];
int f[N];
int n,m,vol;

int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    cin>>n>>m>>vol;
    for(int i = 0 ; i<= n ; i ++)p[i] = i;
    for(int i = 1 ; i<= n ; i ++)cin>>v[i]>>w[i];
    
    while(m --){
        int a,b;
        cin>>a>>b;
        int root1 = find(a),root2 = find(b);
        if(root1 != root2){
            w[root2] += w[root1];
            v[root2] += v[root1];
            p[root1] = root2;
        }
    }
    
    //01背包
    for(int i =1 ;i <= n ;i  ++){
        if(p[i] != i)continue;
        for(int j = vol ; j>= v[i] ; j --){
            f[j] = max(f[j],f[j - v[i]] + w[i]);
        }
    }
    cout<<f[vol]<<endl;
}
```
<br/><br/>
题目

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230114114859.png" width="70%" height="70%" />







### **程序自动分析**

题目

```tex
在实现程序自动分析的过程中，常常需要判定一些约束条件是否能被同时满足。

考虑一个约束满足问题的简化版本：假设 x1,x2,x3,… 代表程序中出现的变量，给定 n 个形如 xi=xj 或 xi≠xj 的变量相等/不等的约束条件，请判定是否可以分别为每一个变量赋予恰当的值，使得上述所有约束条件同时被满足。

例如，一个问题中的约束条件为：x1=x2，x2=x3，x3=x4，x1≠x4，这些约束条件显然是不可能同时被满足的，因此这个问题应判定为不可被满足。

现在给出一些约束满足问题，请分别对它们进行判定。

输入格式
输入文件的第 1 行包含 1 个正整数 t，表示需要判定的问题个数，注意这些问题之间是相互独立的。

对于每个问题，包含若干行：

第 1 行包含 1 个正整数 n，表示该问题中需要被满足的约束条件个数。

接下来 n 行，每行包括 3 个整数 i,j,e，描述 1 个相等/不等的约束条件，相邻整数之间用单个空格隔开。若 e=1，则该约束条件为 xi=xj；若 e=0，则该约束条件为 xi≠xj。

输出格式
输出文件包括 t 行。

输出文件的第 k 行输出一个字符串 YES 或者 NO，YES 表示输入中的第 k 个问题判定为可以被满足，NO 表示不可被满足。

数据范围
1≤n≤105
1≤i,j≤109
```



> 分析
>
> 先考虑相等情况，不可能有矛盾
> 在考虑所有不等的情况   -> 如果xi != xj  如果我们通过前面的结果他们两个在一个集合，那么有矛盾
> 由于题目的范围很大，但是数很小，所以我们考虑用离散化来实现
> 把两个相等的数并在一起
> 最后再判断不等的数是否相等


<br/><br/>

代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include <unordered_map>
#include <unordered_set>

const int N = 2000010;
struct query{
    int x,y,e;
}q[N];

int n,m;
int p[N];
unordered_map<int,int>mp;

//离散化
int get(int x){
    if(mp.count(x) == 0){
        mp[x] = ++n;
    }
    return mp[x];
}

int find(int x)  // 并查集
{
    if (p[x] != x) p[x] = find(p[x]);
    return p[x];
}

int main(){
    int t;
    scanf("%d",&t);
    while(t --){
        mp.clear();
        n = 0;
        scanf("%d",&m);
        
        for(int i = 0 ; i < m ; i ++){
        int x,y,e;
        scanf("%d%d%d",&x,&y,&e);
        q[i] = {get(x),get(y),e};
      }
      
      for(int i = 1  ;i  <= n; i ++)p[i] = i;
      
      //合并所有相等的数
      for(int i = 0 ; i < m ; i ++){
          if(q[i].e == 1){
              int root1 = find(q[i].x);
              int root2 = find(q[i].y);
              p[root1] = root2;
          }
      }
      
      //检查所有不等条件
      int flag = 0;
      for(int i = 0 ;i < m ; i ++){
          if(q[i].e == 0){
              int root1 = find(q[i].x);
              int root2 = find(q[i].y);
              if(root1 == root2){
                  flag = 1;
                  break;
              }
          }
      }
      if(flag == 0)printf("YES\n");
      else printf("NO\n");
    }
    return 0;
}
```







### 银河战舰

```tex
有一个划分为 N列的星际战场，各列依次编号为 1,2,…,N。

有 N艘战舰，也依次编号为 1,2,…,N，其中第 i号战舰处于第 i列。

有 T条指令，每条指令格式为以下两种之一：
M i j，表示让第 i号战舰所在列的全部战舰保持原有顺序，接在第 j号战舰所在列的尾部。
C i j，表示询问第 i号战舰与第 j号战舰当前是否处于同一列中，如果在同一列中，它们之间间隔了多少艘战舰。

现在需要你编写一个程序，处理一系列的指令。
输入格式
第一行包含整数 T，表示共有 T 条指令。

接下来 T行，每行一个指令，指令有两种形式：M i j 或 C i j。

其中 M 和 C 为大写字母表示指令类型，i 和 j 为整数，表示指令涉及的战舰编号。

输出格式
你的程序应当依次对输入的每一条指令进行分析和处理：

如果是 M i j 形式，则表示舰队排列发生了变化，你的程序要注意到这一点，但是不要输出任何信息；

如果是 C i j 形式，你的程序要输出一行，仅包含一个整数，表示在同一列上，第 i
 号战舰与第 j
 号战舰之间布置的战舰数目，如果第 i
 号战舰与第 j
 号战舰当前不在同一列上，则输出 −1
。
```

> 分析
>
> 可以用并查集来判断两艘战舰是否在一个队列里
> 难点是怎么维护两个战舰相隔距离
> 我们可以用数组d 记录  点i到根的距离，然后d[i] - d[j] 的绝对值加一就是结果，如果根结点一样，取0
>
> 注意点，我们还要用一个s数组表示以当前根结点所在队列有多少战舰

   这是合并的时候，我们要把下面一段每个点到根距离的值加上上一段的长度，我们可以让下面一段的根s [pa]+  s[pb]

因为我们在求根的时候会路径压缩，会把加的值加回去，做到间接更新

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230119055516.png)



​     每次求根，我们都要更新一下数组d的值

   d[x] 表示其到根的距离    其实是旧根的距离   还没压缩的时候就是父节点的距离也就是一

​    压缩后其实到根节点的值变成一了，只是我们把它看成没压缩的样子，它的值其实也是保持着原本距离

![微信截图_20230119055526](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230119055526.png)





```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include <cmath>

const int N = 30010;

int count[N];
int p[N];
int s[N];
int d[N];


int find(int x)  // 并查集
{
    if (p[x] != x) {
        int root = find(p[x]);
        d[x] += d[p[x]];
        p[x] = root;
    }
    return p[x];
}

int main(){
    int t;
    cin>>t;
    for(int i = 1 ; i <= N ; i ++){
        p[i] = i;
        s[i] = 1;
        d[i] = 0;
    }
    while(t --){
        char a[2];
        int x,y;
        scanf("%s%d%d",a,&x,&y);
        int r1 = find(x);
        int r2 = find(y);
        if(a[0] == 'M'){
            if(r1 == r2)continue;
            d[r1] = s[r2];
            s[r2] += s[r1];
            p[r1] = r2;
        }else {
           if(r1 != r2) cout<<-1<<endl;
            else printf("%d\n",max(0,abs(d[x]-d[y])-1));
        }
    }
    return 0;
}
```







### 奇欧游戏 (难)

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230120043630.png" style="zoom: 80%;" />



分析

>用前缀和原理来解这题
>
>l 到 r的1个数等于sum(r)  - sum(r - 1)
>所以我们可以用两种状态表示 
>
>比如说l 到 r 有偶数个1 我们就可以用f(l) 和  f(r) 表示两个位置的状态，也就是和根节点的关系，如果是否有相同的奇偶性，如果相同，那么没有矛盾
>如果不相同，说明有矛盾
>我们还要先判断两个位置是否在一个集合，如果是，才能用上面的方法判断，如果不是，合并
>然后还要计算  f(p[l]) 的奇偶性，具体看下面  

![微信截图_20230120044330](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230120044330.png)



> 合并可以参考以下图

![微信截图_20230120045115](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230120045115.png)



代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>

using namespace std;
const int N = 20010;

int p[N];
int idex;
int d[N];
int n,m;
unordered_map<int,int>mp;

//离散化
int get(int x){
    if(mp.count(x) == 0)mp[x] = idex++;
    return mp[x];
}

int find(int x)  // 并查集
{
    if (p[x] != x){
        int root = find(p[x]);
        d[x] ^= d[p[x]];
        p[x] = root;
    }
    return p[x];
}

int main(){
    cin>>n>>m;
    int ans;
    int sum = m;
    for(int i = 0 ; i < N ; i ++)p[i] = i;
    for(int i = 1 ; i <= m ; i ++){
        int a,b;
        string s;
        cin>>a>>b>>s;
        if(s == "even")ans = 0;
        else ans = 1;
        a = get(a - 1);
        b = get(b);
        int pa = find(a);
        int pb = find(b);
        if(pa != pb){
            p[pa] = pb;
            d[pa] = d[a]^d[b]^ans;
        }else {
            if((d[a] ^ d[b]) != ans){
                sum = i - 1;
                break;
            }
        }
    }
    cout<<sum<<endl;
}
```







方法2

>我们可以把x看成x是偶数这个条件，然后把x + n看成x是奇数这个条件
>给出两个数，然后给出奇数和偶数
>如果是奇数，说明两个数奇偶性不同，否则相同
>
>+ 奇数：我们可以判断x是偶数这个条件和y是偶数这个条件是否在一个集合，如果是，说明这两个同时成立
>  也就是说矛盾
>+ 偶数：判断x是偶数和y是奇数是否在一个集合，如果是，说明 x,y奇偶性不同，矛盾



```c++
#include <iostream>
#include <cstring>
#include <algorithm>
#include <unordered_map>
#include<cstdio>
using namespace std;
const int N = 2e4 + 10;

int n, m;
int p[N], d[N];
int ide;
unordered_map<int,int>mp;

//离散化
int get(int x){
    if(mp.count(x) == 0)mp[x] = ++ide;
    return mp[x];
}

int find(int x)  // 并查集
{
    if (p[x] != x){
        p[x] = find(p[x]);
    }
    return p[x];
}

int main(){
    cin>>n>>m;
    int sum = m;
    n = N/2;
    for(int i = 0 ; i < N ; i ++)p[i] = i;
    for(int i = 1 ; i <= m ; i ++){
       string s;
       int a,b;
       cin>>a>>b>>s;
      
       a = get(a - 1);
       b = get(b);
       //偶数
       if(s == "even"){
           if(find(a + n) == find(b)){
               sum = i - 1;
               break;
           }
           p[find(a)] = find(b);
           p[find(a + n)] = find(b + n);
       }else {
           if(find(a) == find(b)){
               sum = i - 1;
               break;
           }
           p[find(a + n)] = find(b);
           p[find(a)] = find(b + n);
       }
    }
    cout<<sum<<endl;
}
```





## 十二、拓扑排序

### 简介

> 首先给点一个图，找出图中每个点遍历顺序，比如课程表顺序，可以用到拓扑排序
>
> 先计算出每个点的入度，然后用一个队列把入党为零的点收入队列。
>
> 开始遍历，每次弹出，把所有和这个弹出点相连的点度数减去一，如果度数为零，就入队列。
>
> 队列里面的顺序就拓扑排序的顺序
>
>




<br/><br/>




## 十三、链表

### 1、数组模拟链表

节省空间

单链表操作

一般用两个数组，一个存值，一个存下一个结点的指针

```java
import java.util.*;
public class Main{
    static int []val=new int[100010];
    static int []next=new int[100010];
    static int index=0;
    static int head=-1;//头结点
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        //指针和链表的值
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String c=in.next();
            if(c.equals("H")){
                int k=in.nextInt();
                inserthead(k);
            }else if(c.equals("D")){
                int k=in.nextInt();
                if(k==0)head=next[head];
                else delect(k-1);
            }else {
                int k=in.nextInt();
                int x=in.nextInt();
                insertk(k-1,x);
            }
        }
        int sum=0;
        for(int i=head;i!=-1;i=next[i]){
            System.out.print(val[i]+" ");
            sum++;
        }

    }
    //从头节点插入
    public static void inserthead(int a){
        val[index]=a;
        next[index]=head;
        head=index;
        index++;
    }
    //第k个插入的结点后加入一个数
    public static void insertk(int k,int x){
        val[index]=x;
        next[index]=next[k];
        next[k]=index;
        index++;
    }
    //删除第K个结点后一个数
    public static void delect(int k){
        next[k]=next[next[k]];
    }
}
```


<br/><br/>


### 2、双向链表


<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730011147.png" style="zoom:67%;" />



这里双向链表有点特殊，我们先指定0号位是头节点，1号位是尾巴结点，0的next指向1，1的pre指向0

然后插入统一用一个方法就是add

最左端插入就是0号位右边插入

最右边插入就是尾结点左边结点的右边插入

第k个结点后插入也一样

```java


import java.util.*;
public class Main{
    static int []next=new int[100010];
    static int []pre=new int[100010];
    static int []val=new int[100010];
    //确定终点和起点

static int index=2;

 public static void main(String[]args){
     next[0]=1;
     pre[1]=0;
    Scanner in=new Scanner(System.in);
     int n=in.nextInt();
     for(int i=0;i<n;i++){
         String s=in.next();
         if(s.equals("L"))add(0,in.nextInt());
         else if(s.equals("R"))add(pre[1],in.nextInt());
         else if(s.equals("D"))delect(in.nextInt()+1);
         else if(s.equals("IL"))add(pre[in.nextInt()+1],in.nextInt());
         else {
             add(in.nextInt()+1,in.nextInt());
         }
     }
     for(int i=next[0];i!=1;i=next[i]){
         System.out.print(val[i]+" ");
     }
     
 }
 public static void add(int k,int x){
     val[index]=x;
     next[index]=next[k];
     pre[next[k]]=index;
     pre[index]=k;
     next[k]=index;
     index++;
 } 
 public static void delect(int k){
     next[pre[k]]=next[k];
     pre[next[k]]=pre[k];
 }
```

}


<br/><br/>

## **十四、队列和堆栈应用**

### 1、单调栈

一般只有一个用法

就是求数组中每个数左边第一个比他小的数，如果没有输出-1

思路就是堆栈里面的元素大于0，并且堆栈顶部大于当前数，就抛出堆栈，到最后如果堆栈为空，输出-1，否则输出堆栈顶部元素

最后把这个数加入堆栈

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int []a=new int[n];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        Stack<Integer>stack=new Stack<>();
        for(int i=0;i<n;i++){
            while(stack.size()>0&&stack.peek()>=a[i])stack.pop();
            if(stack.size()>0)System.out.print(stack.peek()+" ");
            else System.out.print(-1+" ");
            stack.push(a[i]);
        }
    }
}
```

<br/><br/>

### 2、单调队列

一般是求滑动窗口的最大值

看错题集


<br/><br/>

### 3、数组模拟堆栈

简单

<br/><br/>

### **4、数组模拟队列(可循环)**

```java
public class stack2 {
    //队列的最大值
    static int max;
    static int popindex;
    static  int pushindex;
    static  int size;
    static int[]queue;

    public static  void pop(){
        if(size==0) System.out.println("队列为空");
        else {
            int k=queue[popindex];
            size--;
            popindex=index(popindex);
            System.out.println(k);
        }
    }

    public static void push(int value){
       if(size>=max) System.out.println("已经满了");
       else {
           queue[pushindex]=value;
           size++;
           pushindex=index(pushindex);
       }
    }

    //返回两个指针下一个位置
    public  static int index(int index){
        if(index+1<max)return index+1;
        return 0;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        queue=new int[5];
        max=5;
        size=0;
        popindex=0;
        pushindex=0;
        while(true){
            System.out.println("输入你的选择:1-push,2-pop,3-break");
            int choice=in.nextInt();
            switch (choice){
                case 1:
                    System.out.println("输入要push的数字");
                    push(in.nextInt());
                    break;
                case 2:pop();
                    break;
                case 3:return;
            }
        }
    }
}
```

<br/><br/>

### **5、最小栈**

看错题集

有两种思路

先准备两个堆栈

第一种：每次压入堆栈一，看看它和堆栈2顶部哪一个大，把大的压入堆栈2，每次Pop的时候两个堆栈都要弹出来

第二种：每次将一个数压入堆栈一，如果他小于等于堆栈2的顶部元素，入堆栈，pop的时候如果堆栈一和堆栈二的元素一样，两个一起Pop,否则值pop堆栈1

<br/><br/>

### 6、队列实现堆栈

看数据结构集

<br/><br/>

### 7、堆栈实现队列

数据结构集

<br/><br/>

## **十五 KMP(没搞懂)**


<br/><br/>


## 十六、字典树

### 1、简介

字典树可以直接查找一个字符串出现了多少次，效率很高，用树来实现

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730020051.png" width="70%" height="70%" />

<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731014313.png" width="70%" height="70%" />



```java
import java.util.*;
public class Main{
    //第几个位置有几个儿子节点
    static int[][]root=new int[100010][26];
    //统计字符串的数量
    static int[]sum=new int[100010];
    static int  index=0;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String s=in.next();
            if(s.equals("I")){
                insert(in.next());
            }else{
                String str=in.next();
                quary(str);
            }
        }
    }

    public static void quary(String s){
        int q=0;
        for(int i=0;i<s.length();i++){
            int k=s.charAt(i)-'a';
            if(root[q][k]==0){
                System.out.println(0);
                return;
            }
            q=root[q][k];
        }
        System.out.println(sum[q]);
    }

    //插入
    public static void insert(String s){
        int q=0;
        for(int i=0;i<s.length();i++){
            int k=s.charAt(i)-'a';
            if(root[q][k]==0)root[q][k]=++index;
            q=root[q][k];
        }
        sum[q]++;
    }
}
```

<br/><br/>

## 十七、注意事项

### 1、输入结束

有些题目输入没有结束标志，要用以下格式来结束输入

```java
import java.util.*;
public class Main{
    public static  void main(String[]args){
        Scanner in=new Scanner(System.in);
        //判断闰年的标志
        List<Integer>list=new ArrayList<>();
        while(in.hasNext()){
            int y=in.nextInt();
            int m=in.nextInt();
            int d=in.nextInt();
            int falg=0;
            if(y%4==0&&y%100!=0||y%400==0)falg=1;
            HashMap<Integer,Integer>map=new HashMap<>();
            map.put(1,31);
            map.put(3,31);
            map.put(4,30);
            map.put(5,31);
            map.put(6,30);
            map.put(7,31);
            map.put(8,31);
            map.put(9,30);
            map.put(10,31);
            map.put(11,30);
            map.put(12,31);
            if(falg==1)map.put(2,29);
            else map.put(2,28);
            int k =m-1;
            int sum=0;
            for(int i=1;i<=k;i++){
                sum+=map.get(i);
            }
            sum+=d;
            list.add(sum);


        }
        for(int k:list){
            System.out.println(k);
        }
    }
}
```

<br/><br/>



## 十八、堆

看数据结构

### 1、系统堆

默认小根堆，然后定制排序变成大根堆

```java
class heap3{
    static class mycon implements Comparator<Integer>{

        @Override
        public int compare(Integer o1, Integer o2) {
            return o2-o1;
        }
    }
    public static void main(String[] args) {
        PriorityQueue<Integer>queue=new PriorityQueue<>(new mycon());
        queue.add(1);
        queue.add(-3);
        queue.add(20);
        queue.add(24);
        System.out.println(queue.poll());
    }
}
```
<br/><br/>

### 2、比较器(定制排序）

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815202251.png" width="70%" height="70%" />



<br/><br/>

### 3、前k个排序

思路：

> 把前k个数放入小根堆，然后弹出放入下标为Index的位置，index++,然后让k+1个数加入堆，然后重复操作

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815194017.png" width="70%" height="70%" />

<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815195046.png" width="70%" height="70%" />



<br/><br/>




## 十九、大数问题

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807043226.png" width="70%" height="70%" />



```java
import java.math.BigInteger;
        import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        String s1=in.next();
        String s2=in.next();
        BigInteger a=new BigInteger(s1);
        BigInteger b=new BigInteger(s2);
        var c=a.add(b);
        System.out.println(c);
    }
}
```


<br/><br/>


## 二十、哈希

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220814153841.png" width="70%" height="70%" />

<br/><br/>

### 1、模拟哈希

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815142757.png" width="70%" height="70%" />



  



开放寻址法

> 数组开两倍长，然后每个位置填充要插入数范围外的数字，这里取100000001.然后传过来一个数，我们要用取模法判断要放到数组的下标，因为数组保证下标为正，所以要两次取模，如果数组中这个数不等于flag并且不等于传进来的数，k++,记住如果k等于数组长度，进行一个循环，k变成0

```java
import java.util.*;
public class Main{
    static int[]d;
    static int flag;
    static int n=200003;

    static int find(int x){
        int k=(x%n+n)%n;
        while(d[k]!=flag&&d[k]!=x){
            k++;
            if(k==n)k=0;
        }
        return k;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        d=new int[200000];
        flag=100000001;
        for(int i=0;i<200003;i++){
            d[i]=flag;
        }
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String s=in.next();
            int x=in.nextInt();
            int k=find(x);
            if(s.equals("I")){
                d[k]=x;
            }else {
                if(d[k]!=flag)System.out.println("Yes");
                else System.out.println("No");
            }
        }
    }
}
```


<br/><br/>


2、拉链法

就是数组加链表

```java
import java.util.*;
public class  Main{
    static int []d;
    static int []e;
    static int[]ne;
    static int flag=100003;
    static int index=0;

    static void insert(int x){
        int k=(x%flag+flag)%flag;
        e[index]=x;
        ne[index]=d[k];
        d[k]=index;
        index++;
    }

    static boolean quary(int x){
        int k=(x%flag+flag)%flag;
        for(int i=d[k];i!=-1;i=ne[i]){
            if(e[i]==x)return true;
        }
        return false;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        d=new int[100003];
        e=new int[100003];
        ne=new int[100003];
        for(int i=0;i<100003;i++){
            d[i]=-1;
        }
        for(int i=0;i<n;i++){
            String c=in.next();
            int x=in.nextInt();
            if(c.equals("I"))insert(x);
            else {
                var a=quary(x);
                if(a==true)System.out.println("Yes");
                else System.out.println("No");
            }
        }
    }
}
```



<br/><br/>


### 2、字符串哈希

含义：我们把一串字符串预处理，这样子处理子串的时候很容易计算出他们的哈希值了，方便字符串的比较

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220814172654.png" width="70%" height="70%" />

<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815143932.png" width="70%" height="70%" />



```java
import java.util.*;
public class Main{
    static long []h;
    //计算p的多少次方等于多少
    static long []p;
    static long Q=(long)Math.pow(2,64);
    static long P=131;

    static long count(int l,int r){
        return h[r]-h[l-1]*p[r-l+1];
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        p=new long[n+1];
        h=new long[n+1];
        String s=in.next();
        p[0]=1;
        for(int i=1;i<=n;i++){
            p[i]=p[i-1]*P;
            h[i]=(h[i-1]*P+s.charAt(i-1))%Q;
        }
        for(int i=0;i<m;i++){
            int l1=in.nextInt();
            int r1=in.nextInt();
            int l2=in.nextInt();
            int r2=in.nextInt();
            if(count(l1,r1)==count(l2,r2))System.out.println("Yes");
            else System.out.println("No");
        }
    }
}
```

<br/><br/>


## 二十一、搜索和图论(邻接矩阵来表示）

### 1、dfs

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818152430.png" width="70%" height="70%" />





```java
import java.util.*;
public class Main{
    static int []num;
    static int []vist;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        num=new int[n+1];
        vist=new int[n+1];
        dfs(1);
    }
    public static void dfs(int n){
        if(n==num.length){
            for(int i=1;i<num.length;i++){
                System.out.print(num[i]+" ");
            }
            System.out.println();
            return;
        }

        for(int i=1;i<num.length;i++){
            if(vist[i]==0){
                vist[i]=1;
                num[n]=i;
                dfs(n+1);
                vist[i]=0;
            }
        }
    }

}
```

<br/><br/>


### 2、n皇后

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818154922.png" width="70%" height="70%" />



```java
import java.util.*;
public class Main{
    static char[][]num;
    //分别存放列，两个对角线
    static HashSet<Integer>set1=new HashSet<>();
    static HashSet<Integer>set2=new HashSet<>();
    static HashSet<Integer>set3=new HashSet<>();
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        num=new char[n][n];
        //初始化
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                num[i][j]='.';
            }
        }
        dfs(0);
    }

    public static void dfs(int n){
        if(n==num.length){
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    System.out.print(num[i][j]);
                }
                System.out.println();
            }
            System.out.println();
            return;
        }
        for(int i=0;i<num.length;i++){
            if(set1.contains(i)==false&&set2.contains(n+i)==false&&set3.contains(n-i)==false){
                set1.add(i);
                set2.add(n+i);
                set3.add(n-i);
                num[n][i]='Q';
                dfs(n+1);
                set1.remove(i);
                set2.remove(n+i);
                set3.remove(n-i);
                num[n][i]='.';
            }
        }
    }
}
```

<br/><br/>

### 3、bfs(最短路)

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818164017.png" width="70%" height="70%" />



```Java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int [][]num=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                num[i][j]=in.nextInt();
            }
        }
        Queue<int[]>queue=new LinkedList<>();
        queue.add(new int[]{1,1});
        int [][]vist=new int[n+1][m+1];
        int sum=0;
        int []d1={1,0,0,-1};
        int []d2={0,1,-1,0};
        int count=0;
        vist[1][1]=1;
        while(queue.size()>0){
            sum++;
            int size=queue.size();
            while(size>0){
                size--;
                int[]a=queue.poll();
                int x=a[0];
                int y=a[1];
                //System.out.println(x+" "+y+" "+sum);
                int k1=0;
                int k2=0;
                for(int i=0;i<4;i++){
                    k1=x+d1[i];
                    k2=y+d2[i];
                    if(k1>=1&&k2>=1&&k1<=n&&k2<=m&&num[k1][k2]==0&&vist[k1][k2]==0){
                        if(k1==n&&k2==m){
                            count=sum;
                        }
                        vist[k1][k2]=1;
                        queue.add(new int[]{k1,k2});
                    }
                }
            }
        }
        System.out.println(count);
    }
}
```

<br/><br/>

### **4、图和的表示用邻接表，链表用数组来模拟**

> 图除了二维数组 
>
> 还可以用邻接表  体现在每一个节点下面又一个链表  表示这个节点到链表中的每个数都有边
>
> g初始化为 -1

```cpp
int e[N],ne[N],g[N];
    int idx;
    void creat(int a,int b){
    e[idx] = b;
    ne[idx] = g[a];
    g[a] = idx++;
    }
```


<br/><br/>


查找一个节点和和哪些结点相连

```cpp
for(int i = g[u] ; i != -1 ;i=ne[i]){
        int j = e[i];
}
```





<br/><br/>

树的中心

> 这里用递归，dfs遍历，从1也就是顶部开始，算出以当前结点的子树的结点数，加上1就是以当前结点为根的树的结点总数，剩下联通区域结点数就是n-1,同时可以算出，同时可以递归的算出子结点的最大结点数，然后比较。

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819022927.png" width="70%" height="70%" />

```java
import java.util.*;
public class Main{
    static int []tree;
    static int []value;
    static int []next;
    static int min;
    static int index;
    static int []vist;
    static int n;
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }

    public static int dfs(int x){
        vist[x]=1;
        int sum=1;
        int res=0;
        for(int i=tree[x];i!=-1;i=next[i]){
            int j=value[i];
            if(vist[j]==0){
                vist[j]=1;
                int s=dfs(j);
                res=Math.max(res,s);
                sum=sum+s;
            }
        }
        res=Math.max(res,n-sum);
        min=Math.min(min,res);
        return sum;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int count=in.nextInt();
        n=count;
        tree=new int[100010];
        vist=new int[100010];
        min=n;
        index=1;
        value=new int[200010];
        next=new int[200010];
        for(int i=1;i<100010;i++){
            tree[i]=-1;
        }
        for(int i=0;i<n-1;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
            insert(b,a);
        }
        dfs(1);
        System.out.println(min);
    }
}
```


<br/><br/>


### 5、拓扑排序

分别用邻接表和哈希表来模拟图，数组空间太大，不推荐

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820165148.png" width="70%" height="70%" />


```java
import java.util.*;
public class Main{
    static int[]tree=new int[200000];
    static int []v=new int[200000];
    static int []ne=new int[200000];
    static List<Integer>list=new ArrayList<>();
    static Queue<Integer>queue=new LinkedList<>();
    static int[]d;
    static int index;


    //图的建立
    public  static void insert(int a,int b){
        d[b]++;
        v[index]=b;
        ne[index]=tree[a];
        tree[a]=index++;
    }

    public static boolean topo(int n){
        for(int i=1;i<=n;i++){
            if(d[i]==0)queue.add(i);
        }
        while(queue.size()>0){
            int k=queue.poll();
            list.add(k);
            for(int i=tree[k];i!=-1;i=ne[i]){
                //System.out.println(i);
                int j=v[i];
                d[j]--;
                if(d[j]==0)queue.add(j);
            }
        }
        if(list.size()==n)return true;
        return false;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        index=0;
        d=new int[n+1];
        for(int i=1;i<200000;i++)tree[i]=-1;
        for(int i=0;i<m;i++){
            insert(in.nextInt(),in.nextInt());
        }
        boolean  a=topo(n);
        if(a==true){
            for(int k:list){
                System.out.print(k+" ");
            }
        }
        else System.out.println(-1);
    }

}
```


<br/><br/>


```java
 class Main{

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
       HashMap<Integer,List<Integer>>map=new HashMap<>();
       List<Integer>list=new ArrayList<>();
       int n=in.nextInt();
       int m=in.nextInt();
       int[]d=new int[n+1];
       for(int i=0;i<m;i++){
           int k1=in.nextInt();
           int k2=in.nextInt();
           d[k2]++;
           if(map.get(k1)==null){
               List<Integer>help=new ArrayList<>();
               help.add(k2);
               map.put(k1,help);
           }else {
               map.get(k1).add(k2);
           }
       }
       Queue<Integer>queue=new LinkedList<>();
       for(int i=1;i<=n;i++){
           if(d[i]==0)queue.add(i);
       }
       while(queue.size()>0){
           int k=queue.poll();
           list.add(k);
           if(map.get(k)==null)continue;;
           List<Integer>list2=map.get(k);
           for(int w:list2){
               d[w]--;
               if(d[w]==0)queue.add(w);
           }
       }
       if(list.size()==n){
           for (int w:list){
               System.out.print(w+" ");
           }
       }else System.out.println(-1);
    }
}
```

<br/><br/>

### **最短路(非常重要)**

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820183313.png" width="70%" height="70%" />



### 6、单源无权

求一个点到终点的最短路，用bfs

输入，n,和m,表示点和边，存在自环，求1到n的最短路

bfs就行了

```java
import java.util.*;
public class Main{
    static int[]vist;
    static int[]dist;
    static int[]value;
    static int[]tree;
    static int[]next=new int[200000];
    static int index;
    static Queue<Integer>queue=new LinkedList<>();

    //图的建立
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }

    public static void bfs(){
        while(queue.size()>0){
            int k=queue.poll();
            for(int i=tree[k];i!=-1;i=next[i]){
                int j=value[i];
                if(vist[j]==0){
                    vist[j]=1;
                    dist[j]=dist[k]+1;
                    queue.add(j);
                }
            }
        }
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        index=0;
        value=new int[200000];
        vist=new int[n+1];
        dist=new int[n+1];
        tree=new int[n+1];
        for(int i=0;i<=n;i++)tree[i]=-1;
        dist[1]=0;
        queue.add(1);
        vist[1]=1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
        }
        bfs();
        if(vist[n]==0)System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```



<br/><br/>

### 7、Dijkstra(朴素版)

> 适合边多的图，用数组模拟
>
> 思路：每次从没有被访问过的点找出到目标点距离距离最小的点，然后标记为访问，找出他的所有邻接点，然后在更新距离
>
> 注意：所有点距离和图的权都为正无穷，初始距离为0

```java
import java.util.*;
public class Main{
    public  static  int[][]graph;
    public  static  int[]visit;
    public  static  int[]dist;
    static  int n;

    //构建图
    public  static void insert(int a,int b,int c){
        graph[a][b]=Math.min(graph[a][b],c);
    }

    //初始化
    public  static  void start(){
        for(int i=1;i<=n;i++){
            dist[i]=10000000;
            for(int j=1;j<=n;j++){
                graph[i][j]=graph[j][i]=10000000;
            }
        }
    }

    public  static  void  dijkstra(){
        for(int i=0;i<n;i++){
            int t=-1;
            for(int j=1;j<=n;j++){
                if(visit[j]==0&&(t==-1||dist[j]<dist[t])){
                    t=j;
                }
            }
            if(t==-1)break;
            // System.out.println(t+" "+dist[t]);
            visit[t]=1;
            for(int w=1;w<=n;w++){
                if(visit[w]==0){
                    dist[w]=Math.min(dist[w],dist[t]+graph[t][w]);
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1][n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        dijkstra();
        if(dist[n]==10000000) System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```


<br/><br/>


### 8、堆优化

适合稀疏图

用临接表表示图

堆来优化

这里用系统堆

```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];//值
    public  static  int[]next=new int[200000];//下一个指针
    public  static  int[]weight=new int[200000];//权重
    public  static  int index=0;
    static  int n;
    static int max=1000000000;
    //堆
    public static PriorityQueue<int[]>heep=new PriorityQueue<>(new p());

    //定制排序
    static class p implements Comparator<int[]>{

        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[1]-o2[1];
        }
    }

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }

    //初始化
    public  static  void start(){
        for(int i=0;i<graph.length;i++){
            if(i<dist.length)
                dist[i]=max;
            graph[i]=-1;
        }
    }

    public  static  void  dijkstra(){
        while(heep.size()>0){
            int []a=heep.poll();
            int v=a[0];
            int d=a[1];
            if(visit[v]==1)continue;
            visit[v]=1;
            for(int i=graph[v];i!=-1;i=next[i]){
                int j=value[i];
                int q=weight[i];
                if(dist[j]>d+q){
                    dist[j]=d+q;
                    heep.add(new int[]{j,d+q});
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        heep.add(new int[]{1,0});
        dijkstra();
        if(dist[n]==max) System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```

<br/><br/>

### 9、bellman-ford算法

可以处理负权图

这里直接把两个点和一个边以及权重储存在集合中

然后n个点，m条边

循环n次，然后每次把所有边取出来，更新端点的距离，记住要先复制，避免这次操作是基于上一次操作来的

特点:外层循环的意思就是经过第i+1条边，求目标点到各个点的最短路，这个方法可以来判断有没有环

下面是acwing一个题目，求经过k条边能否从1到n号点

```java
import java.util.*;
public class Main{
    static int n;
    static int []dist;
    //保存原数组，每次操作先拷贝一份
    static int[]pre;
    //把两个点和权重存进去
    static List<int[]>list=new ArrayList<>();
    static int max=1000000000;

    static  void start(){
        for(int i=1;i<dist.length;i++){
            dist[i]=max;
        }
        dist[1]=0;
    }

    static boolean bellman(int k){
        //将数组拷贝
        for(int i=0;i<k;i++){
            for(int j=1;j<=n;j++)pre[j]=dist[j];
            for(int j=0;j<list.size();j++){
                int[]num=list.get(j);
                int a=num[0];
                int b=num[1];
                int c=num[2];
                // System.out.println(a+" "+b+" "+c);
                dist[b]=Math.min(dist[b],pre[a]+c);
                //System.out.println(dist[b]);
            }
        }
        if(dist[n]>max/2)return false;
        return true;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m= in.nextInt();
        int k=in.nextInt();
        dist=new int[n+1];
        pre=new int[n+1];
        for(int i=0;i<m;i++){
            int a= in.nextInt();
            int b= in.nextInt();
            int q= in.nextInt();
            list.add(new int[]{a,b,q});
        }
        start();
        boolean a= bellman(k);
        if(a==false) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
}
```


<br/><br/>

### 10、spfa

不能有负环

对bellman-ford优化ellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。

用邻接表建图

然后其他和迪杰斯特拉优化一样

用一个队列，弹出一个点，并且这个点访问设为false,找出这个点的所有临接点，如果最短距离更新成功并且这个点不在队列中，加入队列，设为访问过

```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];//值
    public  static  int[]next=new int[200000];//下一个指针
    public  static  int[]weight=new int[200000];//权重
    public  static  int index=0;
    static  int n;
    static int max=1000000000;

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }

    //初始化
    public  static  void start(){
        for(int i=0;i<graph.length;i++){
            if(i<dist.length)
                dist[i]=max;
            graph[i]=-1;
        }
    }

    public  static  void  spfa(){
        Queue<Integer>queue=new LinkedList<>();
        queue.add(1);
        while(queue.size()>0){
            int k=queue.poll();
            visit[k]=0;
            for(int i=graph[k];i!=-1;i=next[i]){
                int j=value[i];
                if(dist[k]+weight[i]<dist[j]){
                    dist[j]=weight[i]+dist[k];
                    if(visit[j]==0){
                        //System.out.println(j+" "+dist[j]);
                        visit[j]=1;
                        queue.add(j);
                    }
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        spfa();
        if(dist[n]==max) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
}
```

<br/><br/>

### 11、floyd

先初始化距离为max,如果i=j距离为0

g(i)(j)=min(g(i)(j),g(i)(k)+g(k)(i))

```java
import java.util.*;
public class Main{
    static int n,m,q;
    static int[][]graph;
    static int max=1000000000;
    public static void floyd(){
        for(int k=1;k<=n;k++){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    graph[i][j]=Math.min(graph[i][j],graph[i][k]+graph[k][j]);
                }
            }
        }
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        m=in.nextInt();
        q=in.nextInt();
        graph=new int[n+1][n+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i==j)graph[i][j]=0;
                else
                    graph[i][j]=max;
            }
        }
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int q=in.nextInt();
            graph[a][b]=Math.min(graph[a][b],q);
        }
        floyd();

        for(int i=0;i<q;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            if(graph[a][b]>max/2)System.out.println("impossible");
            else System.out.println(graph[a][b]);
        }

    }
}
```


<br/><br/>


### 最小生成树

### 12、prime

思路就是先初始化图的距离为max,  每个点到生成树的距离为max

然后n论循环，每一次找出不在生成树中结点到生成树距离最小的点

然后加入生成树，再找出这个点的临接点并且不在生成树的点

更新其他点到生成树的距离

如果中间发现没有点到生成树，就不能生成最小生成树

```java
import java.util.*;
class  Main{
    static int [][]graph=new int[600][600];
    static  int[]dist=new int[600];
    static  int[]vist=new int[600];
    static  int max=100000000;
    static  int n;
    //初始化
    public  static  void start(){
        for(int i=0;i<=n;i++){
            dist[i]=max;
            for(int j=0;j<=n;j++){
                graph[i][j]=max;
            }
        }
    }

    //prime算法
    public  static  int prime(){
        int sum=0;
        for(int i=0;i<n;i++){
            int t=-1;
            for(int j=1;j<=n;j++){
                if(vist[j]==0&&(t==-1||dist[j]<dist[t]))t=j;
            }
            if(i!=0&&dist[t]==max)return max;
            vist[t]=1;
            for(int j=1;j<=n;j++){
                if(vist[j]==0)dist[j]=Math.min(dist[j],graph[t][j]);
            }
            if(i!=0)sum+=dist[t];
        }
        return sum;

    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int q=in.nextInt();
            graph[a][b]=graph[b][a]=Math.min(graph[a][b],q);
        }
        int f=prime();
        if(f==max)System.out.println("impossible");
        else System.out.println(f);
    }
}
```


<br/><br/>


### 13、kruskal

将所有边放到堆里面

然后从小到大取出

如果这条边的两个点不在一个集合，就加入最小生成树

最小堆加并查集

```java
class  Main11{
    static  int []parent;

    static int find(int x){
        if(x!=parent[x])parent[x]=find(parent[x]);
        return parent[x];
    }
    static PriorityQueue<tree>heep=new PriorityQueue<>();
    public static void main(String[] args) {
       Scanner in=new Scanner(System.in);
       int n=in.nextInt();
       int m=in.nextInt();
       parent=new int[n+1];
       for(int i=0;i<m;i++){
           int a=in.nextInt();
           int b=in.nextInt();
           int q=in.nextInt();
           heep.add(new tree(a,b,q));
       }
       for(int i=1;i<=n;i++){
           parent[i]=i;
       }

       //算法
       int sum=0;
       int cnt=0;
       for(int i=0;i<m;i++){
           tree t=heep.poll();
           int a=t.a;
           int b=t.b;
           int c=t.q;
           int root1=find(a);
           int root2=find(b);
           if(root1!=root2){
             cnt++;
             parent[root1]=root2;
             sum+=c;
           }
       }
        if(cnt<n-1) System.out.println("impossible");
        else
        System.out.println(sum);
    }

}

class tree implements Comparable<tree>{
    int a;
    int b;
    int q;

    public tree(int a, int b, int q) {
        this.a = a;
        this.b = b;
        this.q = q;
    }

    @Override
    public int compareTo(tree o) {
        return this.q-o.q;
    }
}
```


<br/><br/>


### 14、二分图染色

定义：

就是可以将图中的顶点分为两个集合

每个集合中的元素没有交集

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016010537.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016022329.png" width="70%" height="70%" />



<br/><br/>


> 二分图的性质就是不能有含有奇数条边的环
>
> 因为一个点属于1他连接的点肯定属于2  如果是环有奇数边  那么 第一个点为2      和刚开始矛盾了 
>
> 我们可以用染色法来进行判断



<br/><br/>

dfs

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831110953.png" width="70%" height="70%" />


```java
import java.util.*;
class Main{
    static  int []g=new int[100010];
    static  int[]next=new int[200020];
    static  int[]value=new int[200010];
    static  int[]color=new int[100010];
    static  int index=0;
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=g[a];
        g[a]=index++;
    }

    public static boolean dfs(int u,int c){
        color[u]=c;
        for(int i=g[u];i!=-1;i=next[i]){
            int j=value[i];
            if(color[j]==0){
                //将当前结点染成不一样的颜色  当前为1 那么子节点为2  否则为1
                if(dfs(j,3-c)==false)return false;
            }
            else {
              //  如果颜色一样返回false
                if(color[j]==c)return false;
            }
        }
        return true;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        for(int i=1;i<=n;i++)g[i]=-1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
            insert(b,a);
        }
        boolean flag=true;
        for(int i=1;i<=n;i++){
            if(color[i]==0){
                //还没被染色就染为1
                if(dfs(i,1)==false){
                    flag=false;
                    break;
                }
            }
        }
        if(flag==true) System.out.println("Yes");
        else System.out.println("No");
    }
}
```

<br/><br/>



### 15、匈牙利算法


<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831132251.png" width="70%" height="70%" />





```C++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

        const int n=510,m=100010;
        int g[n],value[m],ne[m],idx;
        int match[n];
        bool st[n];

        bool find(int x){
        for(int i=g[x];i!=-1;i=ne[i]){
           int j=value[i];
           if(st[j]==false){
              st[j]=true;
              if(match[j]==0||find(match[j])==true){
              match[j]=x;
              return true;
             }
          }
        }
            return false;
        }

        void add(int a, int b)  // 添加一条边a->b
        {
        value[idx] = b, ne[idx] = g[a], g[a] = idx++ ;
        }


        int main(){
        int n1,n2,m;
        scanf("%d%d%d", &n1, &n2,&m);
        memset(g,-1,sizeof g);

        while(m--){
          int a,b;
          scanf("%d%d", &a, &b);
           add(a,b);
        }
        int sum=0;
        for(int i=1;i<=n1;i++){
            memset(st, 0, sizeof st);
            if(find(i))sum++;
        }
           printf("%d",sum);
            return 0;
        }
```



<br/><br/>


## 二十二、动态规划

### 背包

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831161904.png" width="70%" height="70%" />



<br/><br/>

### 1、01背包

给定价值数组，重量数组，每种物品只能放一个，最大体积为M  求背包最大价值

思路：

> 我们用二维数组来表示当前状态f
>
> f(i)(j)表示当前遍历到第i个物品时候最大价值，j表示当前还能容纳的物品重量
>
> 两个状态：
>
> + 其中f(i-1)(j)表示上一个物品转移到当前，不包含当前物品i
> + 包含当前物品i,这个状态是由f(i-1)(j-v(i))+w(i)转移来的   条件是就j>=v(i)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        int f[1001][1001];
        int w[1001];
        int v[1001];
        int main()
        {
            int n,m;
            cin >> n>>m;
            for(int i=1;i<=n;i++){
               cin>>v[i]>>w[i];
            }
            for(int i=1;i<=n;i++){
               for(int j=0;j<=m;j++){
                  f[i][j]=f[i-1][j];
                  if(j>=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
             }
          }
        cout<<f[n][m];
        return 0;
        }
```

<br/><br/>

### 2、完全背包

物品无限个

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831212952.png" width="70%" height="70%" />

<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831215819.png" width="70%" height="70%" />



优化为二重循环

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        int f[1001][1001];
        int w[1001];
        int v[1001];
        int main()
        {
           int n,m;
           cin >> n>>m;
          for(int i=1;i<=n;i++){
            cin>>v[i]>>w[i];
          }
          for(int i=1;i<=n;i++){
            for(int j=0;j<=m;j++){
              f[i][j]=f[i-1][j];
             if(j>=v[i])f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
           }
         }
           cout<<f[n][m];
           return 0;
        }
```


<br/><br/>


### 3、多重背包

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220901044035.png" width="70%" height="70%" />



```c++
#include <iostream>
#include <cstring>
#include<algorithm>
using namespace std;

        int v[110],w[110],s[110];
        int dp[110][110];
        int main()
        {
           int n,m;
            cin>>n>>m;
        for(int i=1;i<=n;i++){
            cin>>v[i]>>w[i]>>s[i];
        }
           for(int i=1;i<=n;i++){
              for(int j=0;j<=m;j++){
               for(int k=0;k<=s[i]&&j-v[i]*k>=0;k++){
                 dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
               }
             }
          }
            cout<<dp[n][m];
        }
```

<br/><br/>
第一种暴力做法

这里可以看成特殊的完全背包，限制K的大小







优化:

我们首先确认三点：

（1）我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。

（2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。

（3）这里多重背包问的就是每件物品取多少件可以获得最大价值。

分析：

如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好。那么根据数据范围，这样的时间复杂度是O(n^3),也就是1e+9，这样是毫无疑问是会TLE的。

假如10个取7个好，那么在实际的遍历过程中在第7个以后经过状态转移方程其实已经是选择“不取”好了。现在，用二进制思想将其分堆，分成k+1个分别有2^k个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0=1,2^1=2,2^2=4,10 - 7 = 3 这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个。

Tip:参考博客

如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次

二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,.....512分到10个箱子里，那么由于任何一个数字x ∈[1,1024]
都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。

这样利用二进制优化，时间复杂度就从O(n^3)降到O(n^2logS),从4*10^9降到了2*10^7。



我们吧多个物品分成多个二次方组，然后把他们看出01背包

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        const int N=15000,M=2010;
        int n,m;
        int v[N],w[N];
        int f[N];
        int main(){
            cin>>n>>m;
           int a,b,s;
           int cnt=1;
           for(int i=0;i<n;i++){
             cin>>a>>b>>s;
            int k=1;
            while(k<=s){
               cnt++;
              v[cnt]=a*k;
              w[cnt]=b*k;
              s=s-k;
              k=k*2;
           }
        if(s>0){
           cnt++;
           v[cnt]=s*a;
            w[cnt]=b*s;
          }
        }
        n=cnt;

        //01背包一维优化
        for(int i=1;i<=n;i++)
            for(int j=m;j>=v[i];j--)
                f[j]=max(f[j],f[j-v[i]]+w[i]);

        cout<<f[m];
        return 0;
        }
```



<br/><br/>

### 4、分组背包

每个组有多个物品，并且每个组只能拿一个物品，有多个组

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220904045919.png" width="70%" height="70%" />





>有 N� 组物品和一个容量是 V� 的背包。
>
>每组物品有若干个，同一组内的物品最多只能选一个。
>每件物品的体积是 vij���，价值是 wij���，其中 i� 是组号，j� 是组内编号。
>
>求解将哪些物品装入背包，可使物品总体积不超过背包容量，且总价值最大。
>
>输出最大价值。
>
>#### 输入格式
>
>第一行有两个整数 N，V，用空格隔开，分别表示物品组数和背包容量。
>
>接下来有 N 组数据：
>
>- 每组数据第一行有一个整数 Si，表示第 i 个物品组的物品数量；
>- 每组数据接下来有 Si 行，每行有两个整数 vij,wij用空格隔开，分别表示第 i个物品组的第 j 个物品的体积和价值；
>
>#### 输出格式
>
>输出一个整数，表示最大价值。

```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
        const int N = 110;
        int f[N][N];
        int w[N][N],v[N][N],s[100];
        int main(){
           int n,m;
            cin>>n>>m;
        for(int i=1;i<=n;i++){
             cin>>s[i];
           for(int j=0;j<s[i];j++){
              cin>>v[i][j]>>w[i][j];
           }
         }

          for(int i=1;i<=n;i++){
              for(int j=0;j<=m;j++){
                 for(int k=0;k<s[i];k++){
                    f[i][j]=max(f[i-1][j],f[i][j]);
                    if(v[i][k]<=j)
                     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);
                  }
              }
         }

           cout<<f[n][m];
        }
```

<br/><br/>

### 5、线性dp

最长上升子序列问题



最长公共子序列

思路：

> f(i)(j)表示前第一个字符串前i个字母出现且在第二个字符串前j个字母出现的最长公共子序列
>
> 可以分成四个状态
>
> 第i个字符和第j个字符要不要选
>
> 其实第二种情况和第三种包括了第一种，所以我们枚举的时候只要枚举三种情况就行了

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908201544.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909122817.png" width="70%" height="70%" />



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 1010;
        char s1[1010],s2[1010];
        int f[1010][1010];
        int main()
        {
           int n,m;
           cin>>n>>m;
           scanf("%s%s",s1+1,s2+1);
           for(int i=1;i<=n;i++){
              for(int j=1;j<=m;j++){
                  f[i][j]=max(f[i-1][j],f[i][j-1]);
                if(s1[i]==s2[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
              }
           }
         cout<<f[n][m];
          return 0;
     }
```

<br/><br/>

### 6、区间dp

题目：

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909123256.png" width="70%" height="70%" />


<br/><br/>
思路：

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909103456.png" width="70%" height="70%" />







> 我们最终肯定是变成两堆石子
>
> 起点和终点分别是i j
>
> 分割点是K
>
> 所以有上面的式子
>
> 同时最后两堆合并时候代价就是两堆的总和，可以用前缀和计算
>
> 然后左右两边按照相同的方式去计算



代码如下：

```CPP
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 310;
        int f[N][N];
        int s[N];
        int main()
        {
           int n;
            cin>>n;
            for(int i=1;i<=n;i++)cin>>s[i];
        //前缀和
             for(int i=1;i<=n;i++){
               s[i]=s[i-1]+s[i];
            }
        //len长度  i+len-1右端点距离
            for(int len=2;len<=n;len++){
               for(int i=1;i+len-1<=n;i++){
                  int l=i;
                  int r=i+len-1;
                  f[l][r]=100000000;
                  for(int k=l;k<r;k++){
                      f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
                 }
              }
            }
            cout<<f[1][n];
        }
```

<br/><br/>

### 7、计数dp

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911030701.png" width="70%" height="70%" />

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
// f[i][j] = f[i - 1][j] + f[i][j - i]
//表示选取前i哥整数恰好拼成j的方案
        int f[1010][1010];
        int e=1e9+7;
        int main()
        {
            int n;
           cin>>n;
            for(int i=0;i<=n;i++)f[i][0]=1;
            for(int i=1;i<=n;i++){
               for(int j=0;j<=n;j++){
               f[i][j]=f[i-1][j]%e;
               if(j>=i)f[i][j]=(f[i-1][j]+f[i][j-i])%e;
               }
            }
          cout<<f[n][n];
          return 0;
        }
```

<br/><br/>

思路：

> 把1,2,3, … n分别看做n个物体的体积，这n个物体均无使用次数限制，问恰好能装满总体积为n的背包的总方案数（完全背包问题变形）
>
> 初值问题：
> 求最大值时，当都不选时，价值显然是 0
> 而求方案数时，当都不选时，方案数是 1（即前 i 个物品都不选的情况也是一种方案），所以需要初始化为 1
> 即：for (int i = 0; i <= n; i ++) f[i][0] = 1;
> 等价变形后： f[0] = 1
>
> 状态计算：
>
> f[i][j]f[i][j] 表示前i个整数（1,2…,i）恰好拼成j的方案数
> 求方案数：把集合选0个i，1个i，2个i，…全部加起来
> f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
> f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
> 因此 f[i][j]=f[i−1][j]+f[i][j−i];f[i][j]=f[i−1][j]+f[i][j−i]; (这一步类似完全背包的推导）


<br/><br/>


### **8、状态压缩(难)**

思路：

我们先把横着的摆放好，那么竖着的就自然好了，所以我们计算多少符合条件的横着的摆放法

就是用一个二维数组记录当前的状态

f(i)(j)表示第i列的状态为j   j表示这一整列的二进制表示

所以要从前一列转移满足：

1、当前格子不能和上一列的格子冲突       当前格子是由上一层格子伸过来的       所以上一层格子必须为0

2、前一列的状态不能有连续奇数个0   这样子才能放的下

第一个条件可以用j&k==0

第二个条件用（j|k)  不存在连续奇数0

我们输入n m 表示行和列

所以我们没次要预处理  从0到1<<n这么多数，因为有n行 所以最大为2的n次方  也就是1左移n位减一

然后对每个数判断是不是有连续奇数个0

这里可以用移位   

最后在动态规划


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220915024319.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002031013.png" width="70%" height="70%" />




```cpp
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 12,M=1<<N;
int n,m;
long long  f[N][M];
//判断这个数是否有连续的奇数0
bool st[M];
int main(){
    while(cin >> n >> m,m || n){
        //初始化
        memset(f, 0, sizeof f);
          for(int i = 0;i < 1 << n; i++){
             st[i] = true;
             int cnt = 0;
             for(int j = 0; j < n; j++){
                 if(i >> j & 1){
                 if(cnt & 1)st[i]=false;
                 cnt = 0;
             }else {
             cnt ++;
               }
         }
        if(cnt & 1)st[i] = false;
            }
        f[0][0] = 1;
          for(int i = 1;i <= m; i ++){
            for(int j = 0; j<1 << n; j++){
               for(int k = 0;k< 1 << n; k++){
                  if((j&k)==0 && st[j|k]){
                    f[i][j]+=f[i-1][k];
                    }
               }
            }
          }
          cout<<f[m][0]<<endl;
         }
           return 0;
        }
```




<br/><br/>


状态压缩2

解法：

这里用二维数组表示f(i)(j)

表示从0到j   的状态 为i   并且i的第j位为1

倒数第二个点k

从0到 i  的状态表示为i减去j   (这里的减去是把i的二进制数第j个位置变成0，可以用  i-(1<<j)表示)  再加上w(k)(j);



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002033300.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002035509.png" width="70%" height="70%" />






```cPP
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 20,M=1<<N;
int n;
int w[N][N];
int f[M][N];
int main(){
    cin >> n;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
          cin >> w[i][j];
          }
        }
        memset(f, 0x3f, sizeof f);

        //在零号点走到零号点
        f[1][0]=0;
        for(int i=0;i<1<<n;i++){
          for(int j=0;j<n;j++){
             if(i>>j&1){
                for(int k=0;k<n;k++){
                    if((i-(1<<j))>>k&1){
                       f[i][j]=min(f[i][j],f[(i-(1<<j))][k]+w[k][j]);
                    }
                 }
                }
              }
          }
        cout<<f[(1<<n)-1][n-1];
        return 0;
        }
```


<br/><br/>


### 9、树型dp

两个状态 

f(u)(0)表示当前节点不选的最大幸福感

f(u)(1)表示选当前节点的最大幸福感

然后递归处理

这里建图用邻接表

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006213819.png" width="70%" height="70%" />

<br/><br/>
<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006174743.png" width="70%" height="70%" />

<br/><br/>



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006175029.png" width="70%" height="70%" />




```cpp
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 6010;
int e[N],ne[N],g[N];
int idx;
int happy[N];
int havefather[N];
int f[N][2];

void creat(int a,int b){
    e[idx] = b;
    ne[idx] = g[a];
    g[a] = idx++;
}
void dfs(int u){
    f[u][1] = happy[u];
    for(int i = g[u] ; i != -1 ;i=ne[i]){
        int j = e[i];
        dfs(j);
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0],f[j][1]);
    }
}

int main(){
    int n;
    cin>>n;
    for(int i = 1 ;i <= n;i ++){
        cin>>happy[i];
    }

    memset(g, -1, sizeof g);
    for(int i = 0;i<n -1 ;i++){
        int a,b;
        cin >> a >> b;
        havefather[a] = 1;
        creat(b,a);
    }

        //找出根节点
         int root = 1;
    while(havefather[root])root++;

        dfs(root);
        int mx = max(f[root][0],f[root][1]);
        cout<<mx;
        return 0;
}
```

<br/><br/>


### 10、搜索dp

思路：

f(i)(j)  表示当前 i j 这个位置最大距离

可以用 下一个状态加一表示

dfs的变形

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221012120015.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221012212700.png" width="70%" height="70%" />


```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

const int N=310;
int f[N][N];
int h[N][N];
int n,m;
int d1[4]={1,0,-1,0};
int d2[4]={0,1,0,-1};

int dfs(int i,int j){
   int&v=f[i][j];
   if(v!=-1)return v;
   v=1;
   for(int w=0;w< 4;w++){
      int a=i+d1[w];
      int b=j+d2[w];
      if(a>=1&&a<=n&&b>=1&&b<=m&&h[i][j]>h[a][b]){
         v=max(v,dfs(a,b)+1);
      }
   }
      return v;
}
int main(){
   cin>>n>>m;
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         cin>>h[i][j];
             }
      }
   int res=1;
   memset(f,-1,sizeof f);
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        res=max(res,dfs(i,j));
        }
   }
   cout<<res;
   return 0;  
}
```



<br/><br/>



### 11、红酒(杨辉三角)

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221120015643.png" width="70%" height="70%" />


<br/><br/>

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221120015632.png" width="70%" height="70%" />




```cpp
class Solution {
public:
    double champagneTower(int poured, int query_row, int query_glass) {
       double dp[query_row+2][query_row +2];
       memset(dp,0,sizeof(dp));
       if(poured < 1)return poured*1.0;
       else dp[1][1] = poured*1.0; 
       for(int i = 1 ;i <= query_row ; i ++){
           for(int j = 1 ;j <= i ; j ++){
               if(dp[i][j] >1){
                 dp[i + 1][j] += (dp[i][j] - 1)*1.0/2;
                 dp[i + 1][j  + 1] += (dp[i][j] - 1)*1.0/2;
               }
           }
       }
       if(dp[query_row + 1][query_glass+1]>=1)return 1.0;
       return dp[query_row +1][query_glass+1];
    }
};
```









## 二十三、高级数据结构

### 1、树状数组

> 用树状数组也可以构造差分数组  add里面值为a[i] - a[i - 1]    循环就行了

```
树状数组
引入问题
给出一个长度为nn的数组，完成以下两种操作：
1. 将第ii个数加上kk
2. 输出区间[i,j][i,j]内每个数的和

朴素算法
单点修改：O(1)O(1)
区间查询：O(n)O(n)
使用树状数组
单点修改：O(logn)O(logn)
区间查询：O(logn)O(logn)
前置知识
lowbit()lowbit()运算：非负整数xx在二进制表示下最低位1及其后面的0构成的数值。

举例说明：
lowbit(12)=lowbit([1100]2)=[100]2=4lowbit(12)=lowbit([1100]2)=[100]2=4
函数实现：

int lowbit(int x)
{
    return x & -x;
}
树状数组思想
树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为O(logn)O(logn)。

对于一个序列，对其建立如下树形结构：


```

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114021821.png" style="zoom:67%;" />



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114022000.png" style="zoom: 80%;" />



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114021846.png" style="zoom:67%;" />



#### 1、楼兰图腾

找到下标为i  的左边多少比他大的 右边多少比他大的

以及比他小的

可以用树状数组统计

然后两边相乘就行了

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114100346.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 200010;
int n;
int tre[N],low[N],great[N];
int a[N];
//找到最右边的1
int lowbit(int x){
    return x & -x;
}

//求和
int count(int x){
    int sum = 0;
    for(int i = x; i ; i = i -lowbit(i)){
        sum += tre[i];
    }
    return sum;
}

//改变某个数
void add(int x,int k){
    for(int i = x ; i <= n ; i = i + lowbit(i)){
     tre[i] +=k;
    }

}

int main(){
    cin>>n;
    for(int i = 1; i <= n ;i ++){
        scanf("%d",&a[i]);
    }
    
    long long sum1 = 0;
    long long sum2 = 0;
    for(int i = 1; i <= n ; i ++){
        int c = a[i];
        //求比他小的数的个数
        low[i] = count(c - 1);
        //比他大的数的个数
        great[i] = count(n) - count(c);
        //加入树状数组中
        add(c,1);
    }
    
    memset(tre,0,sizeof(tre));
    for(int i = n ;i >= 1 ; i --){
        int c = a[i];
        sum1 += (long long )low[i]*count(c - 1);
        sum2 += (long long)great[i]*(count(n) - count(c));
        add(c,1);
    }
    cout<<sum2<<" "<<sum1;
    return 0;
}

```



#### 2、简单的整数问题

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114234053.png)



有两种思路：

第一种：

算贡献度  用差分思想  前面加后面减

然后求和的值就是其增加或者减少的值再加上这个位置本身的值 得到最终答案



```cpp
#include<bits/stdc++.h> 
using namespace std;
int n,m,a[1000000],c[1000000];
char o;
int js(int t)
{
    return t&(-t);
}
int jk(int x,int y)
{
    for(;x<=n;x+=js(x))
        c[x]+=y;
}
int vn(int x)
{
    //这一步不一样
    int ans=a[x];
    for(;x;x-=js(x))
        ans+=c[x];
    return ans;
}
int main()
{
    scanf("%d%d",&n,&m);
    for(int i=1;i<=n;i++)
        scanf("%d",&a[i]);
    for(int i=1;i<=m;i++)
    {
        scanf(" %c",&o);
        int y,z,v;
        if(o=='C')
        {
            scanf("%d%d%d",&y,&z,&v);
            jk(y,v);
            jk(z+1,-v);
        }
        else if(o=='Q')
        {
            scanf("%d",&y);
            printf("%d\n",vn(y));
        }
    }
    return 0;
}

```



第二种：先构造差分数组

然后在差分数组上面操作  然后再用树状数组求前缀和

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
const int N = 100010;
int a[N],t[N];
int n,m;
int lowbit(int x)  // 返回末尾的1
{
    return x & -x;
}

void add(int x,int c){
    for(int i = x; i <= n ;i = i+lowbit(i)){
        t[i] += c;
    }
}

long long sum(int x){
    long long c = 0;
    for(int i = x ; i ; i -= lowbit(i)){
        c += t[i];
    }
    return c;
}
int main(){
    cin>>n>>m;
    for(int i =1 ; i <= n ; i ++){
        scanf("%d", &a[i]);
    }
    for(int i = 1 ; i <= n ; i ++){
        add(i,a[i] - a[i - 1]);
    }
    char c;
    while(m --){
        int l,r,d;
        scanf(" %c",&c);
        if(c =='C'){
            scanf("%d%d%d",&l,&r,&d);
            add(l,d);
            add(r + 1,-d);
        }else {
            int x;
            scanf("%d",&x);
            printf("%d\n",sum(x));
        }
    }
    return 0;
}
```





#### 3、简单整数问题2

问题描述：

+ 一个数组 ，然后m次询问，每次询问如果为Q  就输入l,r  问数组 下标l ->r的和
+ 如果不为Q ，那么输入l,r,d ，表示将这个数组L -> R的范围加上d



解法：

> 我们假设原数组为a,原数组的差分数组为b
>
> 那么我们b求前缀和就可以得到a[i]  ，然后对1到i求前缀和就得到 前i个数的和
>
> 那么就是一个矩阵  如下图 ，我们要求矩阵的黑色部分，我们可以把它补成一个完整的矩阵
>
> 然后在用总的减去红色的
>
> 我们可以发现红色的满足  bi * i 的前缀和，所以我们要维护两个前缀和  分别为b 以及b * i

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230113045904.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;
int a[N];
//a的差分数组b
long long  tre1[N];
//差分数组b乘i
long long  tre2[N];

int n;

int lowbit(long long  x)
{
    return x & -x;
}

//改变树状数组
void add(long long tre[],int x,long long c){
    for(int i = x;i <= n ;i += lowbit(i)){
        tre[i] += c;
    }
}

//求和
long long sum(long long tre[],long long x){
    long long res  = 0;
    for(int i = x;i;i -= lowbit(i)){
        res += tre[i];
    }
    return res;
}


//求出第前x位置的前缀和
long long  count(int x){
    return sum(tre1,x) * (x + 1) - sum(tre2,x);
}


int main(){
     int m;
    scanf("%d%d",&n,&m);
    for(int i= 1  ;i <= n ; i ++)scanf("%d",&a[i]);
    
    //处理两个数组的差分
    for(int i = 1 ; i <= n ; i ++){
        int  b = a[i] - a[i - 1];
        add(tre1,i,b);
        add(tre2,i,(long long)b*i);
    }
 

   while(m --){
       char a[2];
       int  l,r,d;
       scanf("%s%d%d",a,&l,&r);
       
       if(*a == 'Q'){
           printf("%lld\n",count(r) - count(l - 1));
       }else {
           scanf("%d",&d);
           add(tre1,l,d);
           add(tre2,l,l*d);
           add(tre1,r + 1,-d);
           add(tre2,r + 1,-d*(r + 1));
       }
   }
    
}
```







### 2、线段树

概念
>线段树和堆一样，用数组表示，我们规定从根节点从1开始，那么左儿子是 2 * i ，右儿子是2 * i + 1
>我们用结构体表示线段树，分别存根的下标，已经 l 和r   ， 分别表示当前根覆盖的范围
>线段树可以在一个区间操作和修改，时间复杂度是log(n)



这里有一副图

其实我们可以看出线段树就是和堆一样的完全二叉树

![算法学习笔记(14): 线段树](https://gitee.com/hongshenghyj/typora/raw/master/img/v2-5e9124a6147143e51cea46755e9a0398_720w.jpg)





#### **线段树模版**

核心操作：

>建立一棵树，所以我们可以递归地创建，首先传入根结点1，以及区间的最左端点和区间的最右端点
>根节点的l 和r 肯定包含左右端点
>左儿子的下标是  2 * u  ,包含l 到 mid
>右儿子下标是 2 * u + 1,包含 mid + 1 到 r  递归建立就行了

```cpp
struct node{
    //这个结点包含的左右端点
    int l,r;
    //这一区间的最大值
    long long v;
}tr[4 * N];
int m,p;

//创建线段树
void build(int u,int l,int r){
    tr[u] = {l,r};
    if(l == r)return;
    int mid = l + r >> 1;
    //左右递归
    build(u << 1,l,mid),build(u * 2 + 1 ,mid + 1, r);
}

```



>单点修改，修改某个位置的值，然后其父节点也要随着变化，我们递归查找，如果当前结点是叶子结点，那么我们就找到这个值了，那么直接修改，否则根据修改位置决定往哪里递归，每次递归结束要更新一下当前结点的最大值

```cpp
//单点修改
void modify(int u,int x,int v){
    if(tr[u].l == x && tr[u].r == x)tr[u].v = v;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid)modify(u * 2,x,v);
        else modify(u * 2 + 1,x,v);
        pushup(u);
    }
}
```



>更新当前结点对应的最大值，只要取出它的两个儿子包含区间的最大值就行了

```cpp
//更新当前结点的最大值
void pushup(int u){
  tr[u].v = max(tr[u* 2].v,tr[u * 2 + 1].v);
}

```



>查询比较复杂，要考虑查询的范围和根范围的大小
>1、如果查询范围大于整个根的范围，直接返回当前根的最大值就行了
>2、如果有越界，就判断要不要左右递归

```cpp

//查询最大值
long  long query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r)return tr[u].v;
    int mid =tr[u].l + tr[u].r >> 1;
    long long v = 0;
    if(l <= mid){
       v = max(v,query(u * 2,l,r));
    }
    if(r > mid){
        v = max(v,query(u * 2 + 1,l,r));
    }
    return v;
}

```







#### 找出最大数

>线段树经典题目

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126021559.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
const int N = 200010;
#include <cmath>
using namespace std;

struct node{
    //这个结点包含的左右端点
    int l,r;
    //这一区间的最大值
    long long v;
}tr[4 * N];
int m,p;

//更新当前结点的最大值
void pushup(int u){
  tr[u].v = max(tr[u* 2].v,tr[u * 2 + 1].v);
}

//创建线段树
void build(int u,int l,int r){
    tr[u] = {l,r};
    if(l == r)return;
    int mid = l + r >> 1;
    //左右递归
    build(u << 1,l,mid),build(u * 2 + 1 ,mid + 1, r);
}


//查询最大值
long  long query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r)return tr[u].v;
    int mid =tr[u].l + tr[u].r >> 1;
    long long v = 0;
    if(l <= mid){
       v = max(v,query(u * 2,l,r));
    }
    if(r > mid){
        v = max(v,query(u * 2 + 1,l,r));
    }
    return v;
}

//单点修改
void modify(int u,int x,int v){
    if(tr[u].l == x && tr[u].r == x)tr[u].v = v;
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid)modify(u * 2,x,v);
        else modify(u * 2 + 1,x,v);
        pushup(u);
    }
}

int main(){
    cin>>m>>p;
    build(1,1,m);
    int n = 0;
    long last  = 0;
     char s[2];
    int l;
    while(m --){
        char ch;
        int x;
        cin >> ch >> x;
        if (ch == 'A') modify(1,++n,(last+x)%p);
        else {
            last = query (1,n-x+1,n);
            cout << last << endl;
        }
    }
    return 0;
}
```





#### 你能回答这些问题吗

>思路:
>构造结构体：
>和上一题一样，我们要l和r以及当前结点的信息，同时我们还有记录当前结点区间的最大连续字段和max
>因为最大连续子序列可能跨域两个儿子的区间，同时我们要记录左儿子的最大后缀和和右儿子的最大前缀和
>最终我们取 三个中的最大的
>
>我们还要考虑怎么求最大后缀和，以及最大前缀和
>有两种情况：
>当前前缀和横跨左右儿子，那么值为左儿子的总和加上有儿子的最大前缀和
>当前的前缀和没有横跨，直接取左儿子最大前缀和就行了
>后缀也一样，最后两个值取最大
>所以结构体重要存当前区间的总和
>
>求当前区间的总和：
>左儿子加右儿子

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126040239.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230126023002.png)

代码

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
const int N = 500010;
#include <cmath>
using namespace std;
int w[N];
struct Node{
    //这个结点包含的左右端点
    int l,r;
    //这一区间的总和，最大前缀，最大后缀，最大连续子序列的值
    int sum,lmax,rmax,tmax;
}tr[4 * N];
int n,m;

//更新当前结点的信息
void pushup(Node & u,Node & l, Node & r){
   //当前结点的区间和
   u.sum = l.sum + r.sum;
   //当前结点区间的最大前缀和最大后缀
   u.lmax = max(l.sum + r.lmax,l.lmax);
   u.rmax = max(r.sum + l.rmax,r.rmax);
   //当前结点对应区间的最大值连续子序列的值
   u.tmax = max(l.tmax,max(r.tmax,l.rmax + r.lmax));
}

void pushup(int u){
    pushup(tr[u],tr[u * 2],tr[u* 2 + 1]);
}

//创建线段树
void build(int u,int l,int r){
    //叶子结点
    if(l == r){
        tr[u] = {l,r,w[l],w[l],w[l],w[l]};
    }else {
        tr[u].l = l,tr[u].r = r;
        int mid = l + r >> 1;
        build(u * 2,l,mid);
        build(u * 2 + 1,mid + 1,r);
        pushup(u);
    }
}


//查询
Node query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r)return tr[u];
    int mid =tr[u].l + tr[u].r >> 1;
    if(r <= mid){
       return query(u * 2,l,r);
    }
    else if(l > mid){
        return query(u * 2 + 1,l,r);
    }else {
        auto left = query(u * 2,l,r);
        auto right = query(u * 2 + 1,l,r);
        Node res;
        pushup(res,left,right);
        return res;
    }
}

//单点修改
void modify(int u,int x,int v){
    if(tr[u].l == x && tr[u].r == x)tr[u] = {x,x,v,v,v,v};
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid)modify(u * 2,x,v);
        else modify(u * 2 + 1,x,v);
        pushup(u);
    }
}
int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1;  i <= n ; i ++){
        scanf("%d",&w[i]);
    }
    build(1,1,n);
    int k,x,y;
    while (m -- ){
        scanf("%d%d%d",&k,&x,&y);
        if(k == 1){
            if(x > y)swap(x,y);
            printf("%d\n",query(1,x,y).tmax);
        }else {
            modify(1,x,y);
        }
    }
}

```









第二种写法，更好理解

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
const int N = 500010;
#include <cmath>
using namespace std;
int w[N];
struct Node{
    //这个结点包含的左右端点
    int l,r;
    //这一区间的总和，最大前缀，最大后缀，最大连续子序列的值
    int sum,lmax,rmax,tmax;
}tr[4 * N];
int n,m;

//更新当前结点的信息
void pushup(int  u){
   int l = u * 2;
   int r =  u* 2 + 1;
   //当前结点的区间和
   tr[u].sum = tr[l].sum + tr[r].sum;
   //当前结点区间的最大前缀和最大后缀
   tr[u].lmax = max(tr[l].sum + tr[r].lmax,tr[l].lmax);
   tr[u].rmax = max(tr[r].sum + tr[l].rmax,tr[r].rmax);
   //当前结点对应区间的最大值连续子序列的值
   tr[u].tmax = max(tr[l].rmax + tr[r].lmax,max(tr[r].tmax,tr[l].tmax));
}



//创建线段树
void build(int u,int l,int r){
    //叶子结点
    if(l == r){
        tr[u] = {l,r,w[l],w[l],w[l],w[l]};
    }else {
        tr[u].l = l,tr[u].r = r;
        int mid = l + r >> 1;
        build(u * 2,l,mid);
        build(u * 2 + 1,mid + 1,r);
        pushup(u);
    }
}


//查询
Node query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r)return tr[u];
    int mid =tr[u].l + tr[u].r >> 1;
    if(r <= mid){
       return query(u * 2,l,r);
    }
    else if(l > mid){
        return query(u * 2 + 1,l,r);
    }else {
        auto left = query(u * 2,l,r);
        auto right = query(u * 2 + 1,l,r);
        Node res;
        res.sum = left.sum + right.sum;
        res.lmax = max(left.sum + right.lmax,left.lmax);
        res.rmax = max(right.sum + left.rmax,right.rmax);
        res.tmax = max (max(left.tmax,right.tmax),left.rmax + right.lmax);
        return res;
    }
}


//单点修改
void modify(int u,int x,int v){
    if(tr[u].l == x && tr[u].r == x)tr[u] = {x,x,v,v,v,v};
    else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(x <= mid)modify(u * 2,x,v);
        else modify(u * 2 + 1,x,v);
        pushup(u);
    }
}


int main(){
    scanf("%d%d", &n, &m);
    for(int i = 1;  i <= n ; i ++){
        scanf("%d",&w[i]);
    }
    build(1,1,n);
    int k,x,y;
    while (m -- ){
        scanf("%d%d%d",&k,&x,&y);
        if(k == 1){
            if(x > y)swap(x,y);
            printf("%d\n",query(1,x,y).tmax);
        }else {
            modify(1,x,y);
        }
    }
}

```





#### 区间最大公约数

思路

> 我们首先要知道一个规律:
> gcd(a,b,c,d.....n) = gcd(a,b-a,c-d...)
>
> 然后我们可以用线段树保存差分数组
> 线段树里面保存的内容有:
>
> + sum 差分数组的和  这一区间
> + d是当前区间的最大公约数
>
> 我们建树的时候和很好求，两个儿子相加就行了，然后d就是两个儿子的最大公约数再求一次就行了
>
> 假如我们要求 l 到 r的最大公约数我们可以转换为(a(l), a(l + 1) - a(l),a(l + 2) - a(l + 1))
> a(l + 1) - a(l)  就是差分数组   b(l + 1)
> query 求得就是 b(l + 1)到b(r)的最大公约数  然后再gcd(这个数本身就行)
>
> 注意点：
> 这个数本身用前缀和来求，因为有修改，还有就是越界问题



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230127112724.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 500010;
long long w[N];
int n,m;
struct Node{
    int l,r;
    //这一区间的和
    long long sum;
    //这一区间的最大公约数
    long long d;
}tr[N*4];

//求最大公约数
long long gcd(long long a , long long b)
{
    return b ? gcd(b, a % b) : a;
}

//更新操作
void pushup(int u){
    int l = u * 2;
    int r = u * 2 + 1;
    tr[u].sum = tr[l].sum + tr[r].sum;
    tr[u].d = gcd(tr[l].d,tr[r].d);
}

//构建树
void build(int u,int l,int r){
    tr[u].l = l;
    tr[u].r = r;
    if(l == r){
        tr[u].d = w[r] - w[r - 1];
        tr[u].sum = w[r] - w[r - 1];
    }else {
        int mid = l + r >> 1;
        build(u*2,l,mid);
        build(u*2 + 1,mid + 1,r);
        pushup(u);
    }
}

//修改
void modify(int u,int x,long long v){
    if(tr[u].l == x && tr[u].r == x){
        tr[u].sum += v;
        tr[u].d = tr[u].sum;
    }else {
        int mid = tr[u].l + tr[u].r >> 1;
        if(mid >= x)modify(u*2,x,v);
        else modify(u * 2 + 1,x,v);
        pushup(u);
    }
}

//查询
Node query(int u,int l,int r){
    if(tr[u].l>= l && tr[u].r <= r)return tr[u];
    int mid = tr[u].l + tr[u].r >> 1;
    if(mid >= r)return query(u* 2,l,r);
    else if(mid < l)return query(u* 2 + 1,l,r);
    else {
        auto left = query(u*2,l,r);
        auto right = query(u * 2 + 1,l,r);
        Node res;
        res.sum = left.sum + right.sum;
        res.d = gcd(left.d,right.d);
        return res;
    }
}

int main(){
    cin>>n>>m;
    for(int i = 1 ; i <= n ; i ++){
        scanf("%lld",&w[i]);
    }
    build(1,1,n);
    while(m --){
        char c;
        int l,r;
        long long d;
        cin>>c>>l>>r;
        if(c == 'C'){
            scanf("%lld",&d);
            modify(1,l,d);
            if(r + 1 <= n)modify(1,r + 1,-d);
        }else {
            //求出w[l]
            Node left = query(1,1,l);
            Node right = {0,0,0,0};
            if(l + 1 <= r)
            right = query(1,l + 1,r);
            printf("%lld\n",abs(gcd(left.sum,right.d)));
        }
    }
    return 0;
}
```







#### **懒标记**

>懒标志支持区间修改，可以在log(n)的复杂度内修改一个区间
>pushdown为懒标记的操作，我们只要在结构体中加一个add，表示当前结点为根的子树加上一个add,不包括当前结点
>操作的时候，两个儿子要加上add,同时两个儿子的和要加上每个区间的变化和，然后吧根结点的标记清空
>
>注意点：
>查询和更新的时候都要pushdowc操作

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230129090926.png" alt="微信截图_20230129090926" style="zoom:67%;" />





#### 一个简单的整数问题2

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230129094336.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

const int N = 100010;
int n,m;
struct Node{
    long long l,r,sum,add;
}tr[N*4];
long long w[N];


void pushup(int u){
    int l = u * 2 ;
    int r = u * 2 + 1;
    tr[u].sum = tr[l].sum + tr[r].sum;
}


//构建树
void build(int u,int l,int r){
    tr[u].l = l;
    tr[u].r = r;
    if(l == r)tr[u] = {l,r,w[l],0};
    else {
        int mid  = (l + r >> 1);
        build(u * 2,l,mid);
        build(u * 2 + 1,mid + 1, r);
        pushup(u);
    }
}


//懒标记
void pushdown(int u){
    if(tr[u].add == 0)return ;
    int l = u* 2;
    int r = u * 2 + 1;
    tr[l].add+= tr[u].add;
    tr[l].sum += (tr[l].r - tr[l].l + 1)*tr[u].add;
    tr[r].add += tr[u].add;
    tr[r].sum += (tr[r].r - tr[r].l + 1) * tr[u].add;
    tr[u].add = 0;
}

//修改
void modify(int u,int l,int r,int d){
    if(tr[u].l >= l && tr[u].r <= r){
        tr[u].add += d;
        tr[u].sum += (tr[u].r - tr[u].l + 1) * d;
    }else {
        int mid = (int)(tr[u].l + tr[u].r >> 1);
        pushdown(u);
        if(l <= mid)modify(u * 2,l,r,d);
        if(r > mid)modify(u * 2 + 1,l,r,d);
        pushup(u);
    }
}

long long query(int u,int l,int r){
    if(tr[u].l >= l && tr[u].r <= r){
        return tr[u].sum;
    }else {
        pushdown(u);
       int mid = (int)(tr[u].l + tr[u].r >> 1);
        long long sum =0;
        if(l <= mid)sum += query(u * 2,l,r);
        if(r > mid)sum += query(u * 2 + 1,l,r);
        return sum;
    }
}

int main(){
    scanf("%d%d", &n,&m);
    for(int i = 1; i <= n ; i ++)scanf("%lld",&w[i]);
    build(1,1,n);
    while(m -- ){
        char a;
        int l,r;
        int d;
        cin>>a>>l>>r;
    
        if(a == 'Q'){
            printf("%lld\n",query(1,l,r));
        }else {
            cin>>d;
            modify(1,l,r,d);
        }
    }
    return 0;
}
```





### **3、离散化**

>  主要是把分散的点聚集在一起  然后用前缀和求
>
> 

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230115033335.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221029131633.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int a[300010];
vector<pair<int,int>>add;
vector<int>alls;
vector<pair<int,int>>quary;
int s[300010];
//根据值找离散后的下标
int find(int x){
    int n = alls.size();
    int l = 0;
    int r = n -1 ;
    while(l < r){
        int mid = (l + r)/2;
        if(alls[mid] >= x){
            r = mid;
        }else {
            l = mid + 1;
        }
    }
    return r + 1;
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i = 0 ; i < n ; i ++){
        int x,c;
        cin>>x>>c;
        alls.push_back(x);
        add.push_back({x,c});
    }
    for(int  i = 0 ; i < m ; i ++){
        int l,r;
        cin>>l>>r;
        quary.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());
    
    //预处理前缀和
    for(auto&k : add){
        int x = find(k.first);
        a[x] += k.second;
    }
    
    for(int i = 1 ; i <= alls.size() ; i ++){
         s[i] = s[i - 1] + a[i];
    }
    
    //处理询问
    for(auto& k: quary){
        int  l = k.first;
        int  r = k.second;
        l = find(l);
        r = find(r);
        cout<<s[r] - s[l - 1]<<endl;;
    }
    return 0;
    
}
```





## 二十四、数学

### 技巧

```
 // 因为 a*b == 最小公倍数*最大公约数
 // 所以 最小公倍数 == a*b / 最大公约
```

### 1、试除法判断质数

没什么技巧

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include<cmath>
using namespace std;
bool judge (int x){
    if(x <= 1)return false;
    int mid = (int)(sqrt(x*1.0));
    for(int i  = 2 ; i <= mid ; i ++ ){
        if(x % i == 0)return false;
    }
    return true;
}
int main()
{
    int n;
    cin>>n;
    for(int i  = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        if(judge(a))cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```





### 2、分解质因数

这里能确保每一次的i是质数 因为每一个合数可以分解为质数乘另一个数 所以合数肯定被前面的操作除完了

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221104020211.png" style="zoom:67%;" />

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#include <cmath>

void count(int x){
    int a = (int)sqrt(x);
    for(int i  = 2 ; i <=a ; i ++){
        if(x % i == 0){
            int sum = 0;
            while(x % i == 0){
                sum ++;
                x /=i;
            }
            cout<<i<<" "<<sum<<endl;
        }
    }
    if(x > 1)cout<<x<<" "<<1<<endl;
}
int main(){
    int n;
    cin>>n;
    for(int i = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        count(a);
        cout<<endl;
    }
    return 0;
}
```



### 3、质数

找出1到n中的所有质数

```cpp
void get_primes2(){
    for(int i=2;i<=n;i++){

        if(!st[i]) primes[cnt++]=i;//把素数存起来
        for(int j=i;j<=n;j+=i){//不管是合数还是质数，都用来筛掉后面它的倍数
            st[j]=true;
        }
    }

}
2.诶氏筛法 O(nloglogn)O(nloglogn)
C++ 代码
void get_primes1(){
    for(int i=2;i<=n;i++){
        if(st[i] == false){
            primes[cnt++]=i;
            for(int j=i;j<=n;j+=i) st[j]=true;//可以用质数就把所有的合数都筛掉；
        }
    }
}
3.线性筛法 O(n)O(n)
C++ 代码
void get_primes(){
    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++){//primes[j]<=n/i:变形一下得到——primes[j]*i<=n,把大于n的合数都筛了就
        //没啥意义了
            st[primes[j]*i]=true;//用最小质因子去筛合数

            //1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]<i的
            //最小质因子,所以primes[j]*i的最小质因子就是primes[j];
            //2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是
            //prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小
            //质因子primes[j]<primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该
            //退出循环，避免之后重复进行筛选。
            if(i%primes[j]==0) break;
        }
    }

}
```

```cpp
void get_prime(int n)
{
    for(int i = 2; i <= n; i++)
    {
        if(!st[i])                              //如果还没被标记过，就说明这是个质数，就把它加入到队列中
            prime[cnt++] = i;

        for(int j = 0; prime[j] <= n / i; j++)  //确保第j个质数和i相乘不会爆n
        {
            st[prime[j] * i] = true;
            /*
                prime[]数组中的素数是递增的,当i能整除prime[j]，那么i*prime[j+1]这个合数
                肯定被prime[j]乘以某个数筛掉。
                因为i中含有prime[j],prime[j]比prime[j+1]小，
                即i=k*prime[j]，那么i*prime[j+1]=(k*prime[j])*prime[j+1]=k’*prime[j]，
                接下去的素数同理。所以不用筛下去了。
                因此，在满足i%prime[j]==0这个条件之前以及第一次满足改条件时,
                prime[j]必定是prime[j]*i的最小因子。
            */
            if(i % prime[j] == 0)               
                break;
        }
    }
}

```





### 4、试除法求约数



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221104025330.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

vector<int>get(int x){
    vector<int>v;
    for(int i = 1 ; i<= x/i; i ++ ){
        if(x % i == 0){
            v.push_back(i);
           if(i != x/i)v.push_back(x/i);
        }
    }
    sort(v.begin(),v.end());
    return v;
}
int main()
{
    int n;
    cin>>n;
    for(int i = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        auto v = get(a);
        for(int k:v){
            cout<<k<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```



### 5、最大公约数

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int find(int a,int b){
    if(b == 0)return a;
    else return find(b,a % b);
}
int main(){
    int n;
    cin>>n;
    while(n --){
        int a,b;
        cin>>a>>b;
        cout<<find(a,b)<<endl;
    }
    return 0;
}
```





## 二十五、贪心

### 1、区间找点

思路：安第二点从小到大进行排序

然后每次维护右端点的值

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include <vector>
int main(){
    int n;
    cin>>n;
    vector<vector<int>>v(n);
    for(int i = 0; i <n  ; i ++){
        int a,b;
        scanf("%d%d",&a,&b);
        v[i].push_back(a);
        v[i].push_back(b);
    }
    //排序
    sort(v.begin(),v.end(),[&](vector<int>n1,vector<int>n2){
        return n1[1]<n2[1];
    });
    int sum = 1;
    int last = v[0][1];
    for(int i = 1; i < n ; i ++){
        //cout<<v[i][0]<<endl;
        if(v[i][0]<= last)continue;
        else {
            sum ++;
            last = v[i][1];
        }
    }
    cout<<sum;
    return 0;
}
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113154551.png)



思路和上面一题一样的

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113155510.png)



### 2、区间分组

思路：

用结构体存储  然后按照左端点从左到右进行排序

这里用小顶堆来维护每个组的最右边的位置

如果堆中的数大于当前点左边位置   那么新增一个组  也就是第一个组都能被覆盖

否则就加入第一个组 将堆顶pop出  更新右端点的距离

最后堆中的数量就是分组的个数



```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstdio>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {

        if (heap.empty() || heap.top() >= range[i].l){
            heap.push(range[i].r);
        }
        else {
            heap.pop();
            heap.push(range[i].r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}

```





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113160150.png)



### 3、区间覆盖

思路：

就是每次找出可以覆盖当前区间左端点的  区间中右端点最大的区间  然后更新左端点



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
typedef struct Range{
    int l,r;
}range;
int main(){
    int st,ed;
    scanf("%d%d",&st,&ed);
    int n;
    cin>>n;
    range r[n];
    for(int i = 0 ;i < n ; i ++){
        scanf("%d%d",&r[i].l,&r[i].r);
    }
    sort(r,r+n,[&](range r1,range r2){
        return r1.l<r2.l;
    });
    int sum = 0;
    bool flag = false;
    for(int i = 0 ;i < n ; i ++){
       // cout<<i<<endl;
        int j = i;
        int ri = -2e9;
        while(j<n &&r[j].l<=st){
            ri = max(ri,r[j].r);
            j++;
        }
        if(ri<st){
            flag =false;
            break;
        }
         sum ++;
        if(ri >=ed){
            flag = true;
            break;
        }
        i = j -1;
        st = ri;
    }
    if(flag ==false)sum = -1;
    printf("%d",sum);
}
```





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113161530.png)







### 4、排队打水

我们只需要将把时间长的放后面就行了

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include<vector>
int main(){
    int n;
    cin>>n;
    vector<long long >v(n,0);
    int index = 0;
    while(n --){
        cin>>v[index];
        index ++;
    }
    sort(v.begin(),v.end());
    long long  sum = 0 ;
    long long  count = 0 ;
    for(int i = 0 ;i <v.size(); i ++){
        count += sum;
        sum +=v[i];
    }
    cout<<count<<endl;
    return 0;
}
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113163017.png)



### 5、仓库选址

主要是一个不等式   

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;
int main(){
    int n;
    cin>>n;
    long long sum = 0;
    int a[n];
    for(int i = 0 ; i < n ; i ++){
        cin>>a[i];
    }
    sort(a,a+n);
    for(int i = 0 ; i < n ; i ++){
        sum += abs(a[n/2] - a[i]);
    }
    cout<<sum<<endl;
    return 0;
}
```





<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221108221000.png" style="zoom:67%;" />



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113163227.png)













## 二十六、滑动窗口

>维护一个序列的长度，然后通过窗口的移动，维护某一个值，参考计算机网络



例子

![微信截图_20230302180133](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20230302180133.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;
vector<int>list;
vector<int>list2;
int get(){
    return list[0];
}

void add(int x){
    while(list.size() > 0 && list[list.size() - 1] > x){
        list.erase(list.begin() + list.size() - 1);
    }
    list.push_back(x);
}

void del(int a){
    if(list.size() > 0 && list[0] == a){
        list.erase(list.begin() + 0);
    }
}

int main(){
    int n,m;
    cin>>n>>m;
    vector<int>v(n);
    for(int i = 0; i < n ; i ++)cin>>v[i];
    for(int i = 0 ; i < m ; i ++)add(v[i]);
    cout<<get()<<" ";
    for(int i = m ; i < n ; i ++){
        del(v[i - m]);
        add(v[i]);
        int a = get();
        cout<<a<<" ";
    }
   
    return 0;
}
```

