# 算法汇总



## 没搞懂的

1、堆

3、kmp



## 注意点

1、稠密图用矩阵，稀疏图用邻接表

这里的邻接表也用数组来模拟，参考下面图论代码

邻接表就是用一个g数组表示各个点  初始为-1

然后next数组表示下一下点的位置

value数组表示值

Index表示下标



## **一、时间复杂度**

### 1、算法优劣的核心指标

时间复杂度  额外空间复杂度 常数项时间(细节)



### 2、常见的常数时间操作

加减乘除     位运算(>>  >>>   <<  |  &  ^)     赋值，比较，自增减     数组寻址

位运算简介：>>把二进制全部向右移动一位，前面第一位补没有移动前的第一位

​                    />>>前面第一位补零

n>>2  等价n/2

比如常见的冒泡，选择，插入都是O(n2)时间复杂度



### 3、确认时间复杂度

1、按照最坏情况考虑

2、把整个流程拆分为一个个基本动作，保证每个动作都是常数时间

3、数据量为n，看基本动作和n的关系

4、得到表达式后，把最高阶系数去掉并且只保留最高阶



### 4、额外的空间复杂度

和目的有关的开辟空间不算额外



### 5、对数器

用暴力解和你想出来的优解比较，验证解的准确性



### 6、Master公式求复杂度

这种公式只能用递归问题，并且子问题规模一样的时候才可以用，比如二分，子问题规模n/2

![微信截图_20220803032629](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220803032629.png)

## 二、二分法

### 1、普通二分查找

### 2、在一个有序的数组中找>=某个值的最左侧位置

算法：

int index=-1;

while(l<=r){

mid=(l+r)/2

if(a[mid]>=value) index =mid;r=mid-1 

else l=mid+1

}

return index;

### **3、局部最小值**

找出一个

先判断0位置和n-1位置是不是局部最小值

a[1]>a[0]或者a[n-1]<a[n-2]这两个都是局部最小值

如果端点没有，那么局部最小值一定在中间，因为先下降再上升，所以可以用二分

取mid

left=1

right=n-2

如果a[mid-1]<a[mid]那么局部最小值在mid左边，r=mid-1；

如果a[mid+1]<a[mid]在右边

反之两边都大于a[mid]，那么mid就是局部最小值的坐标，返回

结尾return left

### 4、例题

还有给一个不降序的数组，让你找出一个数，小于等于这个数的最右边，大于等于这个数的最左边

也就是 1 2 2 2 2 3 找出2区间的头和尾坐标

具体题目看代码笔记本

```java
while(l<=r){
        mid=(r+l)/2;
        if(num[mid]>=target){
        index1=mid;
        r=mid-1;
        }else l=mid+1;
        }
```

```java
while(l<=r){
        mid=(r+l)/2;
        if(num[mid]<=target){
        index2=mid;
        l=mid+1;
        }else r=mid-1;
 }
```

## 三、异或运算

### 1、异或运算概念

把两个数化为二进制

然后上下对其(长的前面补零)

相同为0不同为1

比如：1001110000

​           0111101110

结果是：1110011110

这就是异或运算



### 2、性质(重点)

0^n=n;

n^n=0

满足交换律和结合律

### 3、交换两个数

int a=甲   int b=已

a=a^b       a变成甲^乙

b=a^b         甲^乙^乙=甲

a=a^b          甲^乙^甲=乙

### 4、题目

1、找出一个数组中一种数出现了奇数次，其余全是偶数

直接让数组全部异或运算,最后结果就是这个数



2、把一个int类型的数最右侧的1取出来

结论：n&(~(n)+1)

&相同为1，不同为0



3、找数组中两个数是奇数个的

假设这两个数分别是a,b

首先让数组全部异或运算，得到e=a^b

然后用上面的结合计算把e最右侧1取出来 记作w

在这个位置上，a,b两个数肯定一个是1,一个是0

然后遍历数组和w&运算,因为w只有一位为1,其余为0,

```java
public void find(int []arr){
    int eor=0;
    for(int i=0;i<arr.length;i++){
        eor=eor&arr[i];
    }
    //eor=a^b 且！=0
    int rightone=eor&(~(eor)+1);
    int onlyone=0;
    for(int i=0;i<arr.length;i++){
        if((arr[i]&(rightone))!=0){
            onlyone=onlyone^arr[i];
        }
    }
    System.out.println(onlyone+"  "+(eor^onlyone));
}
```



### 5、&运算

同时为1才取1

 //取出第i位的数字
            int u=x>>i&1;

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724075216.png)

a&-a可以得到最右边的1



```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            int sum=0;
            int x=in.nextInt();
            while(x>0){
                int a=method(x);
                x=x-a;
                sum++;
            }
            System.out.print(sum+" ");
        }
    }
    public static int method(int a){
        return a&(-a);
    }
}
```





取出二进制为1的数

 for(int i = 0;i<32;i++){             if((n>>i&1)==1)list.add((n>>i&1)<<i);        }





### 5、移位

a<<b  a乘了b个2



### 6、|  

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220915025144.png)

## 四、排序

### 1、快速排序

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        long []num=new long[n];
        for(int i=0;i<n;i++){
            num[i]=in.nextLong();
        }
        quick_sort(num,0,n-1);
        for(int i=0;i<n;i++){
            System.out.print(num[i]+" ");
        }
    }
    public static void quick_sort(long[]num,int l,int r){
        if(l>=r)return;
        int left=l-1;
        int right=r+1;
        long mid=num[(l+r)/2];
        while(left<right){
            while(num[++left]<mid);
            while(num[--right]>mid);
            if(left<right){
                long temp=num[left];
                num[left]=num[right];
                num[right]=temp;
            }
        }

        quick_sort(num,l,right);
        quick_sort(num,right+1,r);
    }
}
```



### 2、插入排序

```java
public class insert {
    public static void main(String[] args) {
        int []a={2000000,9,-1,40,2,5,99,32,10000,-10000};
        int n=a.length;
        for(int i=1;i<n;i++){
            int num=a[i];
            int index=i;
            while(index-1>=0&&a[index-1]>num){
                a[index]=a[index-1];
                index--;
            }
            a[index]=num;
        }
        System.out.println(Arrays.toString(a));
    }
}
```



### 3、希尔排序

```java
public class xiersort2 {
    public static void main(String[] args) {
        int []a={111,4,5,6,7,-1,1,10,9};
        int n=a.length/2;
        for(;n>0;n=n/2){
            //从n开始，对其所在的组直接插入
            for(int i=n;i<a.length;i++){
                int j=i;
                int temp=a[i];
                if(a[j]<a[j-n]){
                    while(j-n>=0&&temp<a[j-n]){
                        a[j]=a[j-n];
                        j=j-n;
                    }
                    a[j]=temp;
                }
            }
        }
        System.out.println(Arrays.toString(a));
    }
}
```

### 4、归并排序

```java
public class dividsort {
    public static void mag(int []a,int left,int right){
        if(left==right)return;
        int mid=(left+right)/2;
        //向左递归
        mag(a,left,mid);
        //向右
        mag(a,mid+1,right);
        sort(a,left,right,mid);
    }
    //并的过程
    public static void sort(int []a,int left,int right,int mid){
        //左侧从left到Mid，右侧从Mid+1到right
        int p1=left;
        int p2=mid+1;
        int []help=new int[right-left+1];

        int index=0;
        while(p1<=mid&&p2<=right){
            if(a[p1]<=a[p2]){
                help[index++]=a[p1++];
            }else {
                help[index++]=a[p2++];
            }
        }

        while(p1<=mid){
            help[index++]=a[p1++];
        }
        while(p2<=right){
            help[index++]=a[p2++];
        }
        for(int i=0;i<help.length;i++){
            a[i+left]=help[i];
        }
    }
    public static void main(String[] args) {
        int []a={99,45,333,-11,1,6,9,2,7,0};
         mag(a,0,a.length-1);
        System.out.println(Arrays.toString(a));
    }
}
```

#### 题目

![微信截图_20220805022546](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220805022546.png)

![微信截图_20220807034332](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807034332.png)



### 5、基数排序

只能对正数进行排序

```java
public class radixsory {
    public void radsort(int []a) {
        int max = a[0];//得出大的数
        for (int i = 1; i < a.length; i++) {
            if (a[i] > max) {
                max = a[i];
            }
        }
        String s = max + "";
        int maxsize = s.length();//计算最高位是多少
        int[][] radix = new int[10][a.length];//定义十个桶，每个桶长度为数组长度
        int[] number = new int[10];//记录每个桶有多少个元素

        for (int i = 0, n = 1; i < maxsize; i++, n = n * 10) {
            for (int j = 0; j < a.length; j++) {
                int dignumber = a[j] / n % 10;//取出每个元素对应位数的值
                radix[dignumber][number[dignumber]] = a[j];//将对应值放入桶中
                number[dignumber]++;//将对应桶元素个数加一
            }
            //将桶中元素俺顺序放回原来数组
            int index = 0;
            for (int j = 0; j < 10; j++) {
                if (number[j] != 0) {
                    for (int w = 0; w < number[j]; w++) {
                        a[index++] = radix[j][w];
                    }
                }
                number[j] = 0;
            }
        }
    }
    public static void main(String[] args) {
        int []a={4,5,33,12,1,45,1,12,222,3};
        radixsory p=new radixsory();
        p.radsort(a);
        System.out.println(Arrays.toString(a));
    }
}
```





### **6、堆排序**

```java
import java.util.*;
public class Main{
    static int size;
    static int[]heap;
    public static void down(int i){
        int parent=i;
        int child=0;
        int temp=heap[i];
        for(;parent*2+1<size;parent=child){
            child=parent*2;
            if(child+1<size&&heap[child+1]>heap[child])child++;
            if(temp>=heap[child])break;
            heap[parent]=heap[child];
        }
        heap[parent]=temp;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        heap=new int[n];
        size=n;
        for(int i=0;i<n;i++){
            heap[i]=in.nextInt();
        }
        for(int i=n/2;i>=0;i--){
            down(i);
        }
        for(int i=0;i<n;i++){
            int temp=heap[0];
            heap[0]=heap[--size];
            heap[size]=temp;
            down(0);
        }
        for(int i=0;i<n;i++){
            System.out.print(heap[i]+" ");
        }
    }
}
```







## 五、前缀和

### 1、一维

概念：比如一个数组a   a0 a1 a2 a3 a4.... an

又有一个数组S    s1=s1   s2=a1+a2  s3 =a1+a2+a3  前缀和一般数组重下标为1开始

**求S：所以  Sn=an+Sn-1**

用途 求数组中a一个区间[l,r]的和

可以用Sr-Sl-1;

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220715163138.png)

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int l;
        int r;
        //下标从一开始
        int []num=new int[n+1];
        int []dp=new int[n+1];
        for(int i=1;i<=n;i++){
            num[i]=in.nextInt();
            dp[i]=dp[i-1]+num[i];
        }
        for(int i=0;i<m;i++){
            l=in.nextInt();
            r=in.nextInt();
            System.out.println(dp[r]-dp[l-1]+" ");
        }
    }
}


```



### 2、二维**

![img](https://gitee.com/hongshenghyj/typora/raw/master/img/v2-164e5df46fcfaaa6a3bc9ce325b08f4a_720w.jpg)

求一块区域的面积,一般让下标从零开始

  a00         a01       a02      a03     a04

  a10        a11        a12       a13     a14

  a20        a21        a22      a23     a24

  a30         a31       a32      a33     a34

 a40         a41         a42     a 43     a44

Sij右下角下标为i j 的矩形的面积

这时候有递推Sij=s(i-1)j+si(j-1)-s[i-1] [j-1]+a[i]  [i]

比如要求x1,y1为左上角，x2,y2为右下角面积

减去重复的，要加上

总的面积是S(x2)(y2) -S(x2)(y-1)-S(x1-1)(y2)+S(x1-1)(y1-1)

最后算出结果

输入一个数组，并且循环次数，给出左上角和右下角下标，求子矩阵的面积

```java
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int q=in.nextInt();
        int [][]num=new int[n+1][m+1];
        int [][]s=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                num[i][j]=in.nextInt();
            }
        }
        //构造S
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+num[i][j];
                //System.out.println(s[i][j]);
            }
        }
        for(int i=0;i<q;i++){
            int x1=in.nextInt();
            int y1=in.nextInt();
            int x2=in.nextInt();
            int y2=in.nextInt();
            int sum=s[x2][y2]-s[x2][y1-1]-s[x1-1][y2]+s[x1-1][y1-1];
            System.out.println(sum);
        }
    }
}
```



## 六、差分**

### 1、一维差分

差分就是前缀和的逆运算

a数组

b数组

ai=b0+...bi

a是b的前缀和，b是a的差分数组

**b1=a1    b2=a2-a1   b3=a3-a2    b4=a4-a3       大概是这样**

具体运用：比如要在原数组a中一段【l,r】中的每一个数都加c，那么可以运用差分数组，降低时间复杂度

可以让 b(l)+c    让 b(r+1)-c；

一般下标从一开始，比较好处理数据

原理可以看：b1   b2  b3  b4  b5  b6  b7 

要在a1到a4每个数加一

**可以让b1+1     结果是a1到后面每一个前缀和都加一   但是我们只希望加到下标为4的地方 ，所以b(5)-1  让a5后面的数减一，一加一减抵消了，只有1到4是加了1**

因为a是b的前缀和，最后在求一遍前缀和  b[i]=b[i-1]+b[i];

输出b[i]就行了，就是改变后的a数组

下面看一道例题：

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int []num=new int[n+2];
        int []b=new int[n+2];
        for(int i=1;i<=n;i++){
            num[i]=in.nextInt();
            insert(b,i,i,num[i]);
        }
        for(int i=0;i<m;i++){
            int l=in.nextInt();
            int r=in.nextInt();
            int c=in.nextInt();
            insert(b,l,r,c);
        }
        for(int i=1;i<=n;i++){
            b[i]=b[i]+b[i-1];
        }
        for(int i=1;i<=n;i++)System.out.print(b[i]+" ");
    }
    public static void insert(int []num,int i,int j,int c){
        num[i]+=c;
        num[j+1]-=c;
    }
}
```

值得注意的是，我们不用特意构造b数组，我们可以想象a数组初始为0，然后，然后在i到i上加a[i],也就是差分运算，最后得出的就是b数组



### 2、二维差分

二维差分也是一样，我们的目的是让子矩阵中的每个元素加一个常数c

  a00         a01       a02      a03     a04

  a10        a11        a12       a13     a14

  a20        a21        a22      a23     a24

  a30         a31       a32      a33     a34

 a40         a41         a42     a 43     a44

再次说明，我们下标一般从一开始，这样子就不用判断下标等于0的时候怎么操作了，比较方便

我们假设子矩阵的左上角x1,y1,右下角为x2,y2

我们让b(x1)(y1)+=c这样右下角整块大的矩阵就全部加上了c

所以b(x2+1)(y1)-=c       b(x1)(y2+1)-=c    又因为重复减了   所以b(x2+1)(y2+1)+=c

最后我们在用老办法前缀和求二维数组b

**记住，我们初始化b也可以用上面的公式，不用刻意去记住怎么初始化b**

下面是例题，给出，n,m,q 然后输入数组，在输入q组数据x1,y1,x2,y2  c 这块区域加c最后输出数组的样子

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int q=in.nextInt();
        int [][]a=new int[n+2][m+2];
        int [][]b=new int[n+2][m+2];
        //构造a数组和b数组
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                a[i][j]=in.nextInt();
                insert(i,j,i,j,b,a[i][j]);
            }
        }
        //差分数组b的构建
        for(int i=0;i<q;i++){
            int x1=in.nextInt();
            int y1=in.nextInt();
            int x2=in.nextInt();
            int y2=in.nextInt();
            int c=in .nextInt();
            insert(x1,y1,x2,y2,b,c);
        }
        //和前缀和数组一样，求出来
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                a[i][j]=b[i][j]+a[i-1][j]+a[i][j-1]-a[i-1][j-1];
                System.out.print(a[i][j]+" ");
            }
            System.out.println();
        }


    }
    public static void insert(int x1,int y1,int x2,int y2,int [][]b,int c){
        b[x1][y1]+=c;
        b[x2+1][y1]-=c;
        b[x1][y2+1]-=c;
        b[x2+1][y2+1]+=c;
    }

}
```



## 七、图论

### 1、迪杰斯拉算法

```java
public class Dijkstra {
    //有权图单源最短路
    static int[][] graph;
    static int node;//结点数
    static int edge;//边数
    static int[] path;
    static int dist[];
    static int flag;
    static HashSet<Integer> set = new HashSet<>();//判断是否被收录

    //初始化
    public static void creat() {
        for (int i = 1; i < node; i++) {
            dist[i] = 1000;
            path[i] = -1;
        }
        dist[flag] = 0;
        graph[1][2] = 2;
        graph[1][4] = 1;
        graph[2][4] = 3;
        graph[2][5] = 10;
        graph[3][1] = 4;
        graph[3][6] = 5;
        graph[4][3] = 2;
        graph[4][6] = 8;
        graph[4][7] = 4;
        graph[4][5] = 2;
        graph[5][7] = 6;
        graph[6][7] = 1;
    }

    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        System.out.println("输入结点和边");
        node = in.nextInt();
        edge = in.nextInt();
        graph = new int[node][node];
        path = new int[node];
        dist = new int[node];
        flag = 1;
        creat();
        Dijkstra();
        printpath();
    }

    //具体算法
    public static void Dijkstra() {
        while (true) {
            int v = -1;
            int min = 100000;
            //对于没有被收录进去的结点，找出dist最小的
            for (int i = 1; i < node; i++) {
                if (set.contains(i) == false) {
                    if (dist[i] < min) {
                        min = dist[i];
                        v = i;
                    }
                }
            }

            //已经全部收录了
            if (min == 100000) break;
            set.add(v);
            for (int i = 1; i < node; i++) {
                if (graph[v][i] > 0 && set.contains(i) == false) {
                    if (dist[v] + graph[v][i] < dist[i]) {
                        dist[i] = dist[v] + graph[v][i];
                        path[i] = v;
                    }
                }
            }
        }
    }

    public static void printpath() {
        Scanner in = new Scanner(System.in);
        Stack<Integer> queue = new Stack<>();
        while (true) {
            System.out.println("输入结点");
            int n;
            n = in.nextInt();
            System.out.println("最短路径为" + dist[n]);
            while (n != -1) {
                queue.add(n);
                n = path[n];
            }
            while (!queue.isEmpty()) {
                System.out.print(queue.pop() + " ");
            }
        }
    }
}
```



### 2、floyd算法

递归打印路径

```java
class floyd {
    static int [][]graph;
    static int node;
    static int edge;
    static int[][]path;

    public static void insert(){
        for(int i=1;i<node;i++){
            for(int j=1;j<node;j++){
                graph[i][j]=1000;
                path[i][j]=-1;
            }
        }
        graph[1][2]=2;
        graph[1][4]=1;
        graph[2][4]=3;
        graph[2][5]=10;
        graph[3][1]=4;
        graph[3][6]=5;
        graph[4][3]=2;
        graph[4][6]=8;
        graph[4][7]=4;
        graph[4][5]=2;
        graph[5][7]=6;
        graph[7][6]=1;
    }

    public static void printpath(){
        Scanner in=new Scanner(System.in);
        while(true){
            System.out.println("输入两个结点");
            int n1= in.nextInt();
            int n2= in.nextInt();
            if(graph[n1][n2]==1000) System.out.println("两点之间无通路");
            else{
                System.out.println("路径长度为"+graph[n1][n2]);
                System.out.print("最短路径为："+n1+" ");
                dfs(n1,n2);
                System.out.print(n2);
            }
        }
    }
    public static void dfs(int i,int j){
        if(path[i][j]>=0){
            dfs(i,path[i][j]);
            System.out.print(path[i][j]+" ");
            dfs(path[i][j],j);
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        System.out.println("输入定点和边");
        node= in.nextInt();
        edge= in.nextInt();
        graph=new int[node][node];
        path=new int[node][node];
        insert();
        flyed();
        printpath();
    }

    //具体算法floyed
    public static void flyed(){
        for(int k=1;k<node;k++){
            for(int i=1;i<node;i++){
                for(int j=1;j<node;j++){
                    if(graph[i][k]+graph[k][j]<graph[i][j]){
                        graph[i][j]=graph[i][k]+graph[k][j];
                        path[i][j]=k;
                    }
                }
            }
        }
    }
}
```

### **3、最小生成树**

```java
public class prime {
    //prime求最小生成树
    static int [][]graph;//图本身
    static int [][]tree;//最小生成树
    static int node;//结点数
    static int edge;//边数
    static boolean []vist;
    static boolean[]flag;
    static int start=4;
    //图的初始化
    public static void creat(){
        graph=new int[node+1][node+1];
        tree=new int[node+1][node+1];
        vist=new boolean[node+1];
        flag=new boolean[node+1];
        //图初始化为-1，表示两个结点之间没有联通
        for(int i=1;i<=node;i++){
            for(int j=1;j<=node;j++){
                graph[i][j]=-1;
                tree[i][j]=-1;
            }
        }
       graph[1][2]=graph[2][1]=2;
       graph[1][3]=graph[3][1]=4;
       graph[1][4]=graph[4][1]=1;
       graph[2][4]=graph[4][2]=3;
       graph[2][5]=graph[5][2]=10;
       graph[3][6]=graph[6][3]=5;
       graph[3][4]=graph[4][3]=2;
       graph[4][5]=graph[5][4]=7;
       graph[5][7]=graph[7][5]=6;
       graph[4][6]=graph[6][4]=8;
       graph[4][7]=graph[7][4]=4;
       graph[6][7]=graph[7][6]=1;
    }
    public static void MakeTree(){
        int sum=0;
        int h1=-1;
        int h2=-1;
        int min=100000;
        vist[start]=true;
        for(int k=1;k<node;k++){
            min=100000;
            for(int i=1;i<=node;i++){
                for(int j=1;j<=node;j++){
                    if(vist[i]==false)break;
                    else {
                        if(vist[j]==false&&graph[i][j]>0){
                           if(min>graph[i][j]){
                               h1=i;
                               h2=j;
                               min=graph[i][j];
                           }
                        }
                    }
                }
            }
            sum=sum+graph[h1][h2];
            System.out.println("收录定点为<"+h1+","+h2+">"+"权重"+graph[h1][h2]);
            tree[h1][h2]=graph[h1][h2];
            vist[h2]=true;
        }
        System.out.println("总权等于:"+sum);
    }
    public static void dfs(int v){
        Queue <Integer>queue=new LinkedList<>();
        queue.add(v);
        while(!queue.isEmpty()){
            v=queue.poll();
            System.out.println(v);
            for(int i=1;i<=node;i++){
                if(tree[v][i]>0&&flag[i]==false){
                    flag[i]=true;
                    queue.add(i);
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        System.out.println("输入结点数和边数");
        node= 7;
        edge= 12;
        creat();
        MakeTree();
        //遍历树
        dfs(start);
    }
}
```



并查集加最小堆

```java
public class Kruskal {
    static int[][]graph;
    static  int[][]tree;
    static  int node;
    static  int edge;
    static boolean[]flag;
    static int start=1;
    //把边加入里面，按从小到大排序
    static List<Edge> list=new ArrayList<>();
    //并查集
    static int[]num;
    //并查集主体
     static HashMap<Integer,Integer>map=new HashMap<>();
    //初始化
    public static void creat(){
        graph=new int[node+1][node+1];
        tree=new int[node+1][node+1];
        flag=new boolean[node+1];
        //图初始化为-1，表示两个结点之间没有联通
        for(int i=1;i<=node;i++){
            for(int j=1;j<=node;j++){
                graph[i][j]=-1;
                tree[i][j]=-1;
            }
        }
        graph[1][2]=graph[2][1]=2;
        graph[1][3]=graph[3][1]=4;
        graph[1][4]=graph[4][1]=1;
        graph[2][4]=graph[4][2]=3;
        graph[2][5]=graph[5][2]=10;
        graph[3][6]=graph[6][3]=5;
        graph[3][4]=graph[4][3]=2;
        graph[4][5]=graph[5][4]=7;
        graph[5][7]=graph[7][5]=6;
        graph[4][6]=graph[6][4]=8;
        graph[4][7]=graph[7][4]=4;
        graph[6][7]=graph[7][6]=1;
        //把边加入集合
        for(int i=1;i<=node;i++){
            map.put(i,i);
            for(int j=1;j<=node;j++){
                if(graph[i][j]>0&&i<=j){
                    list.add(new Edge(i,j,graph[i][j]));
                }
            }
        }
        Collections.sort(list);
        //验证
       for(Edge k:list){
           System.out.println(k);
       }
        System.out.println(map);
    }
    public static void main(String[] args) {
        node= 7;
        edge= 12;
        creat();
        num=new int[node+1];
        Kruskal();
        dfs(start);
    }
    //算法本身
    public static void Kruskal(){
        int n=list.size();
        for(int i=0;i<n;i++){
            Edge p=list.get(0);
            list.remove(0);
            int k1=p.start;
            int k2=p.end;
            int weight=p.weight;
            //寻找根
            int root1=root(k1);
            int root2=root(k2);

            if(root1==root2)continue;
            else {
                map.put(root1,root2);
                tree[k1][k2]=tree[k2][k1]=weight;
            }
        }
    }
    //并查集
    public static int root(int i){
        while(map.get(i)!=i){
            i=map.get(i);
        }
        return i;
    }
    public static void dfs(int v){
        Queue<Integer> queue=new LinkedList<>();
        queue.add(v);
        flag[v]=true;
        while(!queue.isEmpty()){
            v=queue.poll();
           System.out.println(v);
            for(int i=1;i<=node;i++){
                if(tree[v][i]>0&&flag[i]==false){
                    flag[i]=true;
                    queue.add(i);
                }
            }
        }
    }
}
//记录两点的边
class Edge implements Comparable<Edge>{
    public int start;
    public int end;
    public int weight;

    public Edge(int start, int end, int weight) {
        this.start = start;
        this.end = end;
       this.weight=weight;
    }

    @Override
    public String toString() {
       return start+"->"+end+",权重是"+weight;
    }

    //按权重大小排序
    @Override
    public int compareTo(Edge o) {
        return Double.compare(this.weight,o.weight);
    }
}
```



### **4、哈夫曼树**

每次选出最小的连个值，加起来生成新的结点，加入到集合中，重复操作，运用到最小堆

```java
public class huffmantree {
    //返回哈夫曼树
    public static Node1 creathuffmantree(int []a) {
        //将每个元素转换为Node然后放到集合中
        List<Node1> list = new ArrayList<>();
        for (int k : a) {
            list.add(new Node1(k));
        }
        while (list.size() > 1) {
            //从小到大排序
            Collections.sort(list);
            //取出权值最小的两颗二叉树,构建新的二叉树
            Node1 leftNode = list.get(0);
            Node1 rightNode = list.get(1);
            Node1 parent = new Node1(leftNode.value + rightNode.value);
            parent.left = leftNode;
            parent.right = rightNode;
            //删除掉两个最小结点
            list.remove(0);
            list.remove(0);
            list.add(parent);
        }
        return list.get(0);
    }
    //哈夫曼树
    public static void main(String[] args) {
        int []a={13,7,8,3,29,6,1};
        //得到哈夫曼树的头结点
        Node1 head=creathuffmantree(a);
        Node1 p=new Node1();
        p.pre(head);
    }
}
//创建结点
//让Node支持排序,实现comparable接口
class Node1 implements Comparable<Node1>{
    int value;//结点的权值
    Node1 left=null;
    Node1 right=null;

    public Node1(){

    }
    public Node1(int value){
        this.value=value;
    }

    @Override
    public String toString() {
        return "Node{" +
                "value=" + value +
                '}';
    }


    @Override
    public int compareTo(Node1 o) {
        return Double.compare(this.value,o.value);
    }
    public void pre(Node1 head){
        if(head==null)return;
        System.out.println(head);
        pre(head.left);
        pre(head.right);
    }
}
```

​	

## 八、双指针	

一般先找出暴力做法，然后优化，具体题目不同，可以看错题集



## 九、合并区间









## 十、定制排序(重要)

定制排序如果多个参数，比较的时候要多次比较，比如这个参数不想等，返回另一个参数

### 1、TreeSet

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724171353.png)

```java
class FoodRatings {
    HashMap<String,count>map1=new HashMap<>();///对象名加类
    HashMap<String, TreeSet<count>>map2=new HashMap<>();//烹饪方式加类
    public FoodRatings(String[] foods, String[] cuisines, int[] ratings) {
        for(int i=0;i<foods.length;i++){
            String s=foods[i];
            String s2=cuisines[i];
            int score=ratings[i];
            count p=new count(s,score,s2);
            map1.put(s,p);
            if(map2.get(s2)==null){
                TreeSet<count>set=new TreeSet<>();
                set.add(p);
                map2.put(s,set);
            }else {
                map2.get(s2).add(p);
            }
        }
    }

    public void changeRating(String food, int newRating) {
         count p=map1.get(food);
         String s=p.cuisinesname;
         map2.get(s).remove(p);
         p.score=newRating;
         map2.get(s).add(p);

    }

    public String highestRated(String cuisine) {
         return map2.get(cuisine).last().cuisinesname;
    }
}
class count implements Comparable<count> {
    public String foodname;
    public int score;
    public String cuisinesname;

    public count(String foodname, int score, String cuisinesname) {
        this.foodname = foodname;
        this.score = score;
        this.cuisinesname = cuisinesname;
    }

    public void setFoodname(String foodname) {
        this.foodname = foodname;
    }

    public void setScore(int score) {
        this.score = score;
    }

    public void setCuisinesname(String cuisinesname) {
        this.cuisinesname = cuisinesname;
    }

    public String getFoodname() {
        return foodname;
    }

    public int getScore() {
        return score;
    }

    public String getCuisinesname() {
        return cuisinesname;
    }


    @Override
    public int compareTo(count o) {
        if(this.score!=o.score)return Integer.compare(this.score,o.score);
        return -this.foodname.compareTo(o.foodname);
    }
}
```





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724171542.png)

```java
class NumberContainers {
    HashMap<Integer,Integer>map1;
    HashMap<Integer,TreeSet<Integer>>map2;
    public NumberContainers() {
        map1=new HashMap<>();
        map2=new HashMap<>();
    }
    public void change(int index, int number) {
        if(map1.get(index)==null){
            map1.put(index,number);
        }else{
            //System.out.println(map1.get(index));
            TreeSet<Integer>set=map2.get(map1.get(index));
            set.remove(index);
            map1.put(index,number);
        }
        if(map2.get(number)==null){
            TreeSet set1=new TreeSet<>();
            set1.add(index);
            map2.put(number,set1);
        }else {
            map2.get(number).add(index);
        }
    }

    public int find(int number) {
        if(map2.get(number)==null||map2.get(number).size()==0)return-1;
        return map2.get(number).first();
    }
}
```



## 十一、并查集

### 1、简介：

简单思路就是把相关的边全部放到一起，两个方法，一个找出根，这里用路径压缩，减少查询次数，还有一个方法是联通，如果根不同，直接联通。这里不用判断哪个根链接哪个，除非特殊情况。

### 2、无法达到的点数

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220724195813.png)

把所有元素并查集串起来，查找根的时候可以用路径压缩，然后遍历的时候用Map可以降低时间复杂度。同时这题可以用dfs做

```java
class Solution {
    public long countPairs(int n, int[][] edges) {
        int []parent=new int[n];
        for(int i=0;i<n;i++){
            parent[i]=i;
        }
        for(int i=0;i<edges.length;i++){
            merge(edges[i][0],edges[i][1],parent);
        }
        long sum=0;
        HashMap<Integer,Integer>map=new HashMap<>();
        for(int i=0;i<n;i++){
            int root=findroot(i,parent);
            if(map.get(root)==null)map.put(root,1);
            else map.put(root,map.get(root)+1);
        }
        for(int k:map.keySet()){
            long count=map.get(k);
            sum+=(n-count)*count;
        }
        return sum/2;
    }
    public void merge(int a,int b,int []parent){
        int k1=findroot(a,parent);
        int k2=findroot(b,parent);
        if(a==b)return;
        parent[k1]=k2;
    }
    //路径压缩
    public int findroot(int a,int []parent){
        if(parent[a]!=a)parent[a]=findroot(parent[a],parent);
        return parent[a];
    }
}
```



### 3、联通数(难)

![](C:\Users\waili\Desktop\usual\微信截图\错题力扣\微信截图_20220730003126.png)

```java
class Solution {
    int[]parent;
    public int largestComponentSize(int[] nums) {
        int n=0;
        for(int i=0;i<nums.length;i++){
            n=Math.max(n,nums[i]);
        }
        parent=new int[n+1];
        for(int i=0;i<=n;i++){
            parent[i]=i;
        }
        for(int i=0;i<nums.length;i++){
            int k=nums[i];
            for(int j=2;j*j<=k;j++){
                if(k%j==0){
                    union(j,k);
                    union(j,k/j);
                }
            }
        }
        int max=0;
        int []count=new int[n+1];
        for(int i=0;i<nums.length;i++){
            int root=findroot(nums[i]);
            count[root]++;
            max=Math.max(max,count[root]);
        }
        return max;
    }

    //联通
    public void union(int root1,int root2){
        int k1=findroot(root1);
        int k2=findroot(root2);
        if(k1==k2)return;
        if(k1<k2)
            parent[k1]=k2;
        else parent[k2]=k1;
    }

    //寻找跟，路径压缩
    public int findroot(int x){
        if(parent[x]!=x){
            parent[x]=findroot(parent[x]);
        }
        return parent[x];
    }
}
```



## 十二、拓扑排序

### 1、简介

首先给点一个图，找出图中每个点遍历顺序，比如课程表顺序，可以用到拓扑排序

先计算出每个点的入度，然后用一个队列把入党为零的点收入队列。

开始遍历，每次弹出，把所有和这个弹出点相连的点度数减去一，如果度数为零，就入队列。

队列里面的顺序就拓扑排序的顺序



## 十三、链表

### 1、数组模拟链表

节省空间

单链表操作

一般用两个数组，一个存值，一个存下一个结点的指针

```java
import java.util.*;
public class Main{
    static int []val=new int[100010];
    static int []next=new int[100010];
    static int index=0;
    static int head=-1;//头结点
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        //指针和链表的值
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String c=in.next();
            if(c.equals("H")){
                int k=in.nextInt();
                inserthead(k);
            }else if(c.equals("D")){
                int k=in.nextInt();
                if(k==0)head=next[head];
                else delect(k-1);
            }else {
                int k=in.nextInt();
                int x=in.nextInt();
                insertk(k-1,x);
            }
        }
        int sum=0;
        for(int i=head;i!=-1;i=next[i]){
            System.out.print(val[i]+" ");
            sum++;
        }

    }
    //从头节点插入
    public static void inserthead(int a){
        val[index]=a;
        next[index]=head;
        head=index;
        index++;
    }
    //第k个插入的结点后加入一个数
    public static void insertk(int k,int x){
        val[index]=x;
        next[index]=next[k];
        next[k]=index;
        index++;
    }
    //删除第K个结点后一个数
    public static void delect(int k){
        next[k]=next[next[k]];
    }
}
```





### 2、双向链表

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730011147.png" style="zoom:67%;" />



这里双向链表有点特殊，我们先指定0号位是头节点，1号位是尾巴结点，0的next指向1，1的pre指向0

然后插入统一用一个方法就是add

最左端插入就是0号位右边插入

最右边插入就是尾结点左边结点的右边插入

第k个结点后插入也一样

```java


import java.util.*;
public class Main{
    static int []next=new int[100010];
    static int []pre=new int[100010];
    static int []val=new int[100010];
    //确定终点和起点

static int index=2;

 public static void main(String[]args){
     next[0]=1;
     pre[1]=0;
    Scanner in=new Scanner(System.in);
     int n=in.nextInt();
     for(int i=0;i<n;i++){
         String s=in.next();
         if(s.equals("L"))add(0,in.nextInt());
         else if(s.equals("R"))add(pre[1],in.nextInt());
         else if(s.equals("D"))delect(in.nextInt()+1);
         else if(s.equals("IL"))add(pre[in.nextInt()+1],in.nextInt());
         else {
             add(in.nextInt()+1,in.nextInt());
         }
     }
     for(int i=next[0];i!=1;i=next[i]){
         System.out.print(val[i]+" ");
     }
     
 }
 public static void add(int k,int x){
     val[index]=x;
     next[index]=next[k];
     pre[next[k]]=index;
     pre[index]=k;
     next[k]=index;
     index++;
 } 
 public static void delect(int k){
     next[pre[k]]=next[k];
     pre[next[k]]=pre[k];
 }
```

}

## **十四、队列和堆栈应用**

### 1、单调栈

一般只有一个用法

就是求数组中每个数左边第一个比他小的数，如果没有输出-1

思路就是堆栈里面的元素大于0，并且堆栈顶部大于当前数，就抛出堆栈，到最后如果堆栈为空，输出-1，否则输出堆栈顶部元素

最后把这个数加入堆栈

```java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int []a=new int[n];
        for(int i=0;i<n;i++){
            a[i]=in.nextInt();
        }
        Stack<Integer>stack=new Stack<>();
        for(int i=0;i<n;i++){
            while(stack.size()>0&&stack.peek()>=a[i])stack.pop();
            if(stack.size()>0)System.out.print(stack.peek()+" ");
            else System.out.print(-1+" ");
            stack.push(a[i]);
        }
    }
}
```



### 2、单调队列

一般是求滑动窗口的最大值

看错题集



### 3、数组模拟堆栈

简单



### **4、数组模拟队列(可循环)**

```java
public class stack2 {
    //队列的最大值
    static int max;
    static int popindex;
    static  int pushindex;
    static  int size;
    static int[]queue;

    public static  void pop(){
        if(size==0) System.out.println("队列为空");
        else {
            int k=queue[popindex];
            size--;
            popindex=index(popindex);
            System.out.println(k);
        }
    }

    public static void push(int value){
       if(size>=max) System.out.println("已经满了");
       else {
           queue[pushindex]=value;
           size++;
           pushindex=index(pushindex);
       }
    }

    //返回两个指针下一个位置
    public  static int index(int index){
        if(index+1<max)return index+1;
        return 0;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        queue=new int[5];
        max=5;
        size=0;
        popindex=0;
        pushindex=0;
        while(true){
            System.out.println("输入你的选择:1-push,2-pop,3-break");
            int choice=in.nextInt();
            switch (choice){
                case 1:
                    System.out.println("输入要push的数字");
                    push(in.nextInt());
                    break;
                case 2:pop();
                    break;
                case 3:return;
            }
        }
    }
}
```



### **5、最小栈**

看错题集

有两种思路

先准备两个堆栈

第一种：每次压入堆栈一，看看它和堆栈2顶部哪一个大，把大的压入堆栈2，每次Pop的时候两个堆栈都要弹出来

第二种：每次将一个数压入堆栈一，如果他小于等于堆栈2的顶部元素，入堆栈，pop的时候如果堆栈一和堆栈二的元素一样，两个一起Pop,否则值pop堆栈1



### 6、队列实现堆栈

看数据结构集



### 7、堆栈实现队列

数据结构集



## **十五 KMP(没搞懂)**





## 十六、字典树

### 1、简介

字典树可以直接查找一个字符串出现了多少次，效率很高，用树来实现

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220730020051.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220731014313.png)

```java
import java.util.*;
public class Main{
    //第几个位置有几个儿子节点
    static int[][]root=new int[100010][26];
    //统计字符串的数量
    static int[]sum=new int[100010];
    static int  index=0;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String s=in.next();
            if(s.equals("I")){
                insert(in.next());
            }else{
                String str=in.next();
                quary(str);
            }
        }
    }

    public static void quary(String s){
        int q=0;
        for(int i=0;i<s.length();i++){
            int k=s.charAt(i)-'a';
            if(root[q][k]==0){
                System.out.println(0);
                return;
            }
            q=root[q][k];
        }
        System.out.println(sum[q]);
    }

    //插入
    public static void insert(String s){
        int q=0;
        for(int i=0;i<s.length();i++){
            int k=s.charAt(i)-'a';
            if(root[q][k]==0)root[q][k]=++index;
            q=root[q][k];
        }
        sum[q]++;
    }
}
```



## 十七、注意事项

### 1、输入结束

有些题目输入没有结束标志，要用以下格式来结束输入

```java
import java.util.*;
public class Main{
    public static  void main(String[]args){
        Scanner in=new Scanner(System.in);
        //判断闰年的标志
        List<Integer>list=new ArrayList<>();
        while(in.hasNext()){
            int y=in.nextInt();
            int m=in.nextInt();
            int d=in.nextInt();
            int falg=0;
            if(y%4==0&&y%100!=0||y%400==0)falg=1;
            HashMap<Integer,Integer>map=new HashMap<>();
            map.put(1,31);
            map.put(3,31);
            map.put(4,30);
            map.put(5,31);
            map.put(6,30);
            map.put(7,31);
            map.put(8,31);
            map.put(9,30);
            map.put(10,31);
            map.put(11,30);
            map.put(12,31);
            if(falg==1)map.put(2,29);
            else map.put(2,28);
            int k =m-1;
            int sum=0;
            for(int i=1;i<=k;i++){
                sum+=map.get(i);
            }
            sum+=d;
            list.add(sum);


        }
        for(int k:list){
            System.out.println(k);
        }
    }
}
```





## 十八、堆

看数据结构

### 1、系统堆

默认小根堆，然后定制排序变成大根堆

```java
class heap3{
    static class mycon implements Comparator<Integer>{

        @Override
        public int compare(Integer o1, Integer o2) {
            return o2-o1;
        }
    }
    public static void main(String[] args) {
        PriorityQueue<Integer>queue=new PriorityQueue<>(new mycon());
        queue.add(1);
        queue.add(-3);
        queue.add(20);
        queue.add(24);
        System.out.println(queue.poll());
    }
}
```

### 2、比较器(定制排序）

![微信截图_20220815202251](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815202251.png)



### 3、前k个排序

思路：

把前k个数放入小根堆，然后弹出放入下标为Index的位置，index++,然后让k+1个数加入堆，然后重复操作

![微信截图_20220815194017](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815194017.png)

![微信截图_20220815195046](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815195046.png)

## 十九、大数问题

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220807043226.png)

```java
import java.math.BigInteger;
        import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        String s1=in.next();
        String s2=in.next();
        BigInteger a=new BigInteger(s1);
        BigInteger b=new BigInteger(s2);
        var c=a.add(b);
        System.out.println(c);
    }
}
```







## 二十、哈希

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220814153841.png)

### 1、模拟哈希

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815142757.png)

开放寻址法

数组开两倍长，然后每个位置填充要插入数范围外的数字，这里取100000001.然后传过来一个数，我们要用取模法判断要放到数组的下标，因为数组保证下标为正，所以要两次取模，如果数组中这个数不等于flag并且不等于传进来的数，k++,记住如果k等于数组长度，进行一个循环，k变成0

```java
import java.util.*;
public class Main{
    static int[]d;
    static int flag;
    static int n=200003;

    static int find(int x){
        int k=(x%n+n)%n;
        while(d[k]!=flag&&d[k]!=x){
            k++;
            if(k==n)k=0;
        }
        return k;
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        d=new int[200000];
        flag=100000001;
        for(int i=0;i<200003;i++){
            d[i]=flag;
        }
        int n=in.nextInt();
        for(int i=0;i<n;i++){
            String s=in.next();
            int x=in.nextInt();
            int k=find(x);
            if(s.equals("I")){
                d[k]=x;
            }else {
                if(d[k]!=flag)System.out.println("Yes");
                else System.out.println("No");
            }
        }
    }
}
```





2、拉链法

就是数组加链表

```java
import java.util.*;
public class  Main{
    static int []d;
    static int []e;
    static int[]ne;
    static int flag=100003;
    static int index=0;

    static void insert(int x){
        int k=(x%flag+flag)%flag;
        e[index]=x;
        ne[index]=d[k];
        d[k]=index;
        index++;
    }

    static boolean quary(int x){
        int k=(x%flag+flag)%flag;
        for(int i=d[k];i!=-1;i=ne[i]){
            if(e[i]==x)return true;
        }
        return false;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        d=new int[100003];
        e=new int[100003];
        ne=new int[100003];
        for(int i=0;i<100003;i++){
            d[i]=-1;
        }
        for(int i=0;i<n;i++){
            String c=in.next();
            int x=in.nextInt();
            if(c.equals("I"))insert(x);
            else {
                var a=quary(x);
                if(a==true)System.out.println("Yes");
                else System.out.println("No");
            }
        }
    }
}
```



### 2、字符串哈希

含义：我们把一串字符串预处理，这样子处理子串的时候很容易计算出他们的哈希值了，方便字符串的比较

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220814172654.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220815143932.png)

```java
import java.util.*;
public class Main{
    static long []h;
    //计算p的多少次方等于多少
    static long []p;
    static long Q=(long)Math.pow(2,64);
    static long P=131;

    static long count(int l,int r){
        return h[r]-h[l-1]*p[r-l+1];
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        p=new long[n+1];
        h=new long[n+1];
        String s=in.next();
        p[0]=1;
        for(int i=1;i<=n;i++){
            p[i]=p[i-1]*P;
            h[i]=(h[i-1]*P+s.charAt(i-1))%Q;
        }
        for(int i=0;i<m;i++){
            int l1=in.nextInt();
            int r1=in.nextInt();
            int l2=in.nextInt();
            int r2=in.nextInt();
            if(count(l1,r1)==count(l2,r2))System.out.println("Yes");
            else System.out.println("No");
        }
    }
}
```







## 二十一、搜索和图论(邻接矩阵来表示）

### 1、dfs

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818152430.png)



```java
import java.util.*;
public class Main{
    static int []num;
    static int []vist;
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        num=new int[n+1];
        vist=new int[n+1];
        dfs(1);
    }
    public static void dfs(int n){
        if(n==num.length){
            for(int i=1;i<num.length;i++){
                System.out.print(num[i]+" ");
            }
            System.out.println();
            return;
        }

        for(int i=1;i<num.length;i++){
            if(vist[i]==0){
                vist[i]=1;
                num[n]=i;
                dfs(n+1);
                vist[i]=0;
            }
        }
    }

}
```



### 2、n皇后

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818154922.png)

```java
import java.util.*;
public class Main{
    static char[][]num;
    //分别存放列，两个对角线
    static HashSet<Integer>set1=new HashSet<>();
    static HashSet<Integer>set2=new HashSet<>();
    static HashSet<Integer>set3=new HashSet<>();
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        num=new char[n][n];
        //初始化
        for(int i=0;i<n;i++){
            for(int j=0;j<n;j++){
                num[i][j]='.';
            }
        }
        dfs(0);
    }

    public static void dfs(int n){
        if(n==num.length){
            for(int i=0;i<n;i++){
                for(int j=0;j<n;j++){
                    System.out.print(num[i][j]);
                }
                System.out.println();
            }
            System.out.println();
            return;
        }
        for(int i=0;i<num.length;i++){
            if(set1.contains(i)==false&&set2.contains(n+i)==false&&set3.contains(n-i)==false){
                set1.add(i);
                set2.add(n+i);
                set3.add(n-i);
                num[n][i]='Q';
                dfs(n+1);
                set1.remove(i);
                set2.remove(n+i);
                set3.remove(n-i);
                num[n][i]='.';
            }
        }
    }
}
```



### 3、bfs(最短路)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220818164017.png)

```Java
import java.util.*;
public class Main{
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        int [][]num=new int[n+1][m+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=m;j++){
                num[i][j]=in.nextInt();
            }
        }
        Queue<int[]>queue=new LinkedList<>();
        queue.add(new int[]{1,1});
        int [][]vist=new int[n+1][m+1];
        int sum=0;
        int []d1={1,0,0,-1};
        int []d2={0,1,-1,0};
        int count=0;
        vist[1][1]=1;
        while(queue.size()>0){
            sum++;
            int size=queue.size();
            while(size>0){
                size--;
                int[]a=queue.poll();
                int x=a[0];
                int y=a[1];
                //System.out.println(x+" "+y+" "+sum);
                int k1=0;
                int k2=0;
                for(int i=0;i<4;i++){
                    k1=x+d1[i];
                    k2=y+d2[i];
                    if(k1>=1&&k2>=1&&k1<=n&&k2<=m&&num[k1][k2]==0&&vist[k1][k2]==0){
                        if(k1==n&&k2==m){
                            count=sum;
                        }
                        vist[k1][k2]=1;
                        queue.add(new int[]{k1,k2});
                    }
                }
            }
        }
        System.out.println(count);
    }
}
```



### **4、图和的表示用邻接表，链表用数组来模拟**

图除了二维数组 

  还可以用邻接表  体现在每一个节点下面又一个链表  表示这个节点到链表中的每个数都有边

g初始化为 -1

```cpp
int e[N],ne[N],g[N];
    int idx;
    void creat(int a,int b){
    e[idx] = b;
    ne[idx] = g[a];
    g[a] = idx++;
    }
```





查找一个节点和和哪些结点相连

```cpp
for(int i = g[u] ; i != -1 ;i=ne[i]){
        int j = e[i];
}
```







树的中心

这里用递归，dfs遍历，从1也就是顶部开始，算出以当前结点的子树的结点数，加上1就是以当前结点为根的树的结点总数，剩下联通区域结点数就是n-1,同时可以算出，同时可以递归的算出子结点的最大结点数，然后比较。

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220819022927.png)

```java
import java.util.*;
public class Main{
    static int []tree;
    static int []value;
    static int []next;
    static int min;
    static int index;
    static int []vist;
    static int n;
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }

    public static int dfs(int x){
        vist[x]=1;
        int sum=1;
        int res=0;
        for(int i=tree[x];i!=-1;i=next[i]){
            int j=value[i];
            if(vist[j]==0){
                vist[j]=1;
                int s=dfs(j);
                res=Math.max(res,s);
                sum=sum+s;
            }
        }
        res=Math.max(res,n-sum);
        min=Math.min(min,res);
        return sum;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int count=in.nextInt();
        n=count;
        tree=new int[100010];
        vist=new int[100010];
        min=n;
        index=1;
        value=new int[200010];
        next=new int[200010];
        for(int i=1;i<100010;i++){
            tree[i]=-1;
        }
        for(int i=0;i<n-1;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
            insert(b,a);
        }
        dfs(1);
        System.out.println(min);
    }
}
```



### 5、拓扑排序

分别用邻接表和哈希表来模拟图，数组空间太大，不推荐

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820165148.png)

```java
import java.util.*;
public class Main{
    static int[]tree=new int[200000];
    static int []v=new int[200000];
    static int []ne=new int[200000];
    static List<Integer>list=new ArrayList<>();
    static Queue<Integer>queue=new LinkedList<>();
    static int[]d;
    static int index;


    //图的建立
    public  static void insert(int a,int b){
        d[b]++;
        v[index]=b;
        ne[index]=tree[a];
        tree[a]=index++;
    }

    public static boolean topo(int n){
        for(int i=1;i<=n;i++){
            if(d[i]==0)queue.add(i);
        }
        while(queue.size()>0){
            int k=queue.poll();
            list.add(k);
            for(int i=tree[k];i!=-1;i=ne[i]){
                //System.out.println(i);
                int j=v[i];
                d[j]--;
                if(d[j]==0)queue.add(j);
            }
        }
        if(list.size()==n)return true;
        return false;
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        index=0;
        d=new int[n+1];
        for(int i=1;i<200000;i++)tree[i]=-1;
        for(int i=0;i<m;i++){
            insert(in.nextInt(),in.nextInt());
        }
        boolean  a=topo(n);
        if(a==true){
            for(int k:list){
                System.out.print(k+" ");
            }
        }
        else System.out.println(-1);
    }

}
```





```java
 class Main{

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
       HashMap<Integer,List<Integer>>map=new HashMap<>();
       List<Integer>list=new ArrayList<>();
       int n=in.nextInt();
       int m=in.nextInt();
       int[]d=new int[n+1];
       for(int i=0;i<m;i++){
           int k1=in.nextInt();
           int k2=in.nextInt();
           d[k2]++;
           if(map.get(k1)==null){
               List<Integer>help=new ArrayList<>();
               help.add(k2);
               map.put(k1,help);
           }else {
               map.get(k1).add(k2);
           }
       }
       Queue<Integer>queue=new LinkedList<>();
       for(int i=1;i<=n;i++){
           if(d[i]==0)queue.add(i);
       }
       while(queue.size()>0){
           int k=queue.poll();
           list.add(k);
           if(map.get(k)==null)continue;;
           List<Integer>list2=map.get(k);
           for(int w:list2){
               d[w]--;
               if(d[w]==0)queue.add(w);
           }
       }
       if(list.size()==n){
           for (int w:list){
               System.out.print(w+" ");
           }
       }else System.out.println(-1);
    }
}
```



### **最短路(非常重要)**



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220820183313.png)

### 6、单源无权

求一个点到终点的最短路，用bfs

输入，n,和m,表示点和边，存在自环，求1到n的最短路

bfs就行了

```java
import java.util.*;
public class Main{
    static int[]vist;
    static int[]dist;
    static int[]value;
    static int[]tree;
    static int[]next=new int[200000];
    static int index;
    static Queue<Integer>queue=new LinkedList<>();

    //图的建立
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=tree[a];
        tree[a]=index++;
    }

    public static void bfs(){
        while(queue.size()>0){
            int k=queue.poll();
            for(int i=tree[k];i!=-1;i=next[i]){
                int j=value[i];
                if(vist[j]==0){
                    vist[j]=1;
                    dist[j]=dist[k]+1;
                    queue.add(j);
                }
            }
        }
    }
    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        index=0;
        value=new int[200000];
        vist=new int[n+1];
        dist=new int[n+1];
        tree=new int[n+1];
        for(int i=0;i<=n;i++)tree[i]=-1;
        dist[1]=0;
        queue.add(1);
        vist[1]=1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
        }
        bfs();
        if(vist[n]==0)System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```





### 7、Dijkstra(朴素版)

适合边多的图，用数组模拟

思路：每次从没有被访问过的点找出到目标点距离距离最小的点，然后标记为访问，找出他的所有邻接点，然后在更新距离

注意：所有点距离和图的权都为正无穷，初始距离为0

```java
import java.util.*;
public class Main{
    public  static  int[][]graph;
    public  static  int[]visit;
    public  static  int[]dist;
    static  int n;

    //构建图
    public  static void insert(int a,int b,int c){
        graph[a][b]=Math.min(graph[a][b],c);
    }

    //初始化
    public  static  void start(){
        for(int i=1;i<=n;i++){
            dist[i]=10000000;
            for(int j=1;j<=n;j++){
                graph[i][j]=graph[j][i]=10000000;
            }
        }
    }

    public  static  void  dijkstra(){
        for(int i=0;i<n;i++){
            int t=-1;
            for(int j=1;j<=n;j++){
                if(visit[j]==0&&(t==-1||dist[j]<dist[t])){
                    t=j;
                }
            }
            if(t==-1)break;
            // System.out.println(t+" "+dist[t]);
            visit[t]=1;
            for(int w=1;w<=n;w++){
                if(visit[w]==0){
                    dist[w]=Math.min(dist[w],dist[t]+graph[t][w]);
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1][n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        dijkstra();
        if(dist[n]==10000000) System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```



### 8、堆优化

适合稀疏图

用临接表表示图

堆来优化

这里用系统堆

```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];//值
    public  static  int[]next=new int[200000];//下一个指针
    public  static  int[]weight=new int[200000];//权重
    public  static  int index=0;
    static  int n;
    static int max=1000000000;
    //堆
    public static PriorityQueue<int[]>heep=new PriorityQueue<>(new p());

    //定制排序
    static class p implements Comparator<int[]>{

        @Override
        public int compare(int[] o1, int[] o2) {
            return o1[1]-o2[1];
        }
    }

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }

    //初始化
    public  static  void start(){
        for(int i=0;i<graph.length;i++){
            if(i<dist.length)
                dist[i]=max;
            graph[i]=-1;
        }
    }

    public  static  void  dijkstra(){
        while(heep.size()>0){
            int []a=heep.poll();
            int v=a[0];
            int d=a[1];
            if(visit[v]==1)continue;
            visit[v]=1;
            for(int i=graph[v];i!=-1;i=next[i]){
                int j=value[i];
                int q=weight[i];
                if(dist[j]>d+q){
                    dist[j]=d+q;
                    heep.add(new int[]{j,d+q});
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        heep.add(new int[]{1,0});
        dijkstra();
        if(dist[n]==max) System.out.println(-1);
        else System.out.println(dist[n]);
    }
}
```



### 9、bellman-ford算法

可以处理负权图

这里直接把两个点和一个边以及权重储存在集合中

然后n个点，m条边

循环n次，然后每次把所有边取出来，更新端点的距离，记住要先复制，避免这次操作是基于上一次操作来的

特点:外层循环的意思就是经过第i+1条边，求目标点到各个点的最短路，这个方法可以来判断有没有环

下面是acwing一个题目，求经过k条边能否从1到n号点

```java
import java.util.*;
public class Main{
    static int n;
    static int []dist;
    //保存原数组，每次操作先拷贝一份
    static int[]pre;
    //把两个点和权重存进去
    static List<int[]>list=new ArrayList<>();
    static int max=1000000000;

    static  void start(){
        for(int i=1;i<dist.length;i++){
            dist[i]=max;
        }
        dist[1]=0;
    }

    static boolean bellman(int k){
        //将数组拷贝
        for(int i=0;i<k;i++){
            for(int j=1;j<=n;j++)pre[j]=dist[j];
            for(int j=0;j<list.size();j++){
                int[]num=list.get(j);
                int a=num[0];
                int b=num[1];
                int c=num[2];
                // System.out.println(a+" "+b+" "+c);
                dist[b]=Math.min(dist[b],pre[a]+c);
                //System.out.println(dist[b]);
            }
        }
        if(dist[n]>max/2)return false;
        return true;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m= in.nextInt();
        int k=in.nextInt();
        dist=new int[n+1];
        pre=new int[n+1];
        for(int i=0;i<m;i++){
            int a= in.nextInt();
            int b= in.nextInt();
            int q= in.nextInt();
            list.add(new int[]{a,b,q});
        }
        start();
        boolean a= bellman(k);
        if(a==false) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
}
```



### 10、spfa

不能有负环

对bellman-ford优化ellman_ford算法会遍历所有的边，但是有很多的边遍历了其实没有什么意义，我们只用遍历那些到源点距离变小的点所连接的边即可，只有当一个点的前驱结点更新了，该节点才会得到更新；因此考虑到这一点，我们将创建一个队列每一次加入距离被更新的结点。

用邻接表建图

然后其他和迪杰斯特拉优化一样

用一个队列，弹出一个点，并且这个点访问设为false,找出这个点的所有临接点，如果最短距离更新成功并且这个点不在队列中，加入队列，设为访问过

```java
 import java.util.*;
public class Main{
    public  static  int[]graph;
    public  static  int[]visit;
    public  static  int[]dist;//距离
    public  static  int[]value=new int[200000];//值
    public  static  int[]next=new int[200000];//下一个指针
    public  static  int[]weight=new int[200000];//权重
    public  static  int index=0;
    static  int n;
    static int max=1000000000;

    //构建图
    public  static void insert(int a,int b,int c){
        value[index]=b;
        next[index]=graph[a];
        weight[index]=c;
        graph[a]=index++;
    }

    //初始化
    public  static  void start(){
        for(int i=0;i<graph.length;i++){
            if(i<dist.length)
                dist[i]=max;
            graph[i]=-1;
        }
    }

    public  static  void  spfa(){
        Queue<Integer>queue=new LinkedList<>();
        queue.add(1);
        while(queue.size()>0){
            int k=queue.poll();
            visit[k]=0;
            for(int i=graph[k];i!=-1;i=next[i]){
                int j=value[i];
                if(dist[k]+weight[i]<dist[j]){
                    dist[j]=weight[i]+dist[k];
                    if(visit[j]==0){
                        //System.out.println(j+" "+dist[j]);
                        visit[j]=1;
                        queue.add(j);
                    }
                }
            }
        }
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        graph=new int[n+1];
        visit=new int[n+1];
        dist=new int[n+1];
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int c=in.nextInt();
            insert(a,b,c);
        }
        dist[1]=0;
        spfa();
        if(dist[n]==max) System.out.println("impossible");
        else System.out.println(dist[n]);
    }
}
```



### 11、floyd

先初始化距离为max,如果i=j距离为0

g(i)(j)=min(g(i)(j),g(i)(k)+g(k)(i))

```java
import java.util.*;
public class Main{
    static int n,m,q;
    static int[][]graph;
    static int max=1000000000;
    public static void floyd(){
        for(int k=1;k<=n;k++){
            for(int i=1;i<=n;i++){
                for(int j=1;j<=n;j++){
                    graph[i][j]=Math.min(graph[i][j],graph[i][k]+graph[k][j]);
                }
            }
        }
    }

    public static void main(String[]args){
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        m=in.nextInt();
        q=in.nextInt();
        graph=new int[n+1][n+1];
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(i==j)graph[i][j]=0;
                else
                    graph[i][j]=max;
            }
        }
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int q=in.nextInt();
            graph[a][b]=Math.min(graph[a][b],q);
        }
        floyd();

        for(int i=0;i<q;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            if(graph[a][b]>max/2)System.out.println("impossible");
            else System.out.println(graph[a][b]);
        }

    }
}
```



### 最小生成树

### 12、prime

思路就是先初始化图的距离为max,  每个点到生成树的距离为max

然后n论循环，每一次找出不在生成树中结点到生成树距离最小的点

然后加入生成树，再找出这个点的临接点并且不在生成树的点

更新其他点到生成树的距离

如果中间发现没有点到生成树，就不能生成最小生成树

```java
import java.util.*;
class  Main{
    static int [][]graph=new int[600][600];
    static  int[]dist=new int[600];
    static  int[]vist=new int[600];
    static  int max=100000000;
    static  int n;
    //初始化
    public  static  void start(){
        for(int i=0;i<=n;i++){
            dist[i]=max;
            for(int j=0;j<=n;j++){
                graph[i][j]=max;
            }
        }
    }

    //prime算法
    public  static  int prime(){
        int sum=0;
        for(int i=0;i<n;i++){
            int t=-1;
            for(int j=1;j<=n;j++){
                if(vist[j]==0&&(t==-1||dist[j]<dist[t]))t=j;
            }
            if(i!=0&&dist[t]==max)return max;
            vist[t]=1;
            for(int j=1;j<=n;j++){
                if(vist[j]==0)dist[j]=Math.min(dist[j],graph[t][j]);
            }
            if(i!=0)sum+=dist[t];
        }
        return sum;

    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        int m=in.nextInt();
        start();
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            int q=in.nextInt();
            graph[a][b]=graph[b][a]=Math.min(graph[a][b],q);
        }
        int f=prime();
        if(f==max)System.out.println("impossible");
        else System.out.println(f);
    }
}
```





### 13、kruskal

将所有边放到堆里面

然后从小到大取出

如果这条边的两个点不在一个集合，就加入最小生成树

最小堆加并查集

```java
class  Main11{
    static  int []parent;

    static int find(int x){
        if(x!=parent[x])parent[x]=find(parent[x]);
        return parent[x];
    }
    static PriorityQueue<tree>heep=new PriorityQueue<>();
    public static void main(String[] args) {
       Scanner in=new Scanner(System.in);
       int n=in.nextInt();
       int m=in.nextInt();
       parent=new int[n+1];
       for(int i=0;i<m;i++){
           int a=in.nextInt();
           int b=in.nextInt();
           int q=in.nextInt();
           heep.add(new tree(a,b,q));
       }
       for(int i=1;i<=n;i++){
           parent[i]=i;
       }

       //算法
       int sum=0;
       int cnt=0;
       for(int i=0;i<m;i++){
           tree t=heep.poll();
           int a=t.a;
           int b=t.b;
           int c=t.q;
           int root1=find(a);
           int root2=find(b);
           if(root1!=root2){
             cnt++;
             parent[root1]=root2;
             sum+=c;
           }
       }
        if(cnt<n-1) System.out.println("impossible");
        else
        System.out.println(sum);
    }

}

class tree implements Comparable<tree>{
    int a;
    int b;
    int q;

    public tree(int a, int b, int q) {
        this.a = a;
        this.b = b;
        this.q = q;
    }

    @Override
    public int compareTo(tree o) {
        return this.q-o.q;
    }
}
```





### 14、二分图染色

定义：

就是可以将图中的顶点分为两个集合

每个集合中的元素没有交集

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016010537.png)



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221016022329.png" style="zoom:50%;" />

二分图的性质就是不能有含有奇数条边的环

因为一个点属于1他连接的点肯定属于2  如果是环有奇数边  那么 第一个点为2      和刚开始矛盾了 

我们可以用染色法来进行判断

dfs

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831110953.png)

```java
import java.util.*;
class Main{
    static  int []g=new int[100010];
    static  int[]next=new int[200020];
    static  int[]value=new int[200010];
    static  int[]color=new int[100010];
    static  int index=0;
    public static void insert(int a,int b){
        value[index]=b;
        next[index]=g[a];
        g[a]=index++;
    }

    public static boolean dfs(int u,int c){
        color[u]=c;
        for(int i=g[u];i!=-1;i=next[i]){
            int j=value[i];
            if(color[j]==0){
                //将当前结点染成不一样的颜色  当前为1 那么子节点为2  否则为1
                if(dfs(j,3-c)==false)return false;
            }
            else {
              //  如果颜色一样返回false
                if(color[j]==c)return false;
            }
        }
        return true;
    }
    public static void main(String[] args) {
        Scanner in=new Scanner(System.in);
        int n=in.nextInt();
        int m=in.nextInt();
        for(int i=1;i<=n;i++)g[i]=-1;
        for(int i=0;i<m;i++){
            int a=in.nextInt();
            int b=in.nextInt();
            insert(a,b);
            insert(b,a);
        }
        boolean flag=true;
        for(int i=1;i<=n;i++){
            if(color[i]==0){
                //还没被染色就染为1
                if(dfs(i,1)==false){
                    flag=false;
                    break;
                }
            }
        }
        if(flag==true) System.out.println("Yes");
        else System.out.println("No");
    }
}
```





### 15、匈牙利算法

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831132251.png)









```C++
#include <iostream>
#include <cstring>
#include <algorithm>

using namespace std;

        const int n=510,m=100010;
        int g[n],value[m],ne[m],idx;
        int match[n];
        bool st[n];

        bool find(int x){
        for(int i=g[x];i!=-1;i=ne[i]){
           int j=value[i];
           if(st[j]==false){
              st[j]=true;
              if(match[j]==0||find(match[j])==true){
              match[j]=x;
              return true;
             }
          }
        }
            return false;
        }

        void add(int a, int b)  // 添加一条边a->b
        {
        value[idx] = b, ne[idx] = g[a], g[a] = idx++ ;
        }


        int main(){
        int n1,n2,m;
        scanf("%d%d%d", &n1, &n2,&m);
        memset(g,-1,sizeof g);

        while(m--){
          int a,b;
          scanf("%d%d", &a, &b);
           add(a,b);
        }
        int sum=0;
        for(int i=1;i<=n1;i++){
            memset(st, 0, sizeof st);
            if(find(i))sum++;
        }
           printf("%d",sum);
            return 0;
        }
```





## 二十二、动态规划

### 背包

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831161904.png)



### 1、01背包

给定价值数组，重量数组，每种物品只能放一个，最大体积为M  求背包最大价值

思路：

我们用二维数组来表示当前状态f

f(i)(j)表示当前遍历到第i个物品时候最大价值，j表示当前还能容纳的物品重量

两个状态：

其中f(i-1)(j)表示上一个物品转移到当前，不包含当前物品i

还有一种状态，就是包含当前物品i,这个状态是由f(i-1)(j-v(i))+w(i)转移来的   条件是就j>=v(i)

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        int f[1001][1001];
        int w[1001];
        int v[1001];
        int main()
        {
            int n,m;
            cin >> n>>m;
            for(int i=1;i<=n;i++){
               cin>>v[i]>>w[i];
            }
            for(int i=1;i<=n;i++){
               for(int j=0;j<=m;j++){
                  f[i][j]=f[i-1][j];
                  if(j>=v[i])f[i][j]=max(f[i][j],f[i-1][j-v[i]]+w[i]);
             }
          }
        cout<<f[n][m];
        return 0;
        }
```



### 2、完全背包

物品无限个

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831212952.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220831215819.png)

优化为二重循环

```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        int f[1001][1001];
        int w[1001];
        int v[1001];
        int main()
        {
           int n,m;
           cin >> n>>m;
          for(int i=1;i<=n;i++){
            cin>>v[i]>>w[i];
          }
          for(int i=1;i<=n;i++){
            for(int j=0;j<=m;j++){
              f[i][j]=f[i-1][j];
             if(j>=v[i])f[i][j]=max(f[i][j],f[i][j-v[i]]+w[i]);
           }
         }
           cout<<f[n][m];
           return 0;
        }
```





### 3、多重背包



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220901044035.png)

```c++
#include <iostream>
#include <cstring>
#include<algorithm>
using namespace std;

        int v[110],w[110],s[110];
        int dp[110][110];
        int main()
        {
           int n,m;
            cin>>n>>m;
        for(int i=1;i<=n;i++){
            cin>>v[i]>>w[i]>>s[i];
        }
           for(int i=1;i<=n;i++){
              for(int j=0;j<=m;j++){
               for(int k=0;k<=s[i]&&j-v[i]*k>=0;k++){
                 dp[i][j]=max(dp[i][j],dp[i-1][j-k*v[i]]+k*w[i]);
               }
             }
          }
            cout<<dp[n][m];
        }
```

第一种暴力做法

这里可以看成特殊的完全背包，限制K的大小







优化:

我们首先确认三点：

（1）我们知道转化成01背包的基本思路就是：判断每件物品我是取了你好呢还是不取你好。

（2）我们知道任意一个实数可以由二进制数来表示，也就是2^0~2^k其中一项或几项的和。

（3）这里多重背包问的就是每件物品取多少件可以获得最大价值。

分析：

如果直接遍历转化为01背包问题，是每次都拿一个来问，取了好还是不取好。那么根据数据范围，这样的时间复杂度是O(n^3),也就是1e+9，这样是毫无疑问是会TLE的。

假如10个取7个好，那么在实际的遍历过程中在第7个以后经过状态转移方程其实已经是选择“不取”好了。现在，用二进制思想将其分堆，分成k+1个分别有2^k个的堆，然后拿这一堆一堆去问，我是取了好呢，还是不取好呢，经过dp选择之后，结果和拿一个一个来问的结果是完全一样的，因为dp选择的是最优结果，而根据第二点任意一个实数都可以用二进制来表示，如果最终选出来10个取7个是最优的在分堆的选择过程中分成了2^0=1,2^1=2,2^2=4,10 - 7 = 3 这四堆，然后去问四次，也就是拿去走dp状态转移方程，走的结果是第一堆1个，取了比不取好，第二堆2个，取了比不取好，第三堆四个，取了比不取好，第四堆8个，取了还不如不取，最后依旧是取了1+2+4=7个。

Tip:参考博客

如果仍然不是很能理解的话，取这样一个例子:要求在一堆苹果选出n个苹果。我们传统的思维是一个一个地去选，选够n个苹果就停止。这样选择的次数就是n次

二进制优化思维就是：现在给出一堆苹果和10个箱子，选出n个苹果。将这一堆苹果分别按照1,2,4,8,16,.....512分到10个箱子里，那么由于任何一个数字x ∈[1,1024]
都可以从这10个箱子里的苹果数量表示出来，但是这样选择的次数就是 ≤10次 。

这样利用二进制优化，时间复杂度就从O(n^3)降到O(n^2logS),从4*10^9降到了2*10^7。

作者：大厂狗狗
链接：https://www.acwing.com/solution/content/20115/
来源：AcWing
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

我们吧多个物品分成多个二次方组，然后把他们看出01背包

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

        const int N=15000,M=2010;
        int n,m;
        int v[N],w[N];
        int f[N];
        int main(){
            cin>>n>>m;
           int a,b,s;
           int cnt=1;
           for(int i=0;i<n;i++){
             cin>>a>>b>>s;
            int k=1;
            while(k<=s){
               cnt++;
              v[cnt]=a*k;
              w[cnt]=b*k;
              s=s-k;
              k=k*2;
           }
        if(s>0){
           cnt++;
           v[cnt]=s*a;
            w[cnt]=b*s;
          }
        }
        n=cnt;

        //01背包一维优化
        for(int i=1;i<=n;i++)
            for(int j=m;j>=v[i];j--)
                f[j]=max(f[j],f[j-v[i]]+w[i]);

        cout<<f[m];
        return 0;
        }
```





### 4、分组背包

每个组有多个物品，并且每个组只能拿一个物品，有多个组



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220904045919.png)



```c++
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
        const int N = 110;
        int f[N][N];
        int w[N][N],v[N][N],s[100];
        int main(){
           int n,m;
            cin>>n>>m;
        for(int i=1;i<=n;i++){
             cin>>s[i];
           for(int j=0;j<s[i];j++){
              cin>>v[i][j]>>w[i][j];
           }
         }

          for(int i=1;i<=n;i++){
              for(int j=0;j<=m;j++){
                 for(int k=0;k<s[i];k++){
                    f[i][j]=max(f[i-1][j],f[i][j]);
                    if(v[i][k]<=j)
                     f[i][j]=max(f[i][j],f[i-1][j-v[i][k]]+w[i][k]);
                  }
              }
         }

           cout<<f[n][m];
        }
```



### 5、线性dp

最长上升子序列问题



最长公共子序列

思路：

f(i)(j)表示前第一个字符串前i个字母出现且在第二个字符串前j个字母出现的最长公共子序列

可以分成四个状态

第i个字符和第j个字符要不要选

其实第二种情况和第三种包括了第一种，所以我们枚举的时候只要枚举三种情况就行了

![微信截图_20220908201544](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220908201544.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909122817.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 1010;
        char s1[1010],s2[1010];
        int f[1010][1010];
        int main()
        {
           int n,m;
           cin>>n>>m;
           scanf("%s%s",s1+1,s2+1);
           for(int i=1;i<=n;i++){
              for(int j=1;j<=m;j++){
                  f[i][j]=max(f[i-1][j],f[i][j-1]);
                if(s1[i]==s2[j])f[i][j]=max(f[i][j],f[i-1][j-1]+1);
              }
           }
         cout<<f[n][m];
          return 0;
     }
```



### 6、区间dp

题目：

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909123256.png)

思路：

![微信截图_20220909103456](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220909103456.png)

我们最终肯定是变成两堆石子

起点和终点分别是i j

分割点是K

所以有上面的式子

同时最后两堆合并时候代价就是两堆的总和，可以用前缀和计算

然后左右两边按照相同的方式去计算

代码如下：

```CPP
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
        const int N = 310;
        int f[N][N];
        int s[N];
        int main()
        {
           int n;
            cin>>n;
            for(int i=1;i<=n;i++)cin>>s[i];
        //前缀和
             for(int i=1;i<=n;i++){
               s[i]=s[i-1]+s[i];
            }
        //len长度  i+len-1右端点距离
            for(int len=2;len<=n;len++){
               for(int i=1;i+len-1<=n;i++){
                  int l=i;
                  int r=i+len-1;
                  f[l][r]=100000000;
                  for(int k=l;k<r;k++){
                      f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+s[r]-s[l-1]);
                 }
              }
            }
            cout<<f[1][n];
        }
```



### 7、计数dp

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220911030701.png)

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
// f[i][j] = f[i - 1][j] + f[i][j - i]
//表示选取前i哥整数恰好拼成j的方案
        int f[1010][1010];
        int e=1e9+7;
        int main()
        {
            int n;
           cin>>n;
            for(int i=0;i<=n;i++)f[i][0]=1;
            for(int i=1;i<=n;i++){
               for(int j=0;j<=n;j++){
               f[i][j]=f[i-1][j]%e;
               if(j>=i)f[i][j]=(f[i-1][j]+f[i][j-i])%e;
               }
            }
          cout<<f[n][n];
          return 0;
        }
```



思路：

思路：把1,2,3, … n分别看做n个物体的体积，这n个物体均无使用次数限制，问恰好能装满总体积为n的背包的总方案数（完全背包问题变形）

初值问题：
求最大值时，当都不选时，价值显然是 0
而求方案数时，当都不选时，方案数是 1（即前 i 个物品都不选的情况也是一种方案），所以需要初始化为 1
即：for (int i = 0; i <= n; i ++) f[i][0] = 1;
等价变形后： f[0] = 1

状态计算：

f[i][j]f[i][j] 表示前i个整数（1,2…,i）恰好拼成j的方案数
求方案数：把集合选0个i，1个i，2个i，…全部加起来
f[i][j] = f[i - 1][j] + f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
f[i][j - i] = f[i - 1][j - i] + f[i - 1][j - 2 * i] + ...;
因此 f[i][j]=f[i−1][j]+f[i][j−i];f[i][j]=f[i−1][j]+f[i][j−i]; (这一步类似完全背包的推导）





### **8、状态压缩(难)**

思路：

我们先把横着的摆放好，那么竖着的就自然好了，所以我们计算多少符合条件的横着的摆放法

就是用一个二维数组记录当前的状态

f(i)(j)表示第i列的状态为j   j表示这一整列的二进制表示

所以要从前一列转移满足：

1、当前格子不能和上一列的格子冲突       当前格子是由上一层格子伸过来的       所以上一层格子必须为0

2、前一列的状态不能有连续奇数个0   这样子才能放的下

第一个条件可以用j&k==0

第二个条件用（j|k)  不存在连续奇数0

我们输入n m 表示行和列

所以我们没次要预处理  从0到1<<n这么多数，因为有n行 所以最大为2的n次方  也就是1左移n位减一

然后对每个数判断是不是有连续奇数个0

这里可以用移位   

最后在动态规划





![微信截图_20220915024319](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20220915024319.png)

![微信截图_20221002031013](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002031013.png)



```cpp
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 12,M=1<<N;
int n,m;
long long  f[N][M];
//判断这个数是否有连续的奇数0
bool st[M];
int main(){
    while(cin >> n >> m,m || n){
        //初始化
        memset(f, 0, sizeof f);
          for(int i = 0;i < 1 << n; i++){
             st[i] = true;
             int cnt = 0;
             for(int j = 0; j < n; j++){
                 if(i >> j & 1){
                 if(cnt & 1)st[i]=false;
                 cnt = 0;
             }else {
             cnt ++;
               }
         }
        if(cnt & 1)st[i] = false;
            }
        f[0][0] = 1;
          for(int i = 1;i <= m; i ++){
            for(int j = 0; j<1 << n; j++){
               for(int k = 0;k< 1 << n; k++){
                  if((j&k)==0 && st[j|k]){
                    f[i][j]+=f[i-1][k];
                    }
               }
            }
          }
          cout<<f[m][0]<<endl;
         }
           return 0;
        }
```







状态压缩2

解法：

这里用二维数组表示f(i)(j)

表示从0到j   的状态 为i   并且i的第j位为1

倒数第二个点k

从0到 i  的状态表示为i减去j   (这里的减去是把i的二进制数第j个位置变成0，可以用  i-(1<<j)表示)  再加上w(k)(j);





![微信截图_20221002033300](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002033300.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221002035509.png)





```cPP
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 20,M=1<<N;
int n;
int w[N][N];
int f[M][N];
int main(){
    cin >> n;
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
          cin >> w[i][j];
          }
        }
        memset(f, 0x3f, sizeof f);

        //在零号点走到零号点
        f[1][0]=0;
        for(int i=0;i<1<<n;i++){
          for(int j=0;j<n;j++){
             if(i>>j&1){
                for(int k=0;k<n;k++){
                    if((i-(1<<j))>>k&1){
                       f[i][j]=min(f[i][j],f[(i-(1<<j))][k]+w[k][j]);
                    }
                 }
                }
              }
          }
        cout<<f[(1<<n)-1][n-1];
        return 0;
        }
```





### 9、树型dp

两个状态 

f(u)(0)表示当前节点不选的最大幸福感

f(u)(1)表示选当前节点的最大幸福感

然后递归处理

这里建图用邻接表

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006213819.png)





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006174743.png)



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221006175029.png)



```cpp
#include<cstring>
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 6010;
int e[N],ne[N],g[N];
int idx;
int happy[N];
int havefather[N];
int f[N][2];

void creat(int a,int b){
    e[idx] = b;
    ne[idx] = g[a];
    g[a] = idx++;
}
void dfs(int u){
    f[u][1] = happy[u];
    for(int i = g[u] ; i != -1 ;i=ne[i]){
        int j = e[i];
        dfs(j);
        f[u][1] += f[j][0];
        f[u][0] += max(f[j][0],f[j][1]);
    }
}

int main(){
    int n;
    cin>>n;
    for(int i = 1 ;i <= n;i ++){
        cin>>happy[i];
    }

    memset(g, -1, sizeof g);
    for(int i = 0;i<n -1 ;i++){
        int a,b;
        cin >> a >> b;
        havefather[a] = 1;
        creat(b,a);
    }

        //找出根节点
         int root = 1;
    while(havefather[root])root++;

        dfs(root);
        int mx = max(f[root][0],f[root][1]);
        cout<<mx;
        return 0;
}
```





### 10、搜索dp



思路：

f(i)(j)  表示当前 i j 这个位置最大距离

可以用 下一个状态加一表示

dfs的变形

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221012120015.png)

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221012212700.png)

```cpp
#include<algorithm>
#include<iostream>
#include<cstring>
using namespace std;

const int N=310;
int f[N][N];
int h[N][N];
int n,m;
int d1[4]={1,0,-1,0};
int d2[4]={0,1,0,-1};

int dfs(int i,int j){
   int&v=f[i][j];
   if(v!=-1)return v;
   v=1;
   for(int w=0;w< 4;w++){
      int a=i+d1[w];
      int b=j+d2[w];
      if(a>=1&&a<=n&&b>=1&&b<=m&&h[i][j]>h[a][b]){
         v=max(v,dfs(a,b)+1);
      }
   }
      return v;
}
int main(){
   cin>>n>>m;
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
         cin>>h[i][j];
             }
      }
   int res=1;
   memset(f,-1,sizeof f);
   for(int i=1;i<=n;i++){
      for(int j=1;j<=m;j++){
        res=max(res,dfs(i,j));
        }
   }
   cout<<res;
   return 0;  
}
```



## 二十三、高级数据结构

### 1、树状数组

```
树状数组
引入问题
给出一个长度为nn的数组，完成以下两种操作：
1. 将第ii个数加上kk
2. 输出区间[i,j][i,j]内每个数的和

朴素算法
单点修改：O(1)O(1)
区间查询：O(n)O(n)
使用树状数组
单点修改：O(logn)O(logn)
区间查询：O(logn)O(logn)
前置知识
lowbit()lowbit()运算：非负整数xx在二进制表示下最低位1及其后面的0构成的数值。

举例说明：
lowbit(12)=lowbit([1100]2)=[100]2=4lowbit(12)=lowbit([1100]2)=[100]2=4
函数实现：

int lowbit(int x)
{
    return x & -x;
}
树状数组思想
树状数组的本质思想是使用树结构维护”前缀和”，从而把时间复杂度降为O(logn)O(logn)。

对于一个序列，对其建立如下树形结构：


```

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114021821.png" style="zoom:67%;" />



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114022000.png" style="zoom: 80%;" />



<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221114021846.png" style="zoom:67%;" />



### 2、线段树







### **3、离散化**

主要是把分散的带你聚集在一起  然后用前缀和求

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221029131633.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int a[300010];
vector<pair<int,int>>add;
vector<int>alls;
vector<pair<int,int>>quary;
int s[300010];
//根据值找离散后的下标
int find(int x){
    int n = alls.size();
    int l = 0;
    int r = n -1 ;
    while(l < r){
        int mid = (l + r)/2;
        if(alls[mid] >= x){
            r = mid;
        }else {
            l = mid + 1;
        }
    }
    return r + 1;
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i = 0 ; i < n ; i ++){
        int x,c;
        cin>>x>>c;
        alls.push_back(x);
        add.push_back({x,c});
    }
    for(int  i = 0 ; i < m ; i ++){
        int l,r;
        cin>>l>>r;
        quary.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    //去重
    sort(alls.begin(),alls.end());
    alls.erase(unique(alls.begin(),alls.end()),alls.end());
    
    //预处理前缀和
    for(auto&k : add){
        int x = find(k.first);
        a[x] += k.second;
    }
    
    for(int i = 1 ; i <= alls.size() ; i ++){
         s[i] = s[i - 1] + a[i];
    }
    
    //处理询问
    for(auto& k: quary){
        int  l = k.first;
        int  r = k.second;
        l = find(l);
        r = find(r);
        cout<<s[r] - s[l - 1]<<endl;;
    }
    return 0;
    
}
```





## 二十四、数学

### 1、试除法判断质数

没什么技巧

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include<cmath>
using namespace std;
bool judge (int x){
    if(x <= 1)return false;
    int mid = (int)(sqrt(x*1.0));
    for(int i  = 2 ; i <= mid ; i ++ ){
        if(x % i == 0)return false;
    }
    return true;
}
int main()
{
    int n;
    cin>>n;
    for(int i  = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        if(judge(a))cout<<"Yes"<<endl;
        else cout<<"No"<<endl;
    }
    return 0;
}
```





### 2、分解质因数

这里能确保每一次的i是质数 因为每一个合数可以分解为质数乘另一个数 所以合数肯定被前面的操作除完了

<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221104020211.png" style="zoom:67%;" />

```cpp
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
#include <cmath>

void count(int x){
    int a = (int)sqrt(x);
    for(int i  = 2 ; i <=a ; i ++){
        if(x % i == 0){
            int sum = 0;
            while(x % i == 0){
                sum ++;
                x /=i;
            }
            cout<<i<<" "<<sum<<endl;
        }
    }
    if(x > 1)cout<<x<<" "<<1<<endl;
}
int main(){
    int n;
    cin>>n;
    for(int i = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        count(a);
        cout<<endl;
    }
    return 0;
}
```



### 3、质数

找出1到n中的所有质数

```cpp
void get_primes2(){
    for(int i=2;i<=n;i++){

        if(!st[i]) primes[cnt++]=i;//把素数存起来
        for(int j=i;j<=n;j+=i){//不管是合数还是质数，都用来筛掉后面它的倍数
            st[j]=true;
        }
    }

}
2.诶氏筛法 O(nloglogn)O(nloglogn)
C++ 代码
void get_primes1(){
    for(int i=2;i<=n;i++){
        if(!st[i]){
            primes[cnt++]=i;
            for(int j=i;j<=n;j+=i) st[j]=true;//可以用质数就把所有的合数都筛掉；
        }
    }
}
3.线性筛法 O(n)O(n)
C++ 代码
void get_primes(){
    //外层从2~n迭代，因为这毕竟算的是1~n中质数的个数，而不是某个数是不是质数的判定
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;
        for(int j=0;primes[j]<=n/i;j++){//primes[j]<=n/i:变形一下得到——primes[j]*i<=n,把大于n的合数都筛了就
        //没啥意义了
            st[primes[j]*i]=true;//用最小质因子去筛合数

            //1)当i%primes[j]!=0时,说明此时遍历到的primes[j]不是i的质因子，那么只可能是此时的primes[j]<i的
            //最小质因子,所以primes[j]*i的最小质因子就是primes[j];
            //2)当有i%primes[j]==0时,说明i的最小质因子是primes[j],因此primes[j]*i的最小质因子也就应该是
            //prime[j]，之后接着用st[primes[j+1]*i]=true去筛合数时，就不是用最小质因子去更新了,因为i有最小
            //质因子primes[j]<primes[j+1],此时的primes[j+1]不是primes[j+1]*i的最小质因子，此时就应该
            //退出循环，避免之后重复进行筛选。
            if(i%primes[j]==0) break;
        }
    }

}
```

```cpp
void get_prime(int n)
{
    for(int i = 2; i <= n; i++)
    {
        if(!st[i])                              //如果还没被标记过，就说明这是个质数，就把它加入到队列中
            prime[cnt++] = i;

        for(int j = 0; prime[j] <= n / i; j++)  //确保第j个质数和i相乘不会爆n
        {
            st[prime[j] * i] = true;
            /*
                prime[]数组中的素数是递增的,当i能整除prime[j]，那么i*prime[j+1]这个合数
                肯定被prime[j]乘以某个数筛掉。
                因为i中含有prime[j],prime[j]比prime[j+1]小，
                即i=k*prime[j]，那么i*prime[j+1]=(k*prime[j])*prime[j+1]=k’*prime[j]，
                接下去的素数同理。所以不用筛下去了。
                因此，在满足i%prime[j]==0这个条件之前以及第一次满足改条件时,
                prime[j]必定是prime[j]*i的最小因子。
            */
            if(i % prime[j] == 0)               
                break;
        }
    }
}

```





### 4、试除法求约数



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221104025330.png)



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <vector>
using namespace std;

vector<int>get(int x){
    vector<int>v;
    for(int i = 1 ; i<= x/i; i ++ ){
        if(x % i == 0){
            v.push_back(i);
           if(i != x/i)v.push_back(x/i);
        }
    }
    sort(v.begin(),v.end());
    return v;
}
int main()
{
    int n;
    cin>>n;
    for(int i = 0 ; i < n ; i ++){
        int a;
        cin>>a;
        auto v = get(a);
        for(int k:v){
            cout<<k<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```



### 5、最大公约数

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
int find(int a,int b){
    if(b == 0)return a;
    else return find(b,a % b);
}
int main(){
    int n;
    cin>>n;
    while(n --){
        int a,b;
        cin>>a>>b;
        cout<<find(a,b)<<endl;
    }
    return 0;
}
```





## 二十五、贪心

### 1、区间找点

思路：安第二点从小到大进行排序

然后每次维护右端点的值

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include <vector>
int main(){
    int n;
    cin>>n;
    vector<vector<int>>v(n);
    for(int i = 0; i <n  ; i ++){
        int a,b;
        scanf("%d%d",&a,&b);
        v[i].push_back(a);
        v[i].push_back(b);
    }
    //排序
    sort(v.begin(),v.end(),[&](vector<int>n1,vector<int>n2){
        return n1[1]<n2[1];
    });
    int sum = 1;
    int last = v[0][1];
    for(int i = 1; i < n ; i ++){
        //cout<<v[i][0]<<endl;
        if(v[i][0]<= last)continue;
        else {
            sum ++;
            last = v[i][1];
        }
    }
    cout<<sum;
    return 0;
}
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113154551.png)



思路和上面一题一样的

![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113155510.png)



### 2、区间分组

思路：

用结构体存储  然后按照左端点从左到右进行排序

这里用小顶堆来维护每个组的最右边的位置

如果堆中的数大于当前点左边位置   那么新增一个组  也就是第一个组都能被覆盖

否则就加入第一个组 将堆顶pop出  更新右端点的距离

最后堆中的数量就是分组的个数



```cpp
#include <iostream>
#include <algorithm>
#include <queue>
#include <cstdio>

using namespace std;

const int N = 100010;

int n;
struct Range
{
    int l, r;
    bool operator< (const Range &W)const
    {
        return l < W.l;
    }
}range[N];

int main()
{
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ )
    {
        int l, r;
        scanf("%d%d", &l, &r);
        range[i] = {l, r};
    }

    sort(range, range + n);

    priority_queue<int, vector<int>, greater<int>> heap;
    for (int i = 0; i < n; i ++ )
    {

        if (heap.empty() || heap.top() >= range[i].l){
            heap.push(range[i].r);
        }
        else {
            heap.pop();
            heap.push(range[i].r);
        }
    }

    printf("%d\n", heap.size());

    return 0;
}

```





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113160150.png)



### 3、区间覆盖

思路：

就是每次找出可以覆盖当前区间左端点的  区间中右端点最大的区间  然后更新左端点



```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
typedef struct Range{
    int l,r;
}range;
int main(){
    int st,ed;
    scanf("%d%d",&st,&ed);
    int n;
    cin>>n;
    range r[n];
    for(int i = 0 ;i < n ; i ++){
        scanf("%d%d",&r[i].l,&r[i].r);
    }
    sort(r,r+n,[&](range r1,range r2){
        return r1.l<r2.l;
    });
    int sum = 0;
    bool flag = false;
    for(int i = 0 ;i < n ; i ++){
       // cout<<i<<endl;
        int j = i;
        int ri = -2e9;
        while(j<n &&r[j].l<=st){
            ri = max(ri,r[j].r);
            j++;
        }
        if(ri<st){
            flag =false;
            break;
        }
         sum ++;
        if(ri >=ed){
            flag = true;
            break;
        }
        i = j -1;
        st = ri;
    }
    if(flag ==false)sum = -1;
    printf("%d",sum);
}
```





![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113161530.png)







### 4、排队打水

我们只需要将把时间长的放后面就行了

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;
#include<vector>
int main(){
    int n;
    cin>>n;
    vector<long long >v(n,0);
    int index = 0;
    while(n --){
        cin>>v[index];
        index ++;
    }
    sort(v.begin(),v.end());
    long long  sum = 0 ;
    long long  count = 0 ;
    for(int i = 0 ;i <v.size(); i ++){
        count += sum;
        sum +=v[i];
    }
    cout<<count<<endl;
    return 0;
}
```



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113163017.png)



### 5、仓库选址

主要是一个不等式   

```cpp
#include <iostream>
#include <cstring>
#include <algorithm>
#include <cmath>

using namespace std;
int main(){
    int n;
    cin>>n;
    long long sum = 0;
    int a[n];
    for(int i = 0 ; i < n ; i ++){
        cin>>a[i];
    }
    sort(a,a+n);
    for(int i = 0 ; i < n ; i ++){
        sum += abs(a[n/2] - a[i]);
    }
    cout<<sum<<endl;
    return 0;
}
```





<img src="https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221108221000.png" style="zoom:67%;" />



![](https://gitee.com/hongshenghyj/typora/raw/master/img/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20221113163227.png)
